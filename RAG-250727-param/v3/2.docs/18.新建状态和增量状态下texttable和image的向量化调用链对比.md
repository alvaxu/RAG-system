# 新建状态和增量状态下text/table和image的向量化调用链对比

## �� **图1：新建状态下的完整向量化调用链**

```
V3MainProcessor._process_documents_new()
    ↓
ContentProcessor.process_document_content()
    ↓
├── TextProcessor.process_batch()     # 文本处理（无向量化）
├── TableProcessor.process_batch()    # 表格处理（无向量化）
└── ImageProcessor.process_images()   # 图片处理（包含向量化）
    ↓
    ├── 图片复制
    ├── 图片增强
    ├── 图片向量化
    └── 元数据生成
    ↓
VectorizationManager.vectorize_all_content()  # 统一向量化管理
    ↓
├── TextVectorizer.vectorize_batch()     # 文本向量化
├── TableVectorizer.vectorize_batch()    # 表格向量化
└── 图片向量化结果直接收集（无需额外调用）
    ↓
ModelCaller.call_text_embedding()  # 文本/表格向量化API调用
```

## �� **图2：增量状态下的完整向量化调用链**

```
V3MainProcessor._process_documents_incremental()
    ↓
V3MainProcessor._process_single_document_incremental()
    ↓
V3MainProcessor._process_pdf_incremental() / _process_json_incremental()
    ↓
ContentProcessor.process_document_content()
    ↓
├── TextProcessor.process_batch()     # 文本处理（无向量化）
├── TableProcessor.process_batch()    # 表格处理（无向量化）
└── ImageProcessor.process_images()   # 图片处理（包含向量化）
    ↓
    ├── 图片复制
    ├── 图片增强
    ├── 图片向量化
    └── 元数据生成
    ↓
V3MainProcessor._vectorize_content_incremental()  # 增量向量化
    ↓
├── VectorizationManager.vectorize_content()  # 文本/表格向量化
│   ↓
│   ├── TextVectorizer.vectorize_batch()     # 文本向量化
│   └── TableVectorizer.vectorize_batch()    # 表格向量化
│       ↓
│       ModelCaller.call_text_embedding()    # 文本/表格向量化API调用
└── 直接收集图片向量化结果（无需额外调用）
```

## 📊 **图3：新建状态 vs 增量状态 - Text/Table向量化对比**

```
新建状态 (Text/Table):
V3MainProcessor._process_documents_new()
    ↓
ContentProcessor.process_document_content()
    ↓
TextProcessor.process_batch() / TableProcessor.process_batch()  # 内容处理
    ↓
VectorizationManager.vectorize_all_content()  # 统一向量化管理
    ↓
TextVectorizer.vectorize_batch() / TableVectorizer.vectorize_batch()
    ↓
ModelCaller.call_text_embedding()

增量状态 (Text/Table):
V3MainProcessor._process_documents_incremental()
    ↓
ContentProcessor.process_document_content()
    ↓
TextProcessor.process_batch() / TableProcessor.process_batch()  # 内容处理
    ↓
V3MainProcessor._vectorize_content_incremental()
    ↓
VectorizationManager.vectorize_content()  # 分散向量化管理
    ↓
TextVectorizer.vectorize_batch() / TableVectorizer.vectorize_batch()
    ↓
ModelCaller.call_text_embedding()

关键差异：
✅ 新建状态：统一管理 + 单阶段向量化
✅ 增量状态：分散管理 + 单阶段向量化
```

## ��️ **图4：新建状态 vs 增量状态 - Image向量化对比**

```
新建状态 (Image):
V3MainProcessor._process_documents_new()
    ↓
ContentProcessor.process_document_content()
    ↓
ImageProcessor.process_images()  # 完整处理流程
    ↓
├── 图片复制
├── 图片增强
├── 图片向量化 ← 唯一阶段向量化
└── 元数据生成
    ↓
VectorizationManager.vectorize_all_content()
    ↓
直接收集已向量化的结果（无额外API调用）

增量状态 (Image):
V3MainProcessor._process_documents_incremental()
    ↓
ContentProcessor.process_document_content()
    ↓
ImageProcessor.process_images()  # 完整处理流程
    ↓
├── 图片复制
├── 图片增强
├── 图片向量化 ← 唯一阶段向量化
└── 元数据生成
    ↓
V3MainProcessor._vectorize_content_incremental()
    ↓
直接收集已向量化的结果（无额外API调用）

关键差异：
✅ 新建状态：单阶段向量化（只处理，不检查补充）
✅ 增量状态：单阶段向量化（只处理，不检查补充）
```

## 🔍 **调用链差异总结**

### **清理后的架构特点：**
1. **统一ImageVectorizer**：所有图片向量化都通过`vectorization.image_vectorizer.ImageVectorizer`
2. **消除重复调用**：删除了"辅助工作"中的重复图片向量化逻辑
3. **简化流程**：图片向量化只在`ImageProcessor.process_images()`中执行一次

### **新建状态特点：**
1. **统一管理**：通过`VectorizationManager.vectorize_all_content()`统一管理所有向量化
2. **单阶段向量化**：图片只处理一次，不重复向量化
3. **完整性保证**：确保所有内容都被正确向量化
4. **资源优化**：避免重复的API调用

### **增量状态特点：**
1. **分散管理**：文本/表格通过VectorizationManager，图片直接收集结果
2. **单阶段向量化**：图片只处理一次，不重复向量化
3. **效率优先**：避免重复处理，减少API调用
4. **资源节约**：更高效的内存和API使用

### **清理后的优势：**
- **架构统一**：图片向量化逻辑完全统一，无重复实现
- **性能提升**：消除重复调用，减少资源浪费
- **维护简化**：单一实现，便于维护和调试
- **两种模式一致**：新建和增量状态下的图片向量化流程完全一致

### **重要说明：**
经过清理后，新建状态和增量状态下的图片向量化调用链**完全一致**，都只在`ImageProcessor.process_images()`中执行一次，不再有"辅助工作"中的重复向量化调用。这确保了系统的一致性和效率。