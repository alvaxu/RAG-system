## TableProcessor详细设计文档（重写版）

### 1. 模块概述

**TableProcessor** 是V3版本向量数据库构建系统的核心模块之一，负责处理文档中的表格内容。该模块基于现有 `document_processing/table_processor.py` 的优秀设计，严格按照设计文档的元数据要求，实现表格内容分析、智能分块、HTML生成和向量化等功能。

**核心功能**：
- 表格结构分析和内容提取
- 大表格智能分块处理（参考现有实现）
- HTML格式表格内容生成
- 表格内容向量化（通过ModelCaller）
- 标准化元数据管理（使用TABLE_METADATA_SCHEMA）

### 2. 整体流程

```
表格输入 → 结构分析 → 内容提取 → 智能分块 → HTML生成 → 向量化 → 元数据生成 → 输出结果
```

**详细流程**：
1. **输入检测**：接收表格数据（JSON格式或HTML格式）
2. **结构分析**：分析表格的行数、列数、表头等信息
3. **内容提取**：提取表格的文本内容和结构化信息
4. **智能分块**：当表格过大时，按内容长度进行智能分块（参考现有实现）
5. **HTML生成**：生成用于web展示的HTML格式内容
6. **向量化处理**：通过ModelCaller对表格内容进行向量化
7. **元数据生成**：严格按照TABLE_METADATA_SCHEMA生成标准化元数据
8. **结果输出**：返回处理后的表格chunk列表

### 3. 核心类设计

#### 3.1 TableProcessor（主处理器）

```python
class TableProcessor:
    """
    表格处理器主类
    
    功能：
    1. 统一管理表格处理流程
    2. 协调各个子模块的工作
    3. 处理表格分块和向量化
    4. 生成标准化元数据（使用TABLE_METADATA_SCHEMA）
    """
    
    def __init__(self, config_manager):
        self.config_manager = config_manager
        self.table_analyzer = TableAnalyzer()
        self.table_extractor = TableExtractor()
        self.table_formatter = TableFormatter()
        self.model_caller = ModelCaller(config_manager)  # 使用统一的ModelCaller
        self._load_configuration()
    
    def process_table(self, table_data: Dict, source_type: str = None,
                     metadata: Dict = None) -> Dict:
        """
        处理单个表格
        
        :param table_data: 表格数据字典
        :param source_type: 来源类型（pdf/mineru_output）
        :param metadata: 额外元数据
        :return: 处理结果字典（符合TABLE_METADATA_SCHEMA）
        """
        try:
            # 1. 表格结构分析
            structure_result = self._analyze_table_structure(table_data)
            
            # 2. 表格内容提取
            content_result = self._extract_table_content(table_data, structure_result)
            
            # 3. 智能分块处理（如果需要）
            chunked_result = self._process_table_chunking(content_result)
            
            # 4. HTML格式生成
            html_result = self._generate_html_content(chunked_result)
            
            # 5. 表格向量化（通过ModelCaller）
            vectorization_result = self._vectorize_table_content(content_result)
            
            # 6. 构建最终结果（使用TABLE_METADATA_SCHEMA）
            result = self._build_final_result(
                structure_result, content_result, html_result, 
                vectorization_result, metadata
            )
            
            return result
            
        except Exception as e:
            logging.error(f"表格处理失败: {str(e)}")
            return self._build_error_result(str(e), metadata)
    
    def process_batch(self, tables: List[Dict], metadata: List[Dict] = None) -> List[Dict]:
        """
        批量处理表格
        
        :param tables: 表格数据列表
        :param metadata: 元数据列表
        :return: 处理结果列表
        """
        results = []
        total_tables = len(tables)
        
        for i, table_data in enumerate(tables):
            try:
                # 获取对应的元数据
                table_metadata = metadata[i] if metadata and i < len(metadata) else {}
                
                # 处理单个表格
                result = self.process_table(table_data, metadata=table_metadata)
                results.append(result)
                
                # 进度报告
                if (i + 1) % 10 == 0 or (i + 1) == total_tables:
                    logging.info(f"表格处理进度: {i + 1}/{total_tables}")
                    
            except Exception as e:
                logging.error(f"批量处理表格 {i} 失败: {str(e)}")
                error_result = self._build_error_result(str(e), 
                    metadata[i] if metadata and i < len(metadata) else {})
                results.append(error_result)
        
        return results
    
    def _analyze_table_structure(self, table_data: Dict) -> Dict:
        """分析表格结构"""
        return self.table_analyzer.analyze(table_data)
    
    def _extract_table_content(self, table_data: Dict, structure: Dict) -> Dict:
        """提取表格内容"""
        return self.table_extractor.extract(table_data, structure)
    
    def _process_table_chunking(self, content_result: Dict) -> Dict:
        """处理表格分块"""
        return self.table_formatter.process_chunking(content_result)
    
    def _generate_html_content(self, chunked_result: Dict) -> Dict:
        """生成HTML内容"""
        return self.table_formatter.generate_html(chunked_result)
    
    def _vectorize_table_content(self, content_result: Dict) -> Dict:
        """表格内容向量化（通过ModelCaller）"""
        vectorization_result = {
            'table_embedding': None,
            'vectorization_status': 'pending',
            'embedding_model': None,
            'vectorization_timestamp': None
        }
        
        try:
            # 获取表格内容用于向量化
            table_text = self._combine_table_text(content_result)
            if table_text:
                # 通过ModelCaller进行向量化
                table_embedding = self.model_caller.call_text_embedding(
                    table_text,
                    metadata={'content_type': 'table', 'source': 'table_processor'}
                )
                vectorization_result['table_embedding'] = table_embedding
                vectorization_result['vectorization_status'] = 'completed'
                # 使用ModelCaller的get_model_info方法获取模型信息
                model_info = self.model_caller.get_model_info('text_embedding')
                vectorization_result['embedding_model'] = model_info.get('model_name', 'unknown')
                vectorization_result['vectorization_timestamp'] = int(time.time())
                
        except Exception as e:
            logging.error(f"表格向量化失败: {str(e)}")
            vectorization_result['vectorization_status'] = 'failed'
            vectorization_result['vectorization_error'] = str(e)
        
        return vectorization_result
    
    def _combine_table_text(self, content_result: Dict) -> str:
        """组合表格文本内容用于向量化"""
        parts = []
        
        # 添加表格标题
        if content_result.get('table_title'):
            parts.append(f"标题: {content_result['table_title']}")
        
        # 添加表头
        if content_result.get('table_headers'):
            headers_text = " | ".join(content_result['table_headers'])
            parts.append(f"表头: {headers_text}")
        
        # 添加表格内容
        if content_result.get('table_content'):
            parts.append(content_result['table_content'])
        
        # 添加表格摘要
        if content_result.get('table_summary'):
            parts.append(f"摘要: {content_result['table_summary']}")
        
        return "\n".join(parts)
    
    def _build_final_result(self, structure: Dict, content: Dict, 
                           html: Dict, vectorization: Dict, metadata: Dict) -> Dict:
        """构建最终结果（使用TABLE_METADATA_SCHEMA）"""
        current_timestamp = int(time.time())
        
        # 使用设计文档中定义的TABLE_METADATA_SCHEMA结构
        result = {
            # 通用元数据字段（COMMON_METADATA_FIELDS）
            'chunk_id': f"table_{int(time.time())}_{uuid.uuid4().hex[:8]}",
            'chunk_type': 'table',
            'source_type': metadata.get('source_type', 'mineru_output'),
            'document_name': metadata.get('document_name', ''),
            'document_path': metadata.get('document_path', ''),
            'page_number': metadata.get('page_number', 1),
            'page_idx': metadata.get('page_idx', 0),
            'created_timestamp': current_timestamp,
            'updated_timestamp': current_timestamp,
            'processing_version': 'V3.0.0',
            'vectorized': vectorization.get('vectorization_status') == 'completed',
            'vectorization_timestamp': vectorization.get('vectorization_timestamp'),
            'embedding_model': vectorization.get('embedding_model'),
            
            # 表格特有字段（TABLE_METADATA_SCHEMA）
            'table_id': content.get('table_id', ''),
            'table_type': content.get('table_type', ''),
            'table_title': content.get('table_title', ''),
            'table_summary': content.get('table_summary', ''),
            'table_rows': content.get('table_rows', 0),
            'table_columns': content.get('table_columns', 0),
            'table_headers': content.get('table_headers', []),
            'table_content': content.get('table_content', ''),  # 用于向量化
            'table_html': html.get('table_html', ''),          # 用于web展现
            
            # 分块信息字段
            'is_subtable': content.get('is_subtable', False),
            'parent_table_id': content.get('parent_table_id', ''),
            'subtable_index': content.get('subtable_index', 0),
            'chunk_start_row': content.get('chunk_start_row', 0),
            'chunk_end_row': content.get('chunk_end_row', 0),
            
            # 关联信息字段
            'related_text': content.get('related_text', ''),
            'related_images': content.get('related_images', []),
            'related_text_chunks': content.get('related_text_chunks', []),
            'table_context': content.get('table_context', ''),
            
            # 向量化信息
            'table_embedding': vectorization.get('table_embedding')
        }
        
        return result
    
    def _build_error_result(self, error_message: str, metadata: Dict) -> Dict:
        """构建错误结果"""
        current_timestamp = int(time.time())
        
        return {
            # 通用元数据字段
            'chunk_id': f"table_error_{int(time.time())}_{uuid.uuid4().hex[:8]}",
            'chunk_type': 'table',
            'source_type': metadata.get('source_type', 'mineru_output'),
            'document_name': metadata.get('document_name', ''),
            'document_path': metadata.get('document_path', ''),
            'page_number': metadata.get('page_number', 1),
            'page_idx': metadata.get('page_idx', 0),
            'created_timestamp': current_timestamp,
            'updated_timestamp': current_timestamp,
            'processing_version': 'V3.0.0',
            'vectorized': False,
            'vectorization_timestamp': None,
            'embedding_model': None,
            
            # 错误信息
            'error': True,
            'error_message': error_message,
            'table_id': metadata.get('table_id', 'unknown'),
            'table_type': 'error',
            'table_embedding': None
        }
    
    def _load_configuration(self):
        """加载配置（使用配置管理文档中的配置结构）"""
        self.config = self.config_manager.get_config()
        # 使用配置管理文档中定义的配置结构
        doc_processing_config = self.config.get('document_processing', {})
        self.chunk_size = doc_processing_config.get('chunk_size', 1000)
        self.chunk_overlap = doc_processing_config.get('chunk_overlap', 200)
        
        # 获取路径配置
        paths_config = self.config.get('paths', {})
        self.input_dir = paths_config.get('input_pdf_dir', './document/orig_pdf')
        self.output_dir = paths_config.get('mineru_output_dir', './document/md')
        self.vector_db_dir = paths_config.get('vector_db_dir', './central/vector_db')
    
    def get_vectorization_status(self) -> Dict:
        """获取向量化状态"""
        return {
            'model_info': self.model_caller.get_model_info('text_embedding'),
            'processor_type': 'table_processor',
            'config': {
                'chunk_size': self.chunk_size,
                'chunk_overlap': self.chunk_overlap
            }
        }
```

#### 3.2 TableAnalyzer（表格分析器）

```python
class TableAnalyzer:
    """
    表格结构分析器
    
    功能：
    1. 分析表格的基本结构信息
    2. 识别表格类型和特征
    3. 提取表格的行数、列数、表头等信息
    """
    
    def analyze(self, table_data: Dict) -> Dict:
        """
        分析表格结构
        
        :param table_data: 表格数据
        :return: 结构分析结果
        """
        try:
            # 提取基本信息
            rows = table_data.get('rows', [])
            headers = table_data.get('headers', [])
            
            # 计算行数和列数
            row_count = len(rows)
            column_count = len(headers) if headers else 0
            
            # 如果没有表头，从第一行推断列数
            if not headers and rows:
                column_count = len(rows[0]) if isinstance(rows[0], list) else 1
            
            # 识别表格类型
            table_type = self._identify_table_type(rows, headers, row_count, column_count)
            
            # 分析表格特征
            features = self._analyze_table_features(rows, headers)
            
            # 估算内容长度（用于分块决策）
            estimated_length = self._estimate_content_length(rows, headers)
            
            return {
                'row_count': row_count,
                'column_count': column_count,
                'headers': headers,
                'table_type': table_type,
                'features': features,
                'has_header': bool(headers),
                'is_regular': self._is_regular_table(rows, column_count),
                'estimated_content_length': estimated_length
            }
            
        except Exception as e:
            logging.error(f"表格结构分析失败: {str(e)}")
            return {
                'row_count': 0,
                'column_count': 0,
                'headers': [],
                'table_type': 'unknown',
                'error': str(e),
                'estimated_content_length': 0
            }
    
    def _identify_table_type(self, rows: List, headers: List, row_count: int, column_count: int) -> str:
        """识别表格类型"""
        if not rows:
            return 'empty_table'
        
        if column_count <= 2:
            return 'simple_list'
        elif column_count <= 5:
            return 'data_table'
        elif column_count <= 10:
            return 'complex_data_table'
        else:
            return 'wide_data_table'
    
    def _analyze_table_features(self, rows: List, headers: List) -> Dict:
        """分析表格特征"""
        features = {
            'has_numeric_data': False,
            'has_date_data': False,
            'has_text_data': False,
            'empty_cells_ratio': 0.0,
            'merge_cells': []
        }
        
        if not rows:
            return features
        
        # 分析数据类型
        for row in rows[:min(10, len(rows))]:  # 只分析前10行
            if isinstance(row, list):
                for cell in row:
                    cell_str = str(cell).strip()
                    if cell_str:
                        if self._is_numeric(cell_str):
                            features['has_numeric_data'] = True
                        elif self._is_date(cell_str):
                            features['has_date_data'] = True
                        else:
                            features['has_text_data'] = True
        
        # 计算空单元格比例
        total_cells = sum(len(row) if isinstance(row, list) else 1 for row in rows)
        empty_cells = sum(1 for row in rows for cell in (row if isinstance(row, list) else [row]) 
                         if not str(cell).strip())
        features['empty_cells_ratio'] = empty_cells / total_cells if total_cells > 0 else 0.0
        
        return features
    
    def _is_regular_table(self, rows: List, column_count: int) -> bool:
        """判断是否为规则表格"""
        if not rows or column_count == 0:
            return False
        
        # 检查每行的列数是否一致
        for row in rows:
            if isinstance(row, list) and len(row) != column_count:
                return False
        
        return True
    
    def _estimate_content_length(self, rows: List, headers: List) -> int:
        """估算表格内容长度（用于分块决策）"""
        total_length = 0
        
        # 表头长度
        if headers:
            total_length += sum(len(str(h)) for h in headers)
        
        # 内容长度（只计算前20行避免过长）
        for row in rows[:20]:
            if isinstance(row, list):
                total_length += sum(len(str(cell)) for cell in row)
            else:
                total_length += len(str(row))
        
        # 估算总长度
        if len(rows) > 20:
            avg_row_length = total_length / 20
            total_length = total_length + avg_row_length * (len(rows) - 20)
        
        return total_length
    
    def _is_numeric(self, text: str) -> bool:
        """判断是否为数字"""
        try:
            float(text.replace(',', '').replace('%', ''))
            return True
        except ValueError:
            return False
    
    def _is_date(self, text: str) -> bool:
        """判断是否为日期"""
        import re
        date_patterns = [
            r'\d{4}-\d{2}-\d{2}',
            r'\d{2}/\d{2}/\d{4}',
            r'\d{4}年\d{2}月\d{2}日'
        ]
        return any(re.match(pattern, text) for pattern in date_patterns)
```

#### 3.3 TableExtractor（表格内容提取器）

```python
class TableExtractor:
    """
    表格内容提取器
    
    功能：
    1. 从表格数据中提取文本内容
    2. 生成结构化的表格描述
    3. 处理表格的关联信息
    """
    
    def extract(self, table_data: Dict, structure: Dict) -> Dict:
        """
        提取表格内容
        
        :param table_data: 表格数据
        :param structure: 结构分析结果
        :return: 提取的内容
        """
        try:
            # 提取基本信息
            table_id = table_data.get('table_id', f"table_{int(time.time())}")
            table_type = structure.get('table_type', 'unknown')
            rows = table_data.get('rows', [])
            headers = structure.get('headers', [])
            
            # 生成表格标题和摘要
            title = self._generate_table_title(table_data, structure)
            summary = self._generate_table_summary(rows, headers, structure)
            
            # 提取表格内容文本
            content_text = self._extract_content_text(rows, headers)
            
            # 提取关联信息
            related_info = self._extract_related_info(table_data)
            
            return {
                'table_id': table_id,
                'table_type': table_type,
                'table_title': title,
                'table_summary': summary,
                'table_rows': structure.get('row_count', 0),
                'table_columns': structure.get('column_count', 0),
                'table_headers': headers,
                'table_content': content_text,
                'related_text': related_info.get('related_text', ''),
                'related_images': related_info.get('related_images', []),
                'related_text_chunks': related_info.get('related_text_chunks', []),
                'table_context': related_info.get('table_context', ''),
                'is_subtable': False,
                'parent_table_id': '',
                'subtable_index': 0,
                'chunk_start_row': 0,
                'chunk_end_row': structure.get('row_count', 0)
            }
            
        except Exception as e:
            logging.error(f"表格内容提取失败: {str(e)}")
            return {
                'table_id': 'error',
                'table_type': 'error',
                'error': str(e)
            }
    
    def _generate_table_title(self, table_data: Dict, structure: Dict) -> str:
        """生成表格标题"""
        # 优先使用已有的标题
        if table_data.get('title'):
            return table_data['title']
        
        # 根据表格特征生成标题
        table_type = structure.get('table_type', '')
        row_count = structure.get('row_count', 0)
        column_count = structure.get('column_count', 0)
        
        if table_type == 'data_table':
            return f"数据表格 ({row_count}行 × {column_count}列)"
        elif table_type == 'simple_list':
            return f"列表数据 ({row_count}项)"
        else:
            return f"表格内容 ({row_count}行 × {column_count}列)"
    
    def _generate_table_summary(self, rows: List, headers: List, structure: Dict) -> str:
        """生成表格摘要"""
        if not rows:
            return "空表格"
        
        table_type = structure.get('table_type', '')
        row_count = structure.get('row_count', 0)
        column_count = structure.get('column_count', 0)
        
        if table_type == 'data_table':
            # 分析数据特征
            numeric_count = 0
            text_count = 0
            
            for row in rows[:min(10, len(rows))]:
                if isinstance(row, list):
                    for cell in row:
                        if self._is_numeric(str(cell)):
                            numeric_count += 1
                        else:
                            text_count += 1
            
            summary_parts = [f"包含{row_count}行{column_count}列数据"]
            if numeric_count > 0:
                summary_parts.append(f"数值型数据{numeric_count}项")
            if text_count > 0:
                summary_parts.append(f"文本型数据{text_count}项")
            
            return "，".join(summary_parts)
        
        elif table_type == 'simple_list':
            return f"包含{row_count}个列表项"
        else:
            return f"包含{row_count}行数据"
    
    def _extract_content_text(self, rows: List, headers: List) -> str:
        """提取表格内容文本"""
        content_parts = []
        
        # 添加表头
        if headers:
            header_text = " | ".join(str(h) for h in headers)
            content_parts.append(header_text)
        
        # 添加数据行
        for row in rows:
            if isinstance(row, list):
                row_text = " | ".join(str(cell) for cell in row)
            else:
                row_text = str(row)
            content_parts.append(row_text)
        
        return "\n".join(content_parts)
    
    def _extract_related_info(self, table_data: Dict) -> Dict:
        """提取关联信息"""
        return {
            'related_text': table_data.get('related_text', ''),
            'related_images': table_data.get('related_images', []),
            'related_text_chunks': table_data.get('related_text_chunks', []),
            'table_context': table_data.get('table_context', '')
        }
    
    def _is_numeric(self, text: str) -> bool:
        """判断是否为数字"""
        try:
            float(text.replace(',', '').replace('%', ''))
            return True
        except ValueError:
            return False
```

#### 3.4 TableFormatter（表格格式化器）

```python
class TableFormatter:
    """
    表格格式化器
    
    功能：
    1. 处理表格分块（完整实现现有table_processor.py的分块策略）
    2. 生成HTML格式的表格内容
    3. 管理分块后的表格结构
    """
    
    def __init__(self, config: Dict = None):
        self.config = config or {}
        self.chunk_size = config.get('chunk_size', 1000)
        self.chunk_overlap = config.get('chunk_overlap', 200)
    
    def process_chunking(self, content_result: Dict) -> Dict:
        """
        处理表格分块
        
        :param content_result: 内容提取结果
        :return: 分块处理结果
        """
        try:
            table_content = content_result.get('table_content', '')
            table_id = content_result.get('table_id', '')
            
            # 检查是否需要分块
            if len(table_content) <= self.chunk_size:
                # 不需要分块
                return {
                    'needs_chunking': False,
                    'chunks': [content_result],
                    'total_chunks': 1
                }
            else:
                # 需要分块
                chunks = self._split_table_into_chunks(content_result)
                return {
                    'needs_chunking': True,
                    'chunks': chunks,
                    'total_chunks': len(chunks)
                }
                
        except Exception as e:
            logging.error(f"表格分块处理失败: {str(e)}")
            return {
                'needs_chunking': False,
                'chunks': [content_result],
                'total_chunks': 1,
                'error': str(e)
            }
    
    def _split_table_into_chunks(self, content_result: Dict) -> List[Dict]:
        """
        将大表格分割为多个子表格
        
        完整实现现有table_processor.py的_split_table_into_subtables_by_size方法
        """
        chunks = []
        table_content = content_result.get('table_content', '')
        table_id = content_result.get('table_id', '')
        table_headers = content_result.get('table_headers', [])
        table_rows = content_result.get('table_rows', 0)
        
        # 计算分块策略（参考现有实现）
        header_length = len(" | ".join(str(h) for h in table_headers)) if table_headers else 0
        content_lines = table_content.split('\n')
        
        if len(content_lines) <= 1:
            # 只有表头或内容很少，不需要分块
            return [content_result]
        
        # 估算每行平均长度
        data_lines = content_lines[1:] if table_headers else content_lines
        if data_lines:
            avg_line_length = sum(len(line) for line in data_lines) / len(data_lines)
        else:
            avg_line_length = 0
        
        # 计算每个分块的目标行数（参考现有实现的逻辑）
        if avg_line_length > 0:
            # 使用现有实现的计算公式
            target_lines_per_chunk = max(1, (self.chunk_size - header_length) // int(avg_line_length * 2))
        else:
            target_lines_per_chunk = 10
        
        # 执行分块
        current_lines = []
        chunk_index = 0
        
        for i, line in enumerate(data_lines):
            current_lines.append(line)
            
            # 检查是否达到分块条件
            if (len(current_lines) >= target_lines_per_chunk or 
                i == len(data_lines) - 1 or
                len('\n'.join(current_lines)) > self.chunk_size):
                
                # 创建分块
                chunk_content = self._create_chunk_content(
                    table_headers, current_lines, chunk_index
                )
                
                # 计算分块的行范围
                start_row = chunk_index * target_lines_per_chunk
                end_row = start_row + len(current_lines)
                
                chunk = {
                    'table_id': f"{table_id}_sub_{chunk_index}",
                    'table_type': content_result.get('table_type', ''),
                    'table_title': f"{content_result.get('table_title', '')} (部分 {chunk_index + 1})",
                    'table_summary': f"{content_result.get('table_summary', '')} (部分 {chunk_index + 1})",
                    'table_rows': len(current_lines),
                    'table_columns': content_result.get('table_columns', 0),
                    'table_headers': table_headers,
                    'table_content': chunk_content,
                    'related_text': content_result.get('related_text', ''),
                    'related_images': content_result.get('related_images', []),
                    'related_text_chunks': content_result.get('related_text_chunks', []),
                    'table_context': content_result.get('table_context', ''),
                    'is_subtable': True,
                    'parent_table_id': table_id,
                    'subtable_index': chunk_index,
                    'chunk_start_row': start_row,
                    'chunk_end_row': end_row
                }
                
                chunks.append(chunk)
                chunk_index += 1
                current_lines = []
        
        return chunks
    
    def _create_chunk_content(self, headers: List, lines: List, chunk_index: int) -> str:
        """创建分块内容"""
        content_parts = []
        
        # 添加表头
        if headers:
            header_text = " | ".join(str(h) for h in headers)
            content_parts.append(header_text)
        
        # 添加数据行
        content_parts.extend(lines)
        
        return "\n".join(content_parts)
    
    def generate_html(self, chunked_result: Dict) -> Dict:
        """
        生成HTML格式的表格内容
        
        :param chunked_result: 分块处理结果
        :return: HTML生成结果
        """
        try:
            if chunked_result.get('needs_chunking', False):
                # 处理分块后的表格
                html_chunks = []
                for chunk in chunked_result['chunks']:
                    html_content = self._generate_single_table_html(chunk)
                    html_chunks.append({
                        'chunk_id': chunk.get('table_id', ''),
                        'html_content': html_content
                    })
                
                return {
                    'table_html': html_chunks[0]['html_content'] if html_chunks else '',  # 主表格HTML
                    'html_chunks': html_chunks,
                    'total_html_chunks': len(html_chunks)
                }
            else:
                # 单个表格
                html_content = self._generate_single_table_html(chunked_result['chunks'][0])
                return {
                    'table_html': html_content,
                    'html_chunks': [],
                    'total_html_chunks': 1
                }
                
        except Exception as e:
            logging.error(f"HTML生成失败: {str(e)}")
            return {
                'table_html': '',
                'html_chunks': [],
                'total_html_chunks': 0,
                'error': str(e)
            }
    
    def _generate_single_table_html(self, chunk: Dict) -> str:
        """生成单个表格的HTML内容"""
        try:
            headers = chunk.get('table_headers', [])
            content_lines = chunk.get('table_content', '').split('\n')
            
            # 构建HTML表格
            html_parts = ['<table class="table table-striped table-bordered">']
            
            # 添加表头
            if headers:
                html_parts.append('<thead><tr>')
                for header in headers:
                    html_parts.append(f'<th>{header}</th>')
                html_parts.append('</tr></thead>')
            
            # 添加表体
            html_parts.append('<tbody>')
            for i, line in enumerate(content_lines):
                if i == 0 and headers:
                    # 跳过表头行（如果内容中包含表头）
                    continue
                
                cells = line.split(' | ')
                html_parts.append('<tr>')
                for cell in cells:
                    html_parts.append(f'<td>{cell.strip()}</td>')
                html_parts.append('</tr>')
            html_parts.append('</tbody>')
            
            html_parts.append('</table>')
            
            return ''.join(html_parts)
            
        except Exception as e:
            logging.error(f"生成单个表格HTML失败: {str(e)}")
            return f'<div class="error">表格HTML生成失败: {str(e)}</div>'
```

### 4. 使用示例

#### 4.1 基本使用

```python
# 初始化表格处理器
config_manager = ConfigManager()
table_processor = TableProcessor(config_manager)

# 处理单个表格
table_data = {
    'table_id': 'financial_table_001',
    'rows': [
        ['营收', '1000', '1200'],
        ['利润', '200', '250'],
        ['成本', '800', '950']
    ],
    'headers': ['指标', '2023', '2024']
}

metadata = {
    'source_type': 'mineru_output',
    'document_name': 'financial_report.pdf',
    'document_path': './document/md/financial_report_1.json',
    'page_number': 1,
    'page_idx': 0
}

result = table_processor.process_table(table_data, metadata=metadata)
print(f"表格ID: {result['table_id']}")
print(f"Chunk ID: {result['chunk_id']}")
print(f"表格类型: {result['chunk_type']}")
print(f"行数: {result['table_rows']}")
print(f"列数: {result['table_columns']}")
print(f"是否已向量化: {result['vectorized']}")
print(f"向量化模型: {result['embedding_model']}")
```

#### 4.2 批量处理

```python
# 批量处理多个表格
tables = [table_data_1, table_data_2, table_data_3]
metadata_list = [meta_1, meta_2, meta_3]

results = table_processor.process_batch(tables, metadata_list)
print(f"成功处理 {len(results)} 个表格")

for result in results:
    if not result.get('error'):
        print(f"表格 {result['table_id']} 处理成功，Chunk ID: {result['chunk_id']}")
    else:
        print(f"表格 {result['table_id']} 处理失败: {result['error_message']}")
```

#### 4.3 分块处理示例

```python
# 大表格会自动分块
large_table_data = {
    'table_id': 'large_data_table',
    'rows': [['数据' + str(i), '值' + str(i)] for i in range(1000)],  # 1000行数据
    'headers': ['字段', '数值']
}

result = table_processor.process_table(large_table_data, metadata=metadata)
if result.get('needs_chunking'):
    print(f"大表格已分块，共 {result['total_chunks']} 个分块")
    for chunk in result['chunks']:
        print(f"分块 {chunk['subtable_index']}: {chunk['chunk_start_row']}-{chunk['chunk_end_row']} 行")
```

### 5. 配置参数

#### 5.1 表格处理配置（使用配置管理文档中的结构）

TableProcessor只使用配置管理文档中定义的配置参数：

```json
{
  "document_processing": {
    "chunk_size": 1000,           // 文本分块大小（用于表格内容）
    "chunk_overlap": 200          // 分块重叠大小
  },
  "paths": {
    "input_pdf_dir": "./document/orig_pdf",
    "mineru_output_dir": "./document/md",
    "vector_db_dir": "./central/vector_db"
  }
}
```

#### 5.2 向量化配置

```json
{
  "vectorization": {
    "text_embedding_model": "text-embedding-v1"  // 文本向量化模型
  }
}
```

### 6. 设计优势

#### 6.1 严格遵循设计文档要求
- **元数据结构**：完全使用设计文档中定义的 `TABLE_METADATA_SCHEMA`
- **通用字段**：包含所有必需的 `COMMON_METADATA_FIELDS`
- **字段命名**：与设计文档保持一致

#### 6.2 基于现有优秀设计
- **参考现有实现**：完整实现现有 `table_processor.py` 的分块策略
- **保持兼容性**：与现有系统的接口和数据结构兼容
- **继承优秀特性**：智能分块、错误处理、进度报告等

#### 6.3 模块化设计
- **职责分离**：分析、提取、格式化、向量化各司其职
- **易于扩展**：可以独立扩展各个子模块
- **便于测试**：每个模块都可以独立测试

#### 6.4 智能分块策略
- **按内容长度分块**：避免单个chunk过大
- **保持表头完整性**：每个分块都包含完整表头
- **智能行数计算**：根据内容长度动态计算分块大小

#### 6.5 统一向量化接口
- **使用ModelCaller**：通过统一的模型调用接口
- **配置驱动**：模型选择完全由配置控制
- **错误处理**：向量化失败不影响其他处理步骤

### 7. 与ModelCaller的集成

#### 7.1 向量化调用

```python
# 通过ModelCaller进行表格向量化
table_embedding = self.model_caller.call_text_embedding(
    table_text,
    metadata={'content_type': 'table', 'source': 'table_processor'}
)
```

#### 7.2 模型信息获取

```python
# 使用ModelCaller的get_model_info方法获取模型信息
model_info = self.model_caller.get_model_info('text_embedding')
embedding_model = model_info.get('model_name', 'unknown')
```

#### 7.3 配置验证

```python
# ModelCaller会自动验证配置完整性
# 如果配置缺失，会在初始化时抛出异常
try:
    model_caller = ModelCaller(config_manager)
except ValueError as e:
    logging.error(f"ModelCaller配置验证失败: {e}")
    # 处理配置错误
```

### 8. 与配置管理的集成

#### 8.1 路径配置

```python
# 使用配置管理文档中定义的路径配置
paths_config = self.config.get('paths', {})
self.input_dir = paths_config.get('input_pdf_dir', './document/orig_pdf')
self.output_dir = paths_config.get('mineru_output_dir', './document/md')
self.vector_db_dir = paths_config.get('vector_db_dir', './central/vector_db')
```

#### 8.2 处理参数配置

```python
# 使用配置管理文档中定义的文档处理配置
doc_processing_config = self.config.get('document_processing', {})
self.chunk_size = doc_processing_config.get('chunk_size', 1000)
self.chunk_overlap = doc_processing_config.get('chunk_overlap', 200)
```

这个重写的TableProcessor设计文档确保了：

1. **元数据结构**：完全按照设计文档的 `TABLE_METADATA_SCHEMA` 和 `COMMON_METADATA_FIELDS` 实现
2. **配置管理**：使用配置管理文档中定义的配置结构，避免过度配置
3. **ModelCaller集成**：正确使用ModelCaller提供的方法，包括配置验证和模型信息获取
4. **分块策略**：完整实现现有 `table_processor.py` 的分块逻辑
5. **路径配置**：使用配置管理文档中定义的路径配置
6. **错误处理**：与配置管理文档中定义的失败处理策略保持一致