

# V3ç‰ˆæœ¬é…ç½®ç®¡ç†ç³»ç»Ÿè¯¦ç»†è®¾è®¡æ–‡æ¡£ï¼ˆå®Œæ•´ç‰ˆï¼‰

## æ–‡æ¡£æ¦‚è¿°

### æ–‡æ¡£ç›®çš„
è®¾è®¡V3ç‰ˆæœ¬å‘é‡æ•°æ®åº“æ„å»ºç³»ç»Ÿçš„é…ç½®ç®¡ç†ç³»ç»Ÿï¼Œå®ç°é…ç½®çš„é›†ä¸­åŒ–ã€æ ‡å‡†åŒ–å’Œæ˜“ç®¡ç†æ€§ï¼ŒåŒ…å«æ‰€æœ‰å¿…è¦çš„æ–‡ä»¶è·¯å¾„ã€æ¨¡å‹é€‰æ‹©ã€APIé…ç½®å’Œå¤±è´¥å¤„ç†ç­–ç•¥ã€‚

### è®¾è®¡åŸåˆ™
- **é…ç½®é›†ä¸­åŒ–**ï¼šæ‰€æœ‰é…ç½®é›†ä¸­åœ¨ä¸€ä¸ªåœ°æ–¹ç®¡ç†
- **ç¯å¢ƒå˜é‡ä¼˜å…ˆ**ï¼šæ•æ„Ÿä¿¡æ¯é€šè¿‡ç¯å¢ƒå˜é‡ç®¡ç†
- **Windowså…¼å®¹**ï¼šæ”¯æŒWindowsç³»ç»Ÿçš„ç¯å¢ƒå˜é‡è®¾ç½®
- **å‚æ•°éªŒè¯**ï¼šé…ç½®åŠ è½½æ—¶è¿›è¡Œå®Œæ•´æ€§éªŒè¯
- **é»˜è®¤å€¼ç®¡ç†**ï¼šæä¾›åˆç†çš„é»˜è®¤é…ç½®
- **å¤±è´¥å¤„ç†**ï¼šæ”¯æŒå¤±è´¥è·³è¿‡å’Œåç»­è¡¥åšæœºåˆ¶

##ï¸ ç³»ç»Ÿæ¶æ„è®¾è®¡

### æ•´ä½“æ¶æ„
```
ç”¨æˆ·é…ç½® â†’ é…ç½®ç®¡ç†å™¨ â†’ é…ç½®éªŒè¯å™¨ â†’ é…ç½®åŠ è½½å™¨ â†’ ç¯å¢ƒå˜é‡å¤„ç† â†’ è·¯å¾„éªŒè¯ â†’ é…ç½®åˆ†å‘å™¨ â†’ å„æ¨¡å—ä½¿ç”¨
```

### æ ¸å¿ƒç»„ä»¶
1. **ConfigManager**ï¼šé…ç½®ç®¡ç†å™¨ä¸»ç±»
2. **ConfigValidator**ï¼šé…ç½®éªŒè¯å™¨
3. **ConfigLoader**ï¼šé…ç½®åŠ è½½å™¨
4. **EnvironmentManager**ï¼šç¯å¢ƒå˜é‡ç®¡ç†å™¨ï¼ˆWindowså…¼å®¹ï¼‰
5. **PathManager**ï¼šè·¯å¾„ç®¡ç†å™¨
6. **FailureHandler**ï¼šå¤±è´¥å¤„ç†ç®¡ç†å™¨

## ğŸ“ ç›®å½•ç»“æ„è®¾è®¡

```
v3/
â”œâ”€â”€ config/
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ config_manager.py          # é…ç½®ç®¡ç†å™¨ä¸»ç±»
â”‚   â”œâ”€â”€ config_validator.py        # é…ç½®éªŒè¯å™¨
â”‚   â”œâ”€â”€ config_loader.py           # é…ç½®åŠ è½½å™¨
â”‚   â”œâ”€â”€ environment_manager.py     # ç¯å¢ƒå˜é‡ç®¡ç†å™¨ï¼ˆWindowså…¼å®¹ï¼‰
â”‚   â”œâ”€â”€ path_manager.py            # è·¯å¾„ç®¡ç†å™¨
â”‚   â”œâ”€â”€ failure_handler.py         # å¤±è´¥å¤„ç†ç®¡ç†å™¨
â”‚   â”œâ”€â”€ v3_config.json            # V3é…ç½®æ–‡ä»¶
â”‚   â””â”€â”€ v3_config_schema.json     # é…ç½®æ¨¡å¼æ–‡ä»¶
```

## âš™ï¸ é…ç½®ç»“æ„è®¾è®¡

### 1. ä¸»é…ç½®æ–‡ä»¶ç»“æ„ (v3_config.json)

```json
{
  "version": "3.0.0",
  "system": {
    "mode": "auto",
    "log_level": "INFO"
  },
  "paths": {
    "input_pdf_dir": "./document/orig_pdf",
    "mineru_output_dir": "./document/md",
    "final_image_dir": "./central/images",
    "vector_db_dir": "./central/vector_db",
    "temp_dir": "./temp",
    "logs_dir": "./logs"
  },
  "document_processing": {
    "chunk_size": 1000,
    "chunk_overlap": 200
  },
  "vectorization": {
    "text_embedding_model": "text-embedding-v1",
    "image_embedding_model": "multimodal-embedding-one-peace-v1"
  },
  "image_processing": {
    "enable_enhancement": true,
    "enhancement_model": "qwen-vl-plus",
    "enhancement_model_api": "dashscope"
  },
  "mineru": {
    "api_endpoint": "https://api.mineru.com",
    "batch_size": 10,
    "timeout": 300,
    "retry_count": 3,
    "poll_interval": 10
  },
  "api_rate_limiting": {
    "enhancement_batch_size": 5,
    "enhancement_delay_seconds": 2,
    "vectorization_batch_size": 10,
    "vectorization_delay_seconds": 1,
    "max_retries": 3,
    "retry_delay_seconds": 5,
    "enable_rate_limiting": true
  },
  "batch_processing": {
    "enhancement_workers": 2,
    "vectorization_workers": 3,
    "queue_size": 100,
    "timeout_seconds": 300,
    "progress_report_interval": 10
  },
  "failure_handling": {
    "skip_failed_images": true,
    "max_retries": 3,
    "retry_delay_seconds": 5,
    "continue_on_failure": true,
    "generate_failure_report": true,
    "failure_report_path": "./logs/failure_report.json",
    "mark_for_later_processing": true,
    "failure_report_format": "detailed"
  },
  "storage": {
    "backup_enabled": true,
    "backup_interval": 24
  }
}
```

### 2. é…ç½®æ¨¡å¼æ–‡ä»¶ (v3_config_schema.json)

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "type": "object",
  "required": ["version", "system", "paths", "document_processing", "vectorization"],
  "properties": {
    "version": {
      "type": "string",
      "pattern": "^\\d+\\.\\d+\\.\\d+$"
    },
    "system": {
      "type": "object",
      "required": ["mode"],
      "properties": {
        "mode": {
          "type": "string",
          "enum": ["auto", "new", "incremental"]
        },
        "log_level": {
          "type": "string",
          "enum": ["DEBUG", "INFO", "WARNING", "ERROR"]
        }
      }
    },
    "paths": {
      "type": "object",
      "required": ["input_pdf_dir", "mineru_output_dir", "final_image_dir", "vector_db_dir"],
      "properties": {
        "input_pdf_dir": {"type": "string"},
        "mineru_output_dir": {"type": "string"},
        "final_image_dir": {"type": "string"},
        "vector_db_dir": {"type": "string"},
        "temp_dir": {"type": "string"},
        "logs_dir": {"type": "string"}
      }
    },
    "document_processing": {
      "type": "object",
      "required": ["chunk_size", "chunk_overlap"],
      "properties": {
        "chunk_size": {
          "type": "integer",
          "minimum": 100,
          "maximum": 5000
        },
        "chunk_overlap": {
          "type": "integer",
          "minimum": 0,
          "maximum": 1000
        }
      }
    },
    "vectorization": {
      "type": "object",
      "required": ["text_embedding_model", "image_embedding_model"],
      "properties": {
        "text_embedding_model": {"type": "string"},
        "image_embedding_model": {"type": "string"}
      }
    },
    "image_processing": {
      "type": "object",
      "required": ["enable_enhancement"],
      "properties": {
        "enable_enhancement": {"type": "boolean"},
        "enhancement_model": {"type": "string"},
        "enhancement_model_api": {"type": "string"}
      }
    },
    "mineru": {
      "type": "object",
      "required": ["api_endpoint"],
      "properties": {
        "api_endpoint": {"type": "string"},
        "batch_size": {
          "type": "integer",
          "minimum": 1,
          "maximum": 50
        },
        "timeout": {
          "type": "integer",
          "minimum": 60,
          "maximum": 1800
        },
        "retry_count": {
          "type": "integer",
          "minimum": 1,
          "maximum": 10
        },
        "poll_interval": {
          "type": "integer",
          "minimum": 5,
          "maximum": 60
        }
      }
    },
    "api_rate_limiting": {
      "type": "object",
      "required": ["enhancement_batch_size", "enhancement_delay_seconds", "vectorization_batch_size", "vectorization_delay_seconds"],
      "properties": {
        "enhancement_batch_size": {
          "type": "integer",
          "minimum": 1,
          "maximum": 20
        },
        "enhancement_delay_seconds": {
          "type": "integer",
          "minimum": 1,
          "maximum": 60
        },
        "vectorization_batch_size": {
          "type": "integer",
          "minimum": 1,
          "maximum": 50
        },
        "vectorization_delay_seconds": {
          "type": "integer",
          "minimum": 0,
          "maximum": 30
        },
        "max_retries": {
          "type": "integer",
          "minimum": 1,
          "maximum": 10
        },
        "retry_delay_seconds": {
          "type": "integer",
          "minimum": 1,
          "maximum": 60
        },
        "enable_rate_limiting": {"type": "boolean"}
      }
    },
    "batch_processing": {
      "type": "object",
      "properties": {
        "enhancement_workers": {
          "type": "integer",
          "minimum": 1,
          "maximum": 8
        },
        "vectorization_workers": {
          "type": "integer",
          "minimum": 1,
          "maximum": 10
        },
        "queue_size": {
          "type": "integer",
          "minimum": 10,
          "maximum": 1000
        },
        "timeout_seconds": {
          "type": "integer",
          "minimum": 60,
          "maximum": 1800
        },
        "progress_report_interval": {
          "type": "integer",
          "minimum": 5,
          "maximum": 60
        }
      }
    },
    "failure_handling": {
      "type": "object",
      "required": ["skip_failed_images", "generate_failure_report"],
      "properties": {
        "skip_failed_images": {"type": "boolean"},
        "max_retries": {
          "type": "integer",
          "minimum": 1,
          "maximum": 10
        },
        "retry_delay_seconds": {
          "type": "integer",
          "minimum": 1,
          "maximum": 60
        },
        "continue_on_failure": {"type": "boolean"},
        "generate_failure_report": {"type": "boolean"},
        "failure_report_path": {"type": "string"},
        "mark_for_later_processing": {"type": "boolean"},
        "failure_report_format": {
          "type": "string",
          "enum": ["simple", "detailed"]
        }
      }
    },
    "storage": {
      "type": "object",
      "properties": {
        "backup_enabled": {"type": "boolean"},
        "backup_interval": {
          "type": "integer",
          "minimum": 1,
          "maximum": 168
        }
      }
    }
  }
}
```

## ğŸ”§ æ ¸å¿ƒç±»è®¾è®¡

### 1. ConfigManager ä¸»ç±»

```python
class ConfigManager:
    """
    é…ç½®ç®¡ç†å™¨ä¸»ç±»
    
    åŠŸèƒ½ï¼š
    - ç»Ÿä¸€ç®¡ç†æ‰€æœ‰é…ç½®
    - æä¾›é…ç½®è®¿é—®æ¥å£
    - ç®¡ç†é…ç½®çš„åŠ è½½å’ŒéªŒè¯
    - æ”¯æŒé…ç½®çƒ­æ›´æ–°
    - é›†æˆå¤±è´¥å¤„ç†ç®¡ç†
    """
    
    def __init__(self, config_path: str = None):
        """
        åˆå§‹åŒ–é…ç½®ç®¡ç†å™¨
        
        :param config_path: é…ç½®æ–‡ä»¶è·¯å¾„ï¼Œå¦‚æœä¸ºNoneåˆ™ä½¿ç”¨é»˜è®¤è·¯å¾„
        """
        self.config_path = config_path or "v3/config/v3_config.json"
        self.config_data = {}
        self.config_schema = {}
        self.environment_manager = EnvironmentManager()
        self.validator = ConfigValidator()
        self.loader = ConfigLoader()
        self.path_manager = PathManager()
        self.failure_handler = FailureHandler()
        
    def load_config(self) -> bool:
        """
        åŠ è½½é…ç½®æ–‡ä»¶
        
        :return: æ˜¯å¦åŠ è½½æˆåŠŸ
        """
        try:
            # åŠ è½½é…ç½®æ–‡ä»¶
            self.config_data = self.loader.load_json(self.config_path)
            
            # åŠ è½½é…ç½®æ¨¡å¼
            schema_path = self._get_schema_path()
            self.config_schema = self.loader.load_json(schema_path)
            
            # éªŒè¯é…ç½®
            if not self.validator.validate(self.config_data, self.config_schema):
                raise ValueError("é…ç½®éªŒè¯å¤±è´¥")
            
            # å¤„ç†ç¯å¢ƒå˜é‡
            self._process_environment_variables()
            
            # éªŒè¯è·¯å¾„
            if not self.path_manager.validate_paths(self.config_data.get('paths', {})):
                raise ValueError("è·¯å¾„é…ç½®éªŒè¯å¤±è´¥")
            
            # åˆå§‹åŒ–å¤±è´¥å¤„ç†å™¨
            self.failure_handler.initialize(self.config_data.get('failure_handling', {}))
            
            return True
            
        except Exception as e:
            logger.error(f"é…ç½®åŠ è½½å¤±è´¥: {e}")
            return False
    
    def get(self, key: str, default=None):
        """
        è·å–é…ç½®å€¼
        
        :param key: é…ç½®é”®ï¼Œæ”¯æŒç‚¹å·åˆ†éš”çš„åµŒå¥—é”®
        :param default: é»˜è®¤å€¼
        :return: é…ç½®å€¼
        """
        keys = key.split('.')
        value = self.config_data
        
        try:
            for k in keys:
                value = value[k]
            return value
        except (KeyError, TypeError):
            return default
    
    def get_path(self, path_key: str) -> str:
        """
        è·å–è·¯å¾„é…ç½®ï¼Œæ”¯æŒç›¸å¯¹è·¯å¾„è½¬æ¢ä¸ºç»å¯¹è·¯å¾„
        
        :param path_key: è·¯å¾„é”®
        :return: ç»å¯¹è·¯å¾„
        """
        relative_path = self.get(f"paths.{path_key}")
        if relative_path:
            return self.path_manager.get_absolute_path(relative_path)
        return None
    
    def get_failure_handler(self) -> 'FailureHandler':
        """
        è·å–å¤±è´¥å¤„ç†å™¨å®ä¾‹
        
        :return: å¤±è´¥å¤„ç†å™¨å®ä¾‹
        """
        return self.failure_handler
    
    def set(self, key: str, value):
        """
        è®¾ç½®é…ç½®å€¼
        
        :param key: é…ç½®é”®
        :param value: é…ç½®å€¼
        """
        keys = key.split('.')
        config = self.config_data
        
        for k in keys[:-1]:
            if k not in config:
                config[k] = {}
            config = config[k]
        
        config[keys[-1]] = value
    
    def save_config(self) -> bool:
        """
        ä¿å­˜é…ç½®åˆ°æ–‡ä»¶
        
        :return: æ˜¯å¦ä¿å­˜æˆåŠŸ
        """
        try:
            self.loader.save_json(self.config_path, self.config_data)
            return True
        except Exception as e:
            logger.error(f"é…ç½®ä¿å­˜å¤±è´¥: {e}")
            return False
    
    def _process_environment_variables(self):
        """
        å¤„ç†ç¯å¢ƒå˜é‡è¦†ç›–
        """
        # å¤„ç†APIå¯†é’¥
        if self.environment_manager.get_dashscope_api_key():
            # ä¸å­˜å‚¨åœ¨é…ç½®ä¸­ï¼Œåªåœ¨éœ€è¦æ—¶è¯»å–
            pass
        
        if self.environment_manager.get_mineru_api_key():
            # ä¸å­˜å‚¨åœ¨é…ç½®ä¸­ï¼Œåªåœ¨éœ€è¦æ—¶è¯»å–
            pass
```

### 2. FailureHandler å¤±è´¥å¤„ç†ç®¡ç†å™¨

```python
class FailureHandler:
    """
    å¤±è´¥å¤„ç†ç®¡ç†å™¨
    
    åŠŸèƒ½ï¼š
    - ç®¡ç†å›¾ç‰‡å¤„ç†å¤±è´¥çš„æƒ…å†µ
    - ç”Ÿæˆè¯¦ç»†çš„å¤±è´¥æŠ¥å‘Š
    - æ”¯æŒåç»­è¡¥åšæœºåˆ¶
    - ä¸V502_image_enhancer_new.pyé…åˆ
    """
    
    def __init__(self):
        self.config = {}
        self.failure_report_path = ""
        self.failed_images = []
        self.failure_report_format = "detailed"
        
    def initialize(self, failure_config: dict):
        """
        åˆå§‹åŒ–å¤±è´¥å¤„ç†å™¨
        
        :param failure_config: å¤±è´¥å¤„ç†é…ç½®
        """
        self.config = failure_config
        self.failure_report_path = failure_config.get('failure_report_path', './logs/failure_report.json')
        self.failure_report_format = failure_config.get('failure_report_format', 'detailed')
        
        # ç¡®ä¿æ—¥å¿—ç›®å½•å­˜åœ¨
        logs_dir = os.path.dirname(self.failure_report_path)
        os.makedirs(logs_dir, exist_ok=True)
        
        # åŠ è½½ç°æœ‰çš„å¤±è´¥æŠ¥å‘Š
        self._load_existing_failures()
    
    def record_failure(self, image_info: dict, error_type: str, error_message: str, retry_count: int = 0):
        """
        è®°å½•å›¾ç‰‡å¤„ç†å¤±è´¥
        
        :param image_info: å›¾ç‰‡ä¿¡æ¯
        :param error_type: é”™è¯¯ç±»å‹
        :param error_message: é”™è¯¯ä¿¡æ¯
        :param retry_count: é‡è¯•æ¬¡æ•°
        """
        failure_record = {
            'image_path': image_info.get('image_path', ''),
            'image_id': image_info.get('image_id', ''),
            'document_name': image_info.get('document_name', ''),
            'page_number': image_info.get('page_number', 1),
            'failure_type': error_type,
            'error_message': error_message,
            'retry_count': retry_count,
            'timestamp': int(time.time()),
            'can_retry_later': True,
            'status': 'failed'
        }
        
        self.failed_images.append(failure_record)
        
        # å®æ—¶ä¿å­˜å¤±è´¥æŠ¥å‘Š
        self._save_failure_report()
        
        logger.warning(f"å›¾ç‰‡å¤„ç†å¤±è´¥: {image_info.get('image_id', 'unknown')} - {error_message}")
    
    def get_failed_images(self, failure_type: str = None) -> list:
        """
        è·å–å¤±è´¥çš„å›¾ç‰‡åˆ—è¡¨
        
        :param failure_type: é”™è¯¯ç±»å‹è¿‡æ»¤ï¼Œå¦‚æœä¸ºNoneåˆ™è¿”å›æ‰€æœ‰
        :return: å¤±è´¥å›¾ç‰‡åˆ—è¡¨
        """
        if failure_type:
            return [img for img in self.failed_images if img['failure_type'] == failure_type]
        return self.failed_images.copy()
    
    def mark_as_retried(self, image_id: str, success: bool = True):
        """
        æ ‡è®°å›¾ç‰‡ä¸ºé‡è¯•çŠ¶æ€
        
        :param image_id: å›¾ç‰‡ID
        :param success: æ˜¯å¦é‡è¯•æˆåŠŸ
        """
        for img in self.failed_images:
            if img['image_id'] == image_id:
                if success:
                    img['status'] = 'retry_success'
                    img['retry_timestamp'] = int(time.time())
                else:
                    img['status'] = 'retry_failed'
                    img['retry_count'] += 1
                break
        
        self._save_failure_report()
    
    def generate_failure_report(self) -> dict:
        """
        ç”Ÿæˆå¤±è´¥æŠ¥å‘Š
        
        :return: å¤±è´¥æŠ¥å‘Šå­—å…¸
        """
        total_failures = len(self.failed_images)
        retry_success = len([img for img in self.failed_images if img['status'] == 'retry_success'])
        still_failed = len([img for img in self.failed_images if img['status'] == 'failed'])
        retry_failed = len([img for img in self.failed_images if img['status'] == 'retry_failed'])
        
        report = {
            'timestamp': int(time.time()),
            'summary': {
                'total_failures': total_failures,
                'retry_success': retry_success,
                'still_failed': still_failed,
                'retry_failed': retry_failed
            },
            'failed_images': self.failed_images
        }
        
        if self.failure_report_format == 'detailed':
            # æŒ‰é”™è¯¯ç±»å‹åˆ†ç»„
            error_groups = {}
            for img in self.failed_images:
                error_type = img['failure_type']
                if error_type not in error_groups:
                    error_groups[error_type] = []
                error_groups[error_type].append(img)
            
            report['error_analysis'] = error_groups
        
        return report
    
    def _load_existing_failures(self):
        """
        åŠ è½½ç°æœ‰çš„å¤±è´¥æŠ¥å‘Š
        """
        try:
            if os.path.exists(self.failure_report_path):
                with open(self.failure_report_path, 'r', encoding='utf-8') as f:
                    existing_data = json.load(f)
                    self.failed_images = existing_data.get('failed_images', [])
                    logger.info(f"åŠ è½½ç°æœ‰å¤±è´¥æŠ¥å‘Šï¼ŒåŒ…å« {len(self.failed_images)} æ¡å¤±è´¥è®°å½•")
        except Exception as e:
            logger.warning(f"åŠ è½½ç°æœ‰å¤±è´¥æŠ¥å‘Šå¤±è´¥: {e}")
            self.failed_images = []
    
    def _save_failure_report(self):
        """
        ä¿å­˜å¤±è´¥æŠ¥å‘Šåˆ°æ–‡ä»¶
        """
        try:
            report = self.generate_failure_report()
            with open(self.failure_report_path, 'w', encoding='utf-8') as f:
                json.dump(report, f, indent=2, ensure_ascii=False)
        except Exception as e:
            logger.error(f"ä¿å­˜å¤±è´¥æŠ¥å‘Šå¤±è´¥: {e}")
    
    def clear_resolved_failures(self):
        """
        æ¸…ç†å·²è§£å†³çš„å¤±è´¥è®°å½•
        """
        self.failed_images = [img for img in self.failed_images if img['status'] == 'failed']
        self._save_failure_report()
        logger.info("å·²æ¸…ç†å·²è§£å†³çš„å¤±è´¥è®°å½•")
```

### 3. EnvironmentManager ç¯å¢ƒå˜é‡ç®¡ç†å™¨ï¼ˆWindowså…¼å®¹ï¼‰

```python
class EnvironmentManager:
    """
    ç¯å¢ƒå˜é‡ç®¡ç†å™¨ï¼ˆWindowså…¼å®¹ï¼‰
    
    åŠŸèƒ½ï¼š
    - ç®¡ç†æ‰€æœ‰ç¯å¢ƒå˜é‡
    - æä¾›ç¯å¢ƒå˜é‡è¯»å–æ¥å£
    - æ”¯æŒWindowså’ŒLinuxç³»ç»Ÿ
    - æ”¯æŒç¯å¢ƒå˜é‡éªŒè¯
    """
    
    def __init__(self):
        self.required_vars = [
            'DASHSCOPE_API_KEY',
            'MINERU_API_KEY'
        ]
        self.optional_vars = [
            'LOG_LEVEL',
            'VECTOR_DB_PATH'
        ]
    
    def get_dashscope_api_key(self) -> str:
        """
        è·å–é€šä¹‰åƒé—®APIå¯†é’¥
        
        :return: APIå¯†é’¥
        """
        return os.getenv('DASHSCOPE_API_KEY')
    
    def get_mineru_api_key(self) -> str:
        """
        è·å–MinerU APIå¯†é’¥
        
        :return: MinerU APIå¯†é’¥
        """
        return os.getenv('MINERU_API_KEY')
    
    def validate_environment(self) -> bool:
        """
        éªŒè¯ç¯å¢ƒå˜é‡
        
        :return: æ˜¯å¦éªŒè¯é€šè¿‡
        """
        missing_vars = []
        
        for var in self.required_vars:
            if not os.getenv(var):
                missing_vars.append(var)
        
        if missing_vars:
            logger.error(f"ç¼ºå°‘å¿…éœ€çš„ç¯å¢ƒå˜é‡: {missing_vars}")
            logger.error("è¯·è®¾ç½®ä»¥ä¸‹ç¯å¢ƒå˜é‡:")
            for var in missing_vars:
                if var == 'DASHSCOPE_API_KEY':
                    logger.error(f"  {var}: é€šä¹‰åƒé—®APIå¯†é’¥")
                elif var == 'MINERU_API_KEY':
                    logger.error(f"  {var}: MinerU APIå¯†é’¥")
            return False
        
        return True
    
    def get_environment_info(self) -> dict:
        """
        è·å–ç¯å¢ƒå˜é‡ä¿¡æ¯ï¼ˆç”¨äºè°ƒè¯•ï¼‰
        
        :return: ç¯å¢ƒå˜é‡ä¿¡æ¯å­—å…¸
        """
        info = {
            'system': platform.system(),
            'required_vars': {},
            'optional_vars': {}
        }
        
        for var in self.required_vars:
            value = os.getenv(var)
            info['required_vars'][var] = 'å·²è®¾ç½®' if value else 'æœªè®¾ç½®'
        
        for var in self.optional_vars:
            value = os.getenv(var)
            info['optional_vars'][var] = value if value else 'æœªè®¾ç½®'
        
        return info
    
    def print_environment_setup_guide(self):
        """
        æ‰“å°ç¯å¢ƒå˜é‡è®¾ç½®æŒ‡å—
        """
        system = platform.system()
        
        if system == "Windows":
            print("\n=== Windowsç¯å¢ƒå˜é‡è®¾ç½®æŒ‡å— ===")
            print("æ–¹æ³•1: ä½¿ç”¨PowerShellè®¾ç½®ï¼ˆä¸´æ—¶ï¼‰")
            print("$env:DASHSCOPE_API_KEY='your_api_key_here'")
            print("$env:MINERU_API_KEY='your_mineru_key_here'")
            print("\næ–¹æ³•2: ä½¿ç”¨å‘½ä»¤æç¤ºç¬¦è®¾ç½®ï¼ˆä¸´æ—¶ï¼‰")
            print("set DASHSCOPE_API_KEY=your_api_key_here")
            print("set MINERU_API_KEY=your_mineru_key_here")
            print("\næ–¹æ³•3: ç³»ç»Ÿç¯å¢ƒå˜é‡è®¾ç½®ï¼ˆæ°¸ä¹…ï¼‰")
            print("1. å³é”®'æ­¤ç”µè„‘' â†’ å±æ€§ â†’ é«˜çº§ç³»ç»Ÿè®¾ç½®")
            print("2. ç¯å¢ƒå˜é‡ â†’ æ–°å»º")
            print("3. å˜é‡å: DASHSCOPE_API_KEY, å˜é‡å€¼: your_api_key_here")
            print("4. å˜é‡å: MINERU_API_KEY, å˜é‡å€¼: your_mineru_key_here")
            
        elif system == "Linux" or system == "Darwin":
            print("\n=== Linux/macOSç¯å¢ƒå˜é‡è®¾ç½®æŒ‡å— ===")
            print("æ–¹æ³•1: ä¸´æ—¶è®¾ç½®")
            print("export DASHSCOPE_API_KEY='your_api_key_here'")
            print("export MINERU_API_KEY='your_mineru_key_here'")
            print("\næ–¹æ³•2: æ°¸ä¹…è®¾ç½®ï¼ˆæ·»åŠ åˆ° ~/.bashrc æˆ– ~/.zshrcï¼‰")
            print("echo 'export DASHSCOPE_API_KEY=your_api_key_here' >> ~/.bashrc")
            print("echo 'export MINERU_API_KEY=your_mineru_key_here' >> ~/.bashrc")
            print("source ~/.bashrc")
```

### 4. PathManager è·¯å¾„ç®¡ç†å™¨

```python
class PathManager:
    """
    è·¯å¾„ç®¡ç†å™¨
    
    åŠŸèƒ½ï¼š
    - ç®¡ç†æ‰€æœ‰æ–‡ä»¶è·¯å¾„
    - éªŒè¯è·¯å¾„çš„æœ‰æ•ˆæ€§
    - åˆ›å»ºå¿…è¦çš„ç›®å½•
    - å¤„ç†ç›¸å¯¹è·¯å¾„å’Œç»å¯¹è·¯å¾„
    """
    
    def __init__(self):
        self.base_dir = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
    
    def validate_paths(self, paths_config: dict) -> bool:
        """
        éªŒè¯è·¯å¾„é…ç½®
        
        :param paths_config: è·¯å¾„é…ç½®å­—å…¸
        :return: æ˜¯å¦éªŒè¯é€šè¿‡
        """
        required_paths = [
            'input_pdf_dir',
            'mineru_output_dir', 
            'final_image_dir',
            'vector_db_dir'
        ]
        
        for path_key in required_paths:
            if path_key not in paths_config:
                logger.error(f"ç¼ºå°‘å¿…éœ€çš„è·¯å¾„é…ç½®: {path_key}")
                return False
            
            path = paths_config[path_key]
            if not self._validate_single_path(path, path_key):
                return False
        
        return True
    
    def _validate_single_path(self, path: str, path_key: str) -> bool:
        """
        éªŒè¯å•ä¸ªè·¯å¾„
        
        :param path: è·¯å¾„å­—ç¬¦ä¸²
        :param path_key: è·¯å¾„é”®å
        :return: æ˜¯å¦æœ‰æ•ˆ
        """
        try:
            # è½¬æ¢ä¸ºç»å¯¹è·¯å¾„
            abs_path = self.get_absolute_path(path)
            
            # æ£€æŸ¥è·¯å¾„æ˜¯å¦ä¸ºç©º
            if not path.strip():
                logger.error(f"è·¯å¾„é…ç½®ä¸ºç©º: {path_key}")
                return False
            
            # å¯¹äºè¾“å…¥ç›®å½•ï¼Œæ£€æŸ¥æ˜¯å¦å­˜åœ¨
            if path_key == 'input_pdf_dir':
                if not os.path.exists(abs_path):
                    logger.warning(f"è¾“å…¥PDFç›®å½•ä¸å­˜åœ¨ï¼Œå°†åˆ›å»º: {abs_path}")
                    os.makedirs(abs_path, exist_ok=True)
            
            # å¯¹äºè¾“å‡ºç›®å½•ï¼Œå°è¯•åˆ›å»º
            elif path_key in ['mineru_output_dir', 'final_image_dir', 'vector_db_dir', 'temp_dir', 'logs_dir']:
                os.makedirs(abs_path, exist_ok=True)
                logger.info(f"ç¡®ä¿ç›®å½•å­˜åœ¨: {abs_path}")
            
            return True
            
        except Exception as e:
            logger.error(f"è·¯å¾„éªŒè¯å¤±è´¥ {path_key}: {path}, é”™è¯¯: {e}")
            return False
    
    def get_absolute_path(self, relative_path: str) -> str:
        """
        å°†ç›¸å¯¹è·¯å¾„è½¬æ¢ä¸ºç»å¯¹è·¯å¾„
        
        :param relative_path: ç›¸å¯¹è·¯å¾„
        :return: ç»å¯¹è·¯å¾„
        """
        if os.path.isabs(relative_path):
            return relative_path
        else:
            return os.path.join(self.base_dir, relative_path)
    
    def create_temp_dir(self) -> str:
        """
        åˆ›å»ºä¸´æ—¶ç›®å½•
        
        :return: ä¸´æ—¶ç›®å½•è·¯å¾„
        """
        temp_dir = os.path.join(self.base_dir, "temp", f"temp_{int(time.time())}")
        os.makedirs(temp_dir, exist_ok=True)
        return temp_dir
    
    def cleanup_temp_dirs(self, max_age_hours: int = 24):
        """
        æ¸…ç†è¿‡æœŸçš„ä¸´æ—¶ç›®å½•
        
        :param max_age_hours: æœ€å¤§ä¿ç•™æ—¶é—´ï¼ˆå°æ—¶ï¼‰
        """
        temp_base = os.path.join(self.base_dir, "temp")
        if not os.path.exists(temp_base):
            return
        
        current_time = time.time()
        max_age_seconds = max_age_hours * 3600
        
        for item in os.listdir(temp_base):
            item_path = os.path.join(temp_base, item)
            if os.path.isdir(item_path) and item.startswith("temp_"):
                try:
                    item_age = current_time - os.path.getctime(item_path)
                    if item_age > max_age_seconds:
                        shutil.rmtree(item_path)
                        logger.info(f"æ¸…ç†è¿‡æœŸä¸´æ—¶ç›®å½•: {item_path}")
                except Exception as e:
                    logger.warning(f"æ¸…ç†ä¸´æ—¶ç›®å½•å¤±è´¥: {item_path}, é”™è¯¯: {e}")
```

### 5. ConfigValidator é…ç½®éªŒè¯å™¨

```python
class ConfigValidator:
    """
    é…ç½®éªŒè¯å™¨
    
    åŠŸèƒ½ï¼š
    - éªŒè¯é…ç½®çš„å®Œæ•´æ€§å’Œæ­£ç¡®æ€§
    - æä¾›è¯¦ç»†çš„éªŒè¯é”™è¯¯ä¿¡æ¯
    - æ”¯æŒè‡ªå®šä¹‰éªŒè¯è§„åˆ™
    """
    
    def __init__(self):
        self.validation_errors = []
    
    def validate(self, config: dict, schema: dict) -> bool:
        """
        éªŒè¯é…ç½®
        
        :param config: é…ç½®æ•°æ®
        :param schema: é…ç½®æ¨¡å¼
        :return: æ˜¯å¦éªŒè¯é€šè¿‡
        """
        self.validation_errors = []
        
        try:
            # ä½¿ç”¨JSON SchemaéªŒè¯
            jsonschema.validate(config, schema)
            
            # è‡ªå®šä¹‰éªŒè¯è§„åˆ™
            self._validate_custom_rules(config)
            
            return len(self.validation_errors) == 0
            
        except jsonschema.ValidationError as e:
            self.validation_errors.append(f"JSON SchemaéªŒè¯å¤±è´¥: {e}")
            return False
    
    def _validate_custom_rules(self, config: dict):
        """
        è‡ªå®šä¹‰éªŒè¯è§„åˆ™
        
        :param config: é…ç½®æ•°æ®
        """
        # éªŒè¯chunk_overlapä¸èƒ½å¤§äºchunk_size
        chunk_size = config.get('document_processing', {}).get('chunk_size', 0)
        chunk_overlap = config.get('document_processing', {}).get('chunk_overlap', 0)
        
        if chunk_overlap >= chunk_size:
            self.validation_errors.append(
                f"chunk_overlap ({chunk_overlap}) ä¸èƒ½å¤§äºæˆ–ç­‰äº chunk_size ({chunk_size})"
            )
        
        # éªŒè¯è·¯å¾„é…ç½®
        paths = config.get('paths', {})
        if paths:
            # æ£€æŸ¥è·¯å¾„æ˜¯å¦åŒ…å«éæ³•å­—ç¬¦
            for key, path in paths.items():
                if path and ('<' in path or '>' in path or '|' in path):
                    self.validation_errors.append(
                        f"è·¯å¾„é…ç½®åŒ…å«éæ³•å­—ç¬¦: {key} = {path}"
                    )
        
        # éªŒè¯APIé™æµé…ç½®
        api_config = config.get('api_rate_limiting', {})
        if api_config:
            enhancement_batch = api_config.get('enhancement_batch_size', 0)
            vectorization_batch = api_config.get('vectorization_batch_size', 0)
            
            if enhancement_batch <= 0 or vectorization_batch <= 0:
                self.validation_errors.append(
                    "APIæ‰¹é‡å¤§å°å¿…é¡»å¤§äº0"
                )
    
    def get_validation_errors(self) -> list:
        """
        è·å–éªŒè¯é”™è¯¯ä¿¡æ¯
        
        :return: éªŒè¯é”™è¯¯åˆ—è¡¨
        """
        return self.validation_errors
```

### 6. ConfigLoader é…ç½®åŠ è½½å™¨

```python
class ConfigLoader:
    """
    é…ç½®åŠ è½½å™¨
    
    åŠŸèƒ½ï¼š
    - åŠ è½½é…ç½®æ–‡ä»¶
    - æ”¯æŒå¤šç§æ–‡ä»¶æ ¼å¼
    - æä¾›é…ç½®å¤‡ä»½å’Œæ¢å¤åŠŸèƒ½
    """
    
    def __init__(self):
        self.supported_formats = ['.json', '.yaml', '.yml']
    
    def load_json(self, file_path: str) -> dict:
        """
        åŠ è½½JSONé…ç½®æ–‡ä»¶
        
        :param file_path: æ–‡ä»¶è·¯å¾„
        :return: é…ç½®æ•°æ®
        """
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                return json.load(f)
        except Exception as e:
            raise ConfigLoadError(f"åŠ è½½é…ç½®æ–‡ä»¶å¤±è´¥: {e}")
    
    def save_json(self, file_path: str, data: dict):
        """
        ä¿å­˜é…ç½®åˆ°JSONæ–‡ä»¶
        
        :param file_path: æ–‡ä»¶è·¯å¾„
        :param data: é…ç½®æ•°æ®
        """
        try:
            # åˆ›å»ºå¤‡ä»½
            self._create_backup(file_path)
            
            # ä¿å­˜æ–°é…ç½®
            with open(file_path, 'w', encoding='utf-8') as f:
                json.dump(data, f, indent=2, ensure_ascii=False)
                
        except Exception as e:
            raise ConfigSaveError(f"ä¿å­˜é…ç½®æ–‡ä»¶å¤±è´¥: {e}")
    
    def _create_backup(self, file_path: str):
        """
        åˆ›å»ºé…ç½®æ–‡ä»¶å¤‡ä»½
        
        :param file_path: åŸæ–‡ä»¶è·¯å¾„
        """
        if os.path.exists(file_path):
            backup_path = f"{file_path}.backup.{int(time.time())}"
            shutil.copy2(file_path, backup_path)
            logger.info(f"é…ç½®æ–‡ä»¶å·²å¤‡ä»½åˆ°: {backup_path}")
```

## ğŸ”„ é…ç½®ç®¡ç†æµç¨‹

### 1. é…ç½®åŠ è½½æµç¨‹

```
å¯åŠ¨ç¨‹åº â†’ æ£€æŸ¥é…ç½®æ–‡ä»¶ â†’ åŠ è½½é…ç½®æ–‡ä»¶ â†’ éªŒè¯é…ç½® â†’ å¤„ç†ç¯å¢ƒå˜é‡ â†’ éªŒè¯è·¯å¾„ â†’ åˆå§‹åŒ–å¤±è´¥å¤„ç†å™¨ â†’ é…ç½®å°±ç»ª
```

### 2. é…ç½®æ›´æ–°æµç¨‹

```
ç”¨æˆ·ä¿®æ”¹é…ç½® â†’ éªŒè¯æ–°é…ç½® â†’ åˆ›å»ºå¤‡ä»½ â†’ ä¿å­˜æ–°é…ç½® â†’ é€šçŸ¥ç›¸å…³æ¨¡å— â†’ é…ç½®ç”Ÿæ•ˆ
```

### 3. ç¯å¢ƒå˜é‡å¤„ç†æµç¨‹

```
åŠ è½½é…ç½®æ–‡ä»¶ â†’ æ£€æŸ¥ç¯å¢ƒå˜é‡ â†’ éªŒè¯å¿…éœ€å˜é‡ â†’ é…ç½®å°±ç»ª
```

### 4. å¤±è´¥å¤„ç†æµç¨‹

```
å›¾ç‰‡å¤„ç†å¤±è´¥ â†’ è®°å½•å¤±è´¥ä¿¡æ¯ â†’ è·³è¿‡å¤±è´¥å›¾ç‰‡ â†’ ç»§ç»­å¤„ç† â†’ ç”Ÿæˆå¤±è´¥æŠ¥å‘Š â†’ æ”¯æŒåç»­è¡¥åš
```

## ğŸ“ ä½¿ç”¨ç¤ºä¾‹

### 1. åŸºæœ¬ä½¿ç”¨

```python
# åˆå§‹åŒ–é…ç½®ç®¡ç†å™¨
config_manager = ConfigManager()

# åŠ è½½é…ç½®
if config_manager.load_config():
    # è·å–é…ç½®å€¼
    chunk_size = config_manager.get('document_processing.chunk_size', 1000)
    pdf_dir = config_manager.get_path('input_pdf_dir')
    
    # è·å–å¤±è´¥å¤„ç†å™¨
    failure_handler = config_manager.get_failure_handler()
    
    print(f"Chunk size: {chunk_size}")
    print(f"PDFç›®å½•: {pdf_dir}")
else:
    print("é…ç½®åŠ è½½å¤±è´¥")
```

### 2. å¤±è´¥å¤„ç†ä½¿ç”¨

```python
# åœ¨å›¾ç‰‡å¤„ç†è¿‡ç¨‹ä¸­è®°å½•å¤±è´¥
try:
    # å¤„ç†å›¾ç‰‡
    enhanced_info = image_enhancer.enhance_image_description(image_path)
except Exception as e:
    # è®°å½•å¤±è´¥
    failure_handler = config_manager.get_failure_handler()
    failure_handler.record_failure(
        image_info=img_info,
        error_type="enhancement_api_error",
        error_message=str(e),
        retry_count=3
    )
    # è·³è¿‡å¤±è´¥ï¼Œç»§ç»­å¤„ç†ä¸‹ä¸€å¼ 
    continue

# è·å–å¤±è´¥å›¾ç‰‡åˆ—è¡¨ï¼Œç”¨äºåç»­è¡¥åš
failed_images = failure_handler.get_failed_images()
if failed_images:
    print(f"å‘ç° {len(failed_images)} å¼ å¤±è´¥çš„å›¾ç‰‡ï¼Œå¯ä»¥é€šè¿‡V502_image_enhancer_new.pyè¡¥åš")
```

### 3. ç¯å¢ƒå˜é‡è®¾ç½®ï¼ˆWindowsï¼‰

#### PowerShellï¼ˆä¸´æ—¶ï¼‰
```powershell
$env:DASHSCOPE_API_KEY="your_api_key_here"
$env:MINERU_API_KEY="your_mineru_key_here"
```

#### å‘½ä»¤æç¤ºç¬¦ï¼ˆä¸´æ—¶ï¼‰
```cmd
set DASHSCOPE_API_KEY=your_api_key_here
set MINERU_API_KEY=your_mineru_key_here
```

#### ç³»ç»Ÿç¯å¢ƒå˜é‡ï¼ˆæ°¸ä¹…ï¼‰
1. å³é”®"æ­¤ç”µè„‘" â†’ å±æ€§ â†’ é«˜çº§ç³»ç»Ÿè®¾ç½®
2. ç¯å¢ƒå˜é‡ â†’ æ–°å»º
3. å˜é‡å: `DASHSCOPE_API_KEY`, å˜é‡å€¼: `your_api_key_here`
4. å˜é‡å: `MINERU_API_KEY`, å˜é‡å€¼: `your_mineru_key_here`

### 4. é…ç½®æ–‡ä»¶ç¤ºä¾‹

```json
{
  "system": {
    "mode": "auto"
  },
  "paths": {
    "input_pdf_dir": "./document/orig_pdf",
    "mineru_output_dir": "./document/md",
    "final_image_dir": "./central/images",
    "vector_db_dir": "./central/vector_db"
  },
  "document_processing": {
    "chunk_size": 1200,
    "chunk_overlap": 300
  },
  "image_processing": {
    "enable_enhancement": true,
    "enhancement_model": "qwen-vl-plus"
  },
  "api_rate_limiting": {
    "enhancement_batch_size": 5,
    "enhancement_delay_seconds": 2,
    "vectorization_batch_size": 10,
    "vectorization_delay_seconds": 1
  },
  "failure_handling": {
    "skip_failed_images": true,
    "generate_failure_report": true,
    "mark_for_later_processing": true
  }
}
```

## ï¿½ï¿½ æ‰©å±•æ€§è®¾è®¡

### 1. è·¯å¾„é…ç½®æ‰©å±•
- æ”¯æŒæ–°å¢æ–‡ä»¶ç±»å‹ç›®å½•
- æ”¯æŒè‡ªå®šä¹‰è¾“å‡ºç›®å½•ç»“æ„
- æ”¯æŒå¤šç¯å¢ƒè·¯å¾„é…ç½®

### 2. æ¨¡å‹é…ç½®æ‰©å±•
- æ”¯æŒæ–°å¢å‘é‡åŒ–æ¨¡å‹
- æ”¯æŒæ–°å¢å›¾ç‰‡å¢å¼ºæ¨¡å‹
- æ”¯æŒæ¨¡å‹å‚æ•°é…ç½®

### 3. é…ç½®ç‰ˆæœ¬ç®¡ç†
- æ”¯æŒé…ç½®ç‰ˆæœ¬å‡çº§
- æ”¯æŒé…ç½®å‘åå…¼å®¹
- æ”¯æŒé…ç½®è¿ç§»å·¥å…·

### 4. å¤±è´¥å¤„ç†æ‰©å±•
- æ”¯æŒæ–°å¢å¤±è´¥ç±»å‹
- æ”¯æŒè‡ªå®šä¹‰å¤±è´¥å¤„ç†ç­–ç•¥
- æ”¯æŒå¤±è´¥å¤„ç†æ’ä»¶

## å®‰å…¨æ€§è®¾è®¡

### 1. æ•æ„Ÿä¿¡æ¯ä¿æŠ¤
- APIå¯†é’¥ç­‰æ•æ„Ÿä¿¡æ¯é€šè¿‡ç¯å¢ƒå˜é‡ç®¡ç†
- é…ç½®æ–‡ä»¶ä¸åŒ…å«æ•æ„Ÿä¿¡æ¯
- æ”¯æŒé…ç½®åŠ å¯†å­˜å‚¨

### 2. è·¯å¾„å®‰å…¨
- è·¯å¾„éªŒè¯ï¼Œé˜²æ­¢è·¯å¾„éå†æ”»å‡»
- è·¯å¾„æƒé™æ£€æŸ¥
- ä¸´æ—¶æ–‡ä»¶å®‰å…¨æ¸…ç†

### 3. å¤±è´¥ä¿¡æ¯å®‰å…¨
- å¤±è´¥æŠ¥å‘Šä¸åŒ…å«æ•æ„Ÿä¿¡æ¯
- å¤±è´¥æ—¥å¿—å®‰å…¨å­˜å‚¨
- å¤±è´¥ä¿¡æ¯è®¿é—®æ§åˆ¶

## æ€§èƒ½ä¼˜åŒ–

### 1. é…ç½®ç¼“å­˜
- é…ç½®åŠ è½½åç¼“å­˜åœ¨å†…å­˜ä¸­
- æ”¯æŒé…ç½®çƒ­æ›´æ–°
- å‡å°‘æ–‡ä»¶I/Oæ“ä½œ

### 2. è·¯å¾„ç¼“å­˜
- ç»å¯¹è·¯å¾„è®¡ç®—ç»“æœç¼“å­˜
- ç›®å½•å­˜åœ¨æ€§æ£€æŸ¥ç¼“å­˜
- å‡å°‘æ–‡ä»¶ç³»ç»Ÿè®¿é—®

### 3. å¤±è´¥å¤„ç†ä¼˜åŒ–
- å¤±è´¥è®°å½•æ‰¹é‡å†™å…¥
- å¤±è´¥æŠ¥å‘Šå¢é‡æ›´æ–°
- å¤±è´¥ä¿¡æ¯ç´¢å¼•ä¼˜åŒ–

## æµ‹è¯•ç­–ç•¥

### 1. å•å…ƒæµ‹è¯•
- é…ç½®åŠ è½½æµ‹è¯•
- é…ç½®éªŒè¯æµ‹è¯•
- ç¯å¢ƒå˜é‡å¤„ç†æµ‹è¯•
- è·¯å¾„ç®¡ç†æµ‹è¯•
- å¤±è´¥å¤„ç†æµ‹è¯•

### 2. é›†æˆæµ‹è¯•
- é…ç½®ç®¡ç†æµç¨‹æµ‹è¯•
- é…ç½®æ›´æ–°æµç¨‹æµ‹è¯•
- å¤±è´¥å¤„ç†æµç¨‹æµ‹è¯•
- é”™è¯¯å¤„ç†æµ‹è¯•

### 3. è·¨å¹³å°æµ‹è¯•
- Windowsç¯å¢ƒæµ‹è¯•
- Linuxç¯å¢ƒæµ‹è¯•
- macOSç¯å¢ƒæµ‹è¯•

### 4. å¤±è´¥å¤„ç†æµ‹è¯•
- å¤±è´¥è®°å½•æµ‹è¯•
- å¤±è´¥æŠ¥å‘Šç”Ÿæˆæµ‹è¯•
- å¤±è´¥æ¢å¤æµ‹è¯•
- ä¸V502_image_enhancer_new.pyé›†æˆæµ‹è¯•

---

è¿™å°±æ˜¯å®Œæ•´çš„é…ç½®ç®¡ç†ç³»ç»Ÿè¯¦ç»†è®¾è®¡æ–‡æ¡£ã€‚ç°åœ¨åŒ…å«äº†æ‰€æœ‰å¿…è¦çš„é…ç½®å‚æ•°ï¼Œç‰¹åˆ«æ˜¯ï¼š

1. **æ–‡ä»¶è·¯å¾„é…ç½®**ï¼šPDFè¾“å…¥ã€MinerUè¾“å‡ºã€å›¾ç‰‡å­˜å‚¨ã€å‘é‡æ•°æ®åº“ç­‰
2. **æ¨¡å‹é€‰æ‹©é…ç½®**ï¼šå›¾ç‰‡å¢å¼ºæ¨¡å‹ã€å‘é‡åŒ–æ¨¡å‹ç­‰
3. **APIé™æµé…ç½®**ï¼šæ‰¹é‡å¤„ç†ã€å»¶è¿Ÿæ§åˆ¶ã€é‡è¯•æœºåˆ¶ç­‰
4. **å¤±è´¥å¤„ç†é…ç½®**ï¼šè·³è¿‡å¤±è´¥ã€ç”ŸæˆæŠ¥å‘Šã€æ”¯æŒåç»­è¡¥åšç­‰
5. **Windowså…¼å®¹æ€§**ï¼šç¯å¢ƒå˜é‡è®¾ç½®æŒ‡å—ç­‰

è¿™ä¸ªè®¾è®¡å®Œå…¨æ”¯æŒä½ æåˆ°çš„"è·³è¿‡å¤±è´¥ï¼Œä½†å¯ä»¥è®©åé¢çš„ä¸“é—¨å¤„ç†å¢å¼ºå›¾ç‰‡çš„ç¨‹åºè¡¥åš"çš„éœ€æ±‚ï¼Œä¸V502_image_enhancer_new.pyå®Œç¾é…åˆã€‚