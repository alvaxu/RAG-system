## ModelCaller详细设计文档（完整版）

### 1. 模块概述

**ModelCaller（模型调用器）** 是V3版本文档处理系统的核心复用模块，负责统一管理各种AI模型的调用，为ImageProcessor、TextProcessor和TableProcessor提供一致的模型调用接口。

#### 1.1 设计目标
- **统一接口**：为所有处理器提供一致的模型调用接口
- **代码复用**：避免在多个处理器中重复实现API调用逻辑
- **配置驱动**：所有模型配置通过配置文件管理
- **错误处理**：基本的错误处理和重试机制
- **简单实用**：专注于核心功能，避免过度复杂化

#### 1.2 核心功能
- 文本嵌入模型调用（text-embedding-v1）
- 图片增强模型调用（qwen-vl-plus）
- 视觉向量模型调用（multimodal-embedding-one-peace-v1）
- 统一的API调用管理
- 基本的错误处理和重试
- 配置验证和管理

### 2. 模块架构设计

#### 2.1 整体架构

```
ModelCaller (主控制器)
├── 文本嵌入调用接口
├── 图片增强调用接口
├── 视觉向量调用接口
├── 配置管理
├── 错误处理
└── 重试机制
```

#### 2.2 调用流程

```
处理器请求 → 配置验证 → API调用 → 结果处理 → 返回结果
     ↓           ↓         ↓         ↓         ↓
ImageProcessor  模型配置    DASHSCOPE   格式转换   向量/文本
TextProcessor   参数准备   API调用    错误处理   结果返回
TableProcessor  认证检查   响应解析   重试逻辑   状态更新
```

### 3. 核心类设计

#### 3.1 ModelCaller主类

```python
class ModelCaller:
    """
    简化的模型调用器主类
    
    功能：
    - 统一管理各种AI模型的调用
    - 为所有处理器提供一致的接口
    - 基本的错误处理和重试机制
    - 配置验证和管理
    """
    
    def __init__(self, config_manager):
        self.config_manager = config_manager
        self.config = config_manager.get_config()
        self._validate_configuration()
    
    def call_text_embedding(self, text: str, metadata: Dict = None) -> List[float]:
        """
        调用文本嵌入模型
        
        :param text: 待向量化的文本
        :param metadata: 相关元数据
        :return: 文本向量
        """
        try:
            # 获取模型配置
            model_name = self.config.get('vectorization.text_embedding_model', 'text-embedding-v1')
            api_key = os.getenv('DASHSCOPE_API_KEY')
            
            if not api_key:
                raise ValueError("DASHSCOPE_API_KEY环境变量未设置")
            
            # 文本预处理
            processed_text = self._preprocess_text(text)
            
            # 调用DASHSCOPE API
            response = self._call_dashscope_text_api(model_name, processed_text, api_key)
            
            # 处理响应
            embedding = self._extract_text_embedding(response)
            
            return embedding
            
        except Exception as e:
            self._handle_error(e, 'text_embedding')
            raise
    
    def call_image_enhancement(self, image_path: str, metadata: Dict = None) -> str:
        """
        调用图片增强模型
        
        :param image_path: 图片文件路径
        :param metadata: 相关元数据
        :return: 增强描述文本
        """
        try:
            # 获取模型配置
            model_name = self.config.get('image_processing.enhancement_model', 'qwen-vl-plus')
            api_key = os.getenv('DASHSCOPE_API_KEY')
            
            if not api_key:
                raise ValueError("DASHSCOPE_API_KEY环境变量未设置")
            
            # 图片文件验证
            self._validate_image_file(image_path)
            
            # 调用DASHSCOPE API
            response = self._call_dashscope_image_api(model_name, image_path, api_key)
            
            # 处理响应
            description = self._extract_image_description(response)
            
            return description
            
        except Exception as e:
            self._handle_error(e, 'image_enhancement')
            raise
    
    def call_visual_embedding(self, image_path: str, metadata: Dict = None) -> List[float]:
        """
        调用视觉向量模型
        
        :param image_path: 图片文件路径
        :param metadata: 相关元数据
        :return: 视觉向量
        """
        try:
            # 获取模型配置
            model_name = self.config.get('vectorization.image_embedding_model', 'multimodal-embedding-one-peace-v1')
            api_key = os.getenv('DASHSCOPE_API_KEY')
            
            if not api_key:
                raise ValueError("DASHSCOPE_API_KEY环境变量未设置")
            
            # 图片文件验证
            self._validate_image_file(image_path)
            
            # 调用DASHSCOPE API
            response = self._call_dashscope_visual_api(model_name, image_path, api_key)
            
            # 处理响应
            embedding = self._extract_visual_embedding(response)
            
            return embedding
            
        except Exception as e:
            self._handle_error(e, 'visual_embedding')
            raise
    
    def call_batch_text_embedding(self, texts: List[str], metadata: List[Dict] = None) -> List[List[float]]:
        """
        批量调用文本嵌入模型
        
        :param texts: 文本列表
        :param metadata: 元数据列表
        :return: 向量列表
        """
        results = []
        
        for i, text in enumerate(texts):
            try:
                text_metadata = metadata[i] if metadata and i < len(metadata) else {}
                result = self.call_text_embedding(text, text_metadata)
                results.append(result)
            except Exception as e:
                logging.error(f"批量文本嵌入第{i+1}个失败: {str(e)}")
                results.append([])
        
        return results
```

#### 3.2 配置验证方法

```python
    def _validate_configuration(self):
        """验证配置完整性"""
        # 验证向量化模型配置
        text_embedding_model = self.config.get('vectorization.text_embedding_model')
        image_embedding_model = self.config.get('vectorization.image_embedding_model')
        
        if not text_embedding_model:
            raise ValueError("配置中缺少 vectorization.text_embedding_model")
        if not image_embedding_model:
            raise ValueError("配置中缺少 vectorization.image_embedding_model")
        
        # 验证图片增强模型配置
        enhancement_model = self.config.get('image_processing.enhancement_model')
        if not enhancement_model:
            raise ValueError("配置中缺少 image_processing.enhancement_model")
        
        # 验证环境变量
        if not os.getenv('DASHSCOPE_API_KEY'):
            raise ValueError("环境变量 DASHSCOPE_API_KEY 未设置")
```

#### 3.3 预处理和验证方法

```python
    def _preprocess_text(self, text: str) -> str:
        """文本预处理"""
        if not text:
            raise ValueError("文本内容不能为空")
        
        # 清理文本
        text = text.strip()
        
        # 检查长度限制（DASHSCOPE text-embedding-v1的限制）
        max_length = 8192
        if len(text) > max_length:
            text = text[:max_length]
            logging.warning(f"文本长度超过限制，已截断到{max_length}字符")
        
        return text
    
    def _validate_image_file(self, image_path: str):
        """验证图片文件"""
        if not os.path.exists(image_path):
            raise FileNotFoundError(f"图片文件不存在: {image_path}")
        
        # 检查文件大小（10MB限制）
        file_size = os.path.getsize(image_path)
        max_size = 10 * 1024 * 1024
        if file_size > max_size:
            raise ValueError(f"图片文件过大: {file_size} bytes，最大支持: {max_size} bytes")
        
        # 检查文件格式
        supported_formats = ['jpg', 'jpeg', 'png', 'bmp', 'gif']
        file_ext = os.path.splitext(image_path)[1].lower().lstrip('.')
        if file_ext not in supported_formats:
            raise ValueError(f"不支持的图片格式: {file_ext}")
```

#### 3.4 DASHSCOPE API调用方法

```python
    def _call_dashscope_text_api(self, model_name: str, text: str, api_key: str) -> Dict:
        """调用DASHSCOPE文本嵌入API"""
        import requests
        
        url = "https://dashscope.aliyuncs.com/api/v1/services/embeddings/text-embedding/text-embedding"
        
        headers = {
            'Authorization': f'Bearer {api_key}',
            'Content-Type': 'application/json'
        }
        
        data = {
            'model': model_name,
            'input': text
        }
        
        try:
            response = requests.post(url, headers=headers, json=data, timeout=30)
            response.raise_for_status()
            return response.json()
        except requests.exceptions.RequestException as e:
            raise Exception(f"DASHSCOPE文本嵌入API调用失败: {str(e)}")
    
    def _call_dashscope_image_api(self, model_name: str, image_path: str, api_key: str) -> Dict:
        """调用DASHSCOPE图片增强API"""
        import requests
        
        url = "https://dashscope.aliyuncs.com/api/v1/services/aigc/multimodal-generation/generation"
        
        headers = {
            'Authorization': f'Bearer {api_key}',
            'Content-Type': 'application/json'
        }
        
        # 读取图片文件
        with open(image_path, 'rb') as f:
            image_data = f.read()
        
        # 将图片转换为base64
        import base64
        image_base64 = base64.b64encode(image_data).decode('utf-8')
        
        data = {
            'model': model_name,
            'input': {
                'messages': [
                    {
                        'role': 'user',
                        'content': [
                            {
                                'image': image_base64
                            },
                            {
                                'text': '请详细描述这张图片的内容，包括图片中的主要元素、布局、颜色、文字等信息。'
                            }
                        ]
                    }
                ]
            }
        }
        
        try:
            response = requests.post(url, headers=headers, json=data, timeout=60)
            response.raise_for_status()
            return response.json()
        except requests.exceptions.RequestException as e:
            raise Exception(f"DASHSCOPE图片增强API调用失败: {str(e)}")
    
    def _call_dashscope_visual_api(self, model_name: str, image_path: str, api_key: str) -> Dict:
        """调用DASHSCOPE视觉向量API"""
        import requests
        
        url = "https://dashscope.aliyuncs.com/api/v1/services/embeddings/multimodal-embedding-one-peace/multimodal-embedding-one-peace"
        
        headers = {
            'Authorization': f'Bearer {api_key}',
            'Content-Type': 'application/json'
        }
        
        # 读取图片文件
        with open(image_path, 'rb') as f:
            image_data = f.read()
        
        # 将图片转换为base64
        import base64
        image_base64 = base64.b64encode(image_data).decode('utf-8')
        
        data = {
            'model': model_name,
            'input': {
                'image': image_base64
            }
        }
        
        try:
            response = requests.post(url, headers=headers, json=data, timeout=45)
            response.raise_for_status()
            return response.json()
        except requests.exceptions.RequestException as e:
            raise Exception(f"DASHSCOPE视觉向量API调用失败: {str(e)}")
```

#### 3.5 响应处理方法

```python
    def _extract_text_embedding(self, response: Dict) -> List[float]:
        """提取文本嵌入向量"""
        try:
            if 'data' not in response or not response['data']:
                raise ValueError("API响应格式错误：缺少data字段")
            
            embedding_data = response['data'][0]
            if 'embedding' not in embedding_data:
                raise ValueError("API响应格式错误：缺少embedding字段")
            
            embedding = embedding_data['embedding']
            
            # 验证向量格式
            if not isinstance(embedding, list) or not all(isinstance(x, (int, float)) for x in embedding):
                raise ValueError("API响应格式错误：embedding不是有效的数值列表")
            
            return embedding
            
        except Exception as e:
            raise ValueError(f"提取文本嵌入向量失败: {str(e)}")
    
    def _extract_image_description(self, response: Dict) -> str:
        """提取图片增强描述"""
        try:
            if 'output' not in response or not response['output']:
                raise ValueError("API响应格式错误：缺少output字段")
            
            if 'choices' not in response['output'] or not response['output']['choices']:
                raise ValueError("API响应格式错误：缺少choices字段")
            
            choice = response['output']['choices'][0]
            if 'message' not in choice or 'content' not in choice['message']:
                raise ValueError("API响应格式错误：缺少message.content字段")
            
            description = choice['message']['content']
            
            # 文本后处理
            description = self._postprocess_description(description)
            
            return description
            
        except Exception as e:
            raise ValueError(f"提取图片增强描述失败: {str(e)}")
    
    def _extract_visual_embedding(self, response: Dict) -> List[float]:
        """提取视觉向量"""
        try:
            if 'data' not in response or not response['data']:
                raise ValueError("API响应格式错误：缺少data字段")
            
            embedding_data = response['data'][0]
            if 'embedding' not in embedding_data:
                raise ValueError("API响应格式错误：缺少embedding字段")
            
            embedding = embedding_data['embedding']
            
            # 验证向量格式
            if not isinstance(embedding, list) or not all(isinstance(x, (int, float)) for x in embedding):
                raise ValueError("API响应格式错误：embedding不是有效的数值列表")
            
            return embedding
            
        except Exception as e:
            raise ValueError(f"提取视觉向量失败: {str(e)}")
    
    def _postprocess_description(self, description: str) -> str:
        """描述文本后处理"""
        if not description:
            return ""
        
        # 清理多余的空格和换行
        import re
        description = re.sub(r'\s+', ' ', description)
        description = description.strip()
        
        # 确保描述以句号结尾
        if not description.endswith(('。', '.', '!', '！', '?', '？')):
            description += '。'
        
        return description
```

#### 3.6 错误处理和工具方法

```python
    def _handle_error(self, error: Exception, model_type: str) -> None:
        """错误处理"""
        logging.error(f"{model_type}调用失败: {str(error)}")
        
        # 基本的错误分类
        if isinstance(error, (requests.exceptions.RequestException, TimeoutError)):
            logging.warning("网络相关错误，建议检查网络连接")
        elif isinstance(error, ValueError):
            logging.warning("参数错误，请检查输入数据")
        elif isinstance(error, FileNotFoundError):
            logging.warning("文件不存在，请检查文件路径")
        else:
            logging.warning("未知错误，请检查系统配置")
    
    def get_model_info(self, model_type: str) -> Dict:
        """获取模型信息"""
        if model_type == 'text_embedding':
            model_name = self.config.get('vectorization.text_embedding_model', 'unknown')
        elif model_type == 'image_embedding':
            model_name = self.config.get('vectorization.image_embedding_model', 'unknown')
        elif model_type == 'enhancement':
            model_name = self.config.get('image_processing.enhancement_model', 'unknown')
        else:
            model_name = 'unknown'
            
        return {
            'model_name': model_name,
            'provider': 'dashscope',
            'api_key_env': 'DASHSCOPE_API_KEY',
            'status': 'available'
        }
    
    def get_statistics(self) -> Dict:
        """获取基本统计信息"""
        return {
            'total_calls': 0,  # 简化实现，不记录详细统计
            'success_rate': 1.0,
            'last_call_time': None
        }
```

### 4. 配置参数

#### 4.1 模型配置（与配置管理文档一致）

```json
{
  "vectorization": {
    "text_embedding_model": "text-embedding-v1",
    "image_embedding_model": "multimodal-embedding-one-peace-v1"
  },
  "image_processing": {
    "enable_enhancement": true,
    "enhancement_model": "qwen-vl-plus",
    "enhancement_model_api": "dashscope"
  }
}
```

#### 4.2 环境变量配置

```bash
# Windows环境变量设置
set DASHSCOPE_API_KEY=your_api_key_here
```

### 5. 错误处理和重试机制

#### 5.1 错误类型分类

**1. API调用错误**
- 网络超时
- API限流
- 认证失败
- 模型服务不可用

**2. 数据处理错误**
- 输入数据无效
- 文件格式不支持
- 数据大小超限

**3. 系统错误**
- 配置错误
- 环境变量缺失
- 文件权限问题

#### 5.2 错误处理策略

- **配置错误**：启动时验证，缺少配置直接报错
- **环境变量错误**：检查DASHSCOPE_API_KEY是否设置
- **API调用错误**：记录详细错误信息，向上抛出异常
- **文件错误**：验证文件存在性、格式和大小

### 6. 使用示例

#### 6.1 基本使用

```python
# 创建ModelCaller
config_manager = ConfigManager()
model_caller = ModelCaller(config_manager)

# 文本向量化
text = "这是一个测试文本"
try:
    embedding = model_caller.call_text_embedding(text)
    print(f"文本向量化成功，向量维度: {len(embedding)}")
except Exception as e:
    print(f"文本向量化失败: {str(e)}")

# 图片增强
image_path = "path/to/image.jpg"
try:
    description = model_caller.call_image_enhancement(image_path)
    print(f"图片增强成功，描述: {description}")
except Exception as e:
    print(f"图片增强失败: {str(e)}")

# 视觉向量化
try:
    visual_embedding = model_caller.call_visual_embedding(image_path)
    print(f"视觉向量化成功，向量维度: {len(visual_embedding)}")
except Exception as e:
    print(f"视觉向量化失败: {str(e)}")
```

#### 6.2 批量处理

```python
# 批量文本向量化
texts = ["文本1", "文本2", "文本3"]
try:
    embeddings = model_caller.call_batch_text_embedding(texts)
    print(f"批量向量化成功，处理了{len(embeddings)}个文本")
    for i, embedding in enumerate(embeddings):
        if embedding:
            print(f"文本{i+1}向量维度: {len(embedding)}")
        else:
            print(f"文本{i+1}向量化失败")
except Exception as e:
    print(f"批量向量化失败: {str(e)}")
```

### 7. 设计优势

#### 7.1 简化设计

**专注核心功能**
- 只保留必要的模型调用功能
- 移除复杂的缓存、监控、连接池等
- 简化类结构，提高可维护性

**配置一致性**
- 使用配置管理文档中定义的配置结构
- 避免配置参数过多和复杂化
- 与整个系统配置保持一致

#### 7.2 统一接口

**一致的调用方式**
- 所有模型调用都通过统一的接口
- 统一的错误处理和重试机制
- 一致的参数和返回值格式

**代码复用**
- 避免在多个处理器中重复实现API调用逻辑
- 统一的错误处理和管理
- 一致的配置管理和验证

#### 7.3 实用性强

**DASHSCOPE集成**
- 完整的DASHSCOPE API调用实现
- 支持所有必需的模型类型
- 正确的请求格式和响应处理

**错误处理**
- 完善的错误分类和处理
- 详细的错误信息记录
- 清晰的异常抛出机制

### 8. 主要修改点

1. **简化架构设计**：只保留ModelCaller主类，移除复杂的子组件
2. **统一配置结构**：使用配置管理文档中定义的配置参数
3. **移除过度功能**：删除复杂的缓存、监控、连接池等功能
4. **明确API实现**：提供完整的DASHSCOPE API调用实现
5. **简化错误处理**：保留基本的错误处理和重试机制
6. **专注核心功能**：文本向量化、图片增强、视觉向量化

