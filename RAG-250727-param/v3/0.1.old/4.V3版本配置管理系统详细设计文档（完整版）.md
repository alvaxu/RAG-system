

# V3版本配置管理系统详细设计文档（完整版）

## 文档概述

### 文档目的
设计V3版本向量数据库构建系统的配置管理系统，实现配置的集中化、标准化和易管理性，包含所有必要的文件路径、模型选择、API配置和失败处理策略。

### 设计原则
- **配置集中化**：所有配置集中在一个地方管理
- **环境变量优先**：敏感信息通过环境变量管理
- **Windows兼容**：支持Windows系统的环境变量设置
- **参数验证**：配置加载时进行完整性验证
- **默认值管理**：提供合理的默认配置
- **失败处理**：支持失败跳过和后续补做机制

##️ 系统架构设计

### 整体架构
```
用户配置 → 配置管理器 → 配置验证器 → 配置加载器 → 环境变量处理 → 路径验证 → 配置分发器 → 各模块使用
```

### 核心组件
1. **ConfigManager**：配置管理器主类
2. **ConfigValidator**：配置验证器
3. **ConfigLoader**：配置加载器
4. **EnvironmentManager**：环境变量管理器（Windows兼容）
5. **PathManager**：路径管理器
6. **FailureHandler**：失败处理管理器

## 📁 目录结构设计

```
v3/
├── config/
│   ├── __init__.py
│   ├── config_manager.py          # 配置管理器主类
│   ├── config_validator.py        # 配置验证器
│   ├── config_loader.py           # 配置加载器
│   ├── environment_manager.py     # 环境变量管理器（Windows兼容）
│   ├── path_manager.py            # 路径管理器
│   ├── failure_handler.py         # 失败处理管理器
│   ├── v3_config.json            # V3配置文件
│   └── v3_config_schema.json     # 配置模式文件
```

## ⚙️ 配置结构设计

### 1. 主配置文件结构 (v3_config.json)

```json
{
  "version": "3.0.0",
  "system": {
    "mode": "auto",
    "log_level": "INFO"
  },
  "paths": {
    "input_pdf_dir": "./document/orig_pdf",
    "mineru_output_dir": "./document/md",
    "final_image_dir": "./central/images",
    "vector_db_dir": "./central/vector_db",
    "temp_dir": "./temp",
    "logs_dir": "./logs"
  },
  "document_processing": {
    "chunk_size": 1000,
    "chunk_overlap": 200
  },
  "vectorization": {
    "text_embedding_model": "text-embedding-v1",
    "image_embedding_model": "multimodal-embedding-one-peace-v1"
  },
  "image_processing": {
    "enable_enhancement": true,
    "enhancement_model": "qwen-vl-plus",
    "enhancement_model_api": "dashscope"
  },
  "mineru": {
    "api_endpoint": "https://api.mineru.com",
    "batch_size": 10,
    "timeout": 300,
    "retry_count": 3,
    "poll_interval": 10
  },
  "api_rate_limiting": {
    "enhancement_batch_size": 5,
    "enhancement_delay_seconds": 2,
    "vectorization_batch_size": 10,
    "vectorization_delay_seconds": 1,
    "max_retries": 3,
    "retry_delay_seconds": 5,
    "enable_rate_limiting": true
  },
  "batch_processing": {
    "enhancement_workers": 2,
    "vectorization_workers": 3,
    "queue_size": 100,
    "timeout_seconds": 300,
    "progress_report_interval": 10
  },
  "failure_handling": {
    "skip_failed_images": true,
    "max_retries": 3,
    "retry_delay_seconds": 5,
    "continue_on_failure": true,
    "generate_failure_report": true,
    "failure_report_path": "./logs/failure_report.json",
    "mark_for_later_processing": true,
    "failure_report_format": "detailed"
  },
  "storage": {
    "backup_enabled": true,
    "backup_interval": 24
  }
}
```

### 2. 配置模式文件 (v3_config_schema.json)

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "type": "object",
  "required": ["version", "system", "paths", "document_processing", "vectorization"],
  "properties": {
    "version": {
      "type": "string",
      "pattern": "^\\d+\\.\\d+\\.\\d+$"
    },
    "system": {
      "type": "object",
      "required": ["mode"],
      "properties": {
        "mode": {
          "type": "string",
          "enum": ["auto", "new", "incremental"]
        },
        "log_level": {
          "type": "string",
          "enum": ["DEBUG", "INFO", "WARNING", "ERROR"]
        }
      }
    },
    "paths": {
      "type": "object",
      "required": ["input_pdf_dir", "mineru_output_dir", "final_image_dir", "vector_db_dir"],
      "properties": {
        "input_pdf_dir": {"type": "string"},
        "mineru_output_dir": {"type": "string"},
        "final_image_dir": {"type": "string"},
        "vector_db_dir": {"type": "string"},
        "temp_dir": {"type": "string"},
        "logs_dir": {"type": "string"}
      }
    },
    "document_processing": {
      "type": "object",
      "required": ["chunk_size", "chunk_overlap"],
      "properties": {
        "chunk_size": {
          "type": "integer",
          "minimum": 100,
          "maximum": 5000
        },
        "chunk_overlap": {
          "type": "integer",
          "minimum": 0,
          "maximum": 1000
        }
      }
    },
    "vectorization": {
      "type": "object",
      "required": ["text_embedding_model", "image_embedding_model"],
      "properties": {
        "text_embedding_model": {"type": "string"},
        "image_embedding_model": {"type": "string"}
      }
    },
    "image_processing": {
      "type": "object",
      "required": ["enable_enhancement"],
      "properties": {
        "enable_enhancement": {"type": "boolean"},
        "enhancement_model": {"type": "string"},
        "enhancement_model_api": {"type": "string"}
      }
    },
    "mineru": {
      "type": "object",
      "required": ["api_endpoint"],
      "properties": {
        "api_endpoint": {"type": "string"},
        "batch_size": {
          "type": "integer",
          "minimum": 1,
          "maximum": 50
        },
        "timeout": {
          "type": "integer",
          "minimum": 60,
          "maximum": 1800
        },
        "retry_count": {
          "type": "integer",
          "minimum": 1,
          "maximum": 10
        },
        "poll_interval": {
          "type": "integer",
          "minimum": 5,
          "maximum": 60
        }
      }
    },
    "api_rate_limiting": {
      "type": "object",
      "required": ["enhancement_batch_size", "enhancement_delay_seconds", "vectorization_batch_size", "vectorization_delay_seconds"],
      "properties": {
        "enhancement_batch_size": {
          "type": "integer",
          "minimum": 1,
          "maximum": 20
        },
        "enhancement_delay_seconds": {
          "type": "integer",
          "minimum": 1,
          "maximum": 60
        },
        "vectorization_batch_size": {
          "type": "integer",
          "minimum": 1,
          "maximum": 50
        },
        "vectorization_delay_seconds": {
          "type": "integer",
          "minimum": 0,
          "maximum": 30
        },
        "max_retries": {
          "type": "integer",
          "minimum": 1,
          "maximum": 10
        },
        "retry_delay_seconds": {
          "type": "integer",
          "minimum": 1,
          "maximum": 60
        },
        "enable_rate_limiting": {"type": "boolean"}
      }
    },
    "batch_processing": {
      "type": "object",
      "properties": {
        "enhancement_workers": {
          "type": "integer",
          "minimum": 1,
          "maximum": 8
        },
        "vectorization_workers": {
          "type": "integer",
          "minimum": 1,
          "maximum": 10
        },
        "queue_size": {
          "type": "integer",
          "minimum": 10,
          "maximum": 1000
        },
        "timeout_seconds": {
          "type": "integer",
          "minimum": 60,
          "maximum": 1800
        },
        "progress_report_interval": {
          "type": "integer",
          "minimum": 5,
          "maximum": 60
        }
      }
    },
    "failure_handling": {
      "type": "object",
      "required": ["skip_failed_images", "generate_failure_report"],
      "properties": {
        "skip_failed_images": {"type": "boolean"},
        "max_retries": {
          "type": "integer",
          "minimum": 1,
          "maximum": 10
        },
        "retry_delay_seconds": {
          "type": "integer",
          "minimum": 1,
          "maximum": 60
        },
        "continue_on_failure": {"type": "boolean"},
        "generate_failure_report": {"type": "boolean"},
        "failure_report_path": {"type": "string"},
        "mark_for_later_processing": {"type": "boolean"},
        "failure_report_format": {
          "type": "string",
          "enum": ["simple", "detailed"]
        }
      }
    },
    "storage": {
      "type": "object",
      "properties": {
        "backup_enabled": {"type": "boolean"},
        "backup_interval": {
          "type": "integer",
          "minimum": 1,
          "maximum": 168
        }
      }
    }
  }
}
```

## 🔧 核心类设计

### 1. ConfigManager 主类

```python
class ConfigManager:
    """
    配置管理器主类
    
    功能：
    - 统一管理所有配置
    - 提供配置访问接口
    - 管理配置的加载和验证
    - 支持配置热更新
    - 集成失败处理管理
    """
    
    def __init__(self, config_path: str = None):
        """
        初始化配置管理器
        
        :param config_path: 配置文件路径，如果为None则使用默认路径
        """
        self.config_path = config_path or "v3/config/v3_config.json"
        self.config_data = {}
        self.config_schema = {}
        self.environment_manager = EnvironmentManager()
        self.validator = ConfigValidator()
        self.loader = ConfigLoader()
        self.path_manager = PathManager()
        self.failure_handler = FailureHandler()
        
    def load_config(self) -> bool:
        """
        加载配置文件
        
        :return: 是否加载成功
        """
        try:
            # 加载配置文件
            self.config_data = self.loader.load_json(self.config_path)
            
            # 加载配置模式
            schema_path = self._get_schema_path()
            self.config_schema = self.loader.load_json(schema_path)
            
            # 验证配置
            if not self.validator.validate(self.config_data, self.config_schema):
                raise ValueError("配置验证失败")
            
            # 处理环境变量
            self._process_environment_variables()
            
            # 验证路径
            if not self.path_manager.validate_paths(self.config_data.get('paths', {})):
                raise ValueError("路径配置验证失败")
            
            # 初始化失败处理器
            self.failure_handler.initialize(self.config_data.get('failure_handling', {}))
            
            return True
            
        except Exception as e:
            logger.error(f"配置加载失败: {e}")
            return False
    
    def get(self, key: str, default=None):
        """
        获取配置值
        
        :param key: 配置键，支持点号分隔的嵌套键
        :param default: 默认值
        :return: 配置值
        """
        keys = key.split('.')
        value = self.config_data
        
        try:
            for k in keys:
                value = value[k]
            return value
        except (KeyError, TypeError):
            return default
    
    def get_path(self, path_key: str) -> str:
        """
        获取路径配置，支持相对路径转换为绝对路径
        
        :param path_key: 路径键
        :return: 绝对路径
        """
        relative_path = self.get(f"paths.{path_key}")
        if relative_path:
            return self.path_manager.get_absolute_path(relative_path)
        return None
    
    def get_failure_handler(self) -> 'FailureHandler':
        """
        获取失败处理器实例
        
        :return: 失败处理器实例
        """
        return self.failure_handler
    
    def set(self, key: str, value):
        """
        设置配置值
        
        :param key: 配置键
        :param value: 配置值
        """
        keys = key.split('.')
        config = self.config_data
        
        for k in keys[:-1]:
            if k not in config:
                config[k] = {}
            config = config[k]
        
        config[keys[-1]] = value
    
    def save_config(self) -> bool:
        """
        保存配置到文件
        
        :return: 是否保存成功
        """
        try:
            self.loader.save_json(self.config_path, self.config_data)
            return True
        except Exception as e:
            logger.error(f"配置保存失败: {e}")
            return False
    
    def _process_environment_variables(self):
        """
        处理环境变量覆盖
        """
        # 处理API密钥
        if self.environment_manager.get_dashscope_api_key():
            # 不存储在配置中，只在需要时读取
            pass
        
        if self.environment_manager.get_mineru_api_key():
            # 不存储在配置中，只在需要时读取
            pass
```

### 2. FailureHandler 失败处理管理器

```python
class FailureHandler:
    """
    失败处理管理器
    
    功能：
    - 管理图片处理失败的情况
    - 生成详细的失败报告
    - 支持后续补做机制
    - 与V502_image_enhancer_new.py配合
    """
    
    def __init__(self):
        self.config = {}
        self.failure_report_path = ""
        self.failed_images = []
        self.failure_report_format = "detailed"
        
    def initialize(self, failure_config: dict):
        """
        初始化失败处理器
        
        :param failure_config: 失败处理配置
        """
        self.config = failure_config
        self.failure_report_path = failure_config.get('failure_report_path', './logs/failure_report.json')
        self.failure_report_format = failure_config.get('failure_report_format', 'detailed')
        
        # 确保日志目录存在
        logs_dir = os.path.dirname(self.failure_report_path)
        os.makedirs(logs_dir, exist_ok=True)
        
        # 加载现有的失败报告
        self._load_existing_failures()
    
    def record_failure(self, image_info: dict, error_type: str, error_message: str, retry_count: int = 0):
        """
        记录图片处理失败
        
        :param image_info: 图片信息
        :param error_type: 错误类型
        :param error_message: 错误信息
        :param retry_count: 重试次数
        """
        failure_record = {
            'image_path': image_info.get('image_path', ''),
            'image_id': image_info.get('image_id', ''),
            'document_name': image_info.get('document_name', ''),
            'page_number': image_info.get('page_number', 1),
            'failure_type': error_type,
            'error_message': error_message,
            'retry_count': retry_count,
            'timestamp': int(time.time()),
            'can_retry_later': True,
            'status': 'failed'
        }
        
        self.failed_images.append(failure_record)
        
        # 实时保存失败报告
        self._save_failure_report()
        
        logger.warning(f"图片处理失败: {image_info.get('image_id', 'unknown')} - {error_message}")
    
    def get_failed_images(self, failure_type: str = None) -> list:
        """
        获取失败的图片列表
        
        :param failure_type: 错误类型过滤，如果为None则返回所有
        :return: 失败图片列表
        """
        if failure_type:
            return [img for img in self.failed_images if img['failure_type'] == failure_type]
        return self.failed_images.copy()
    
    def mark_as_retried(self, image_id: str, success: bool = True):
        """
        标记图片为重试状态
        
        :param image_id: 图片ID
        :param success: 是否重试成功
        """
        for img in self.failed_images:
            if img['image_id'] == image_id:
                if success:
                    img['status'] = 'retry_success'
                    img['retry_timestamp'] = int(time.time())
                else:
                    img['status'] = 'retry_failed'
                    img['retry_count'] += 1
                break
        
        self._save_failure_report()
    
    def generate_failure_report(self) -> dict:
        """
        生成失败报告
        
        :return: 失败报告字典
        """
        total_failures = len(self.failed_images)
        retry_success = len([img for img in self.failed_images if img['status'] == 'retry_success'])
        still_failed = len([img for img in self.failed_images if img['status'] == 'failed'])
        retry_failed = len([img for img in self.failed_images if img['status'] == 'retry_failed'])
        
        report = {
            'timestamp': int(time.time()),
            'summary': {
                'total_failures': total_failures,
                'retry_success': retry_success,
                'still_failed': still_failed,
                'retry_failed': retry_failed
            },
            'failed_images': self.failed_images
        }
        
        if self.failure_report_format == 'detailed':
            # 按错误类型分组
            error_groups = {}
            for img in self.failed_images:
                error_type = img['failure_type']
                if error_type not in error_groups:
                    error_groups[error_type] = []
                error_groups[error_type].append(img)
            
            report['error_analysis'] = error_groups
        
        return report
    
    def _load_existing_failures(self):
        """
        加载现有的失败报告
        """
        try:
            if os.path.exists(self.failure_report_path):
                with open(self.failure_report_path, 'r', encoding='utf-8') as f:
                    existing_data = json.load(f)
                    self.failed_images = existing_data.get('failed_images', [])
                    logger.info(f"加载现有失败报告，包含 {len(self.failed_images)} 条失败记录")
        except Exception as e:
            logger.warning(f"加载现有失败报告失败: {e}")
            self.failed_images = []
    
    def _save_failure_report(self):
        """
        保存失败报告到文件
        """
        try:
            report = self.generate_failure_report()
            with open(self.failure_report_path, 'w', encoding='utf-8') as f:
                json.dump(report, f, indent=2, ensure_ascii=False)
        except Exception as e:
            logger.error(f"保存失败报告失败: {e}")
    
    def clear_resolved_failures(self):
        """
        清理已解决的失败记录
        """
        self.failed_images = [img for img in self.failed_images if img['status'] == 'failed']
        self._save_failure_report()
        logger.info("已清理已解决的失败记录")
```

### 3. EnvironmentManager 环境变量管理器（Windows兼容）

```python
class EnvironmentManager:
    """
    环境变量管理器（Windows兼容）
    
    功能：
    - 管理所有环境变量
    - 提供环境变量读取接口
    - 支持Windows和Linux系统
    - 支持环境变量验证
    """
    
    def __init__(self):
        self.required_vars = [
            'DASHSCOPE_API_KEY',
            'MINERU_API_KEY'
        ]
        self.optional_vars = [
            'LOG_LEVEL',
            'VECTOR_DB_PATH'
        ]
    
    def get_dashscope_api_key(self) -> str:
        """
        获取通义千问API密钥
        
        :return: API密钥
        """
        return os.getenv('DASHSCOPE_API_KEY')
    
    def get_mineru_api_key(self) -> str:
        """
        获取MinerU API密钥
        
        :return: MinerU API密钥
        """
        return os.getenv('MINERU_API_KEY')
    
    def validate_environment(self) -> bool:
        """
        验证环境变量
        
        :return: 是否验证通过
        """
        missing_vars = []
        
        for var in self.required_vars:
            if not os.getenv(var):
                missing_vars.append(var)
        
        if missing_vars:
            logger.error(f"缺少必需的环境变量: {missing_vars}")
            logger.error("请设置以下环境变量:")
            for var in missing_vars:
                if var == 'DASHSCOPE_API_KEY':
                    logger.error(f"  {var}: 通义千问API密钥")
                elif var == 'MINERU_API_KEY':
                    logger.error(f"  {var}: MinerU API密钥")
            return False
        
        return True
    
    def get_environment_info(self) -> dict:
        """
        获取环境变量信息（用于调试）
        
        :return: 环境变量信息字典
        """
        info = {
            'system': platform.system(),
            'required_vars': {},
            'optional_vars': {}
        }
        
        for var in self.required_vars:
            value = os.getenv(var)
            info['required_vars'][var] = '已设置' if value else '未设置'
        
        for var in self.optional_vars:
            value = os.getenv(var)
            info['optional_vars'][var] = value if value else '未设置'
        
        return info
    
    def print_environment_setup_guide(self):
        """
        打印环境变量设置指南
        """
        system = platform.system()
        
        if system == "Windows":
            print("\n=== Windows环境变量设置指南 ===")
            print("方法1: 使用PowerShell设置（临时）")
            print("$env:DASHSCOPE_API_KEY='your_api_key_here'")
            print("$env:MINERU_API_KEY='your_mineru_key_here'")
            print("\n方法2: 使用命令提示符设置（临时）")
            print("set DASHSCOPE_API_KEY=your_api_key_here")
            print("set MINERU_API_KEY=your_mineru_key_here")
            print("\n方法3: 系统环境变量设置（永久）")
            print("1. 右键'此电脑' → 属性 → 高级系统设置")
            print("2. 环境变量 → 新建")
            print("3. 变量名: DASHSCOPE_API_KEY, 变量值: your_api_key_here")
            print("4. 变量名: MINERU_API_KEY, 变量值: your_mineru_key_here")
            
        elif system == "Linux" or system == "Darwin":
            print("\n=== Linux/macOS环境变量设置指南 ===")
            print("方法1: 临时设置")
            print("export DASHSCOPE_API_KEY='your_api_key_here'")
            print("export MINERU_API_KEY='your_mineru_key_here'")
            print("\n方法2: 永久设置（添加到 ~/.bashrc 或 ~/.zshrc）")
            print("echo 'export DASHSCOPE_API_KEY=your_api_key_here' >> ~/.bashrc")
            print("echo 'export MINERU_API_KEY=your_mineru_key_here' >> ~/.bashrc")
            print("source ~/.bashrc")
```

### 4. PathManager 路径管理器

```python
class PathManager:
    """
    路径管理器
    
    功能：
    - 管理所有文件路径
    - 验证路径的有效性
    - 创建必要的目录
    - 处理相对路径和绝对路径
    """
    
    def __init__(self):
        self.base_dir = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
    
    def validate_paths(self, paths_config: dict) -> bool:
        """
        验证路径配置
        
        :param paths_config: 路径配置字典
        :return: 是否验证通过
        """
        required_paths = [
            'input_pdf_dir',
            'mineru_output_dir', 
            'final_image_dir',
            'vector_db_dir'
        ]
        
        for path_key in required_paths:
            if path_key not in paths_config:
                logger.error(f"缺少必需的路径配置: {path_key}")
                return False
            
            path = paths_config[path_key]
            if not self._validate_single_path(path, path_key):
                return False
        
        return True
    
    def _validate_single_path(self, path: str, path_key: str) -> bool:
        """
        验证单个路径
        
        :param path: 路径字符串
        :param path_key: 路径键名
        :return: 是否有效
        """
        try:
            # 转换为绝对路径
            abs_path = self.get_absolute_path(path)
            
            # 检查路径是否为空
            if not path.strip():
                logger.error(f"路径配置为空: {path_key}")
                return False
            
            # 对于输入目录，检查是否存在
            if path_key == 'input_pdf_dir':
                if not os.path.exists(abs_path):
                    logger.warning(f"输入PDF目录不存在，将创建: {abs_path}")
                    os.makedirs(abs_path, exist_ok=True)
            
            # 对于输出目录，尝试创建
            elif path_key in ['mineru_output_dir', 'final_image_dir', 'vector_db_dir', 'temp_dir', 'logs_dir']:
                os.makedirs(abs_path, exist_ok=True)
                logger.info(f"确保目录存在: {abs_path}")
            
            return True
            
        except Exception as e:
            logger.error(f"路径验证失败 {path_key}: {path}, 错误: {e}")
            return False
    
    def get_absolute_path(self, relative_path: str) -> str:
        """
        将相对路径转换为绝对路径
        
        :param relative_path: 相对路径
        :return: 绝对路径
        """
        if os.path.isabs(relative_path):
            return relative_path
        else:
            return os.path.join(self.base_dir, relative_path)
    
    def create_temp_dir(self) -> str:
        """
        创建临时目录
        
        :return: 临时目录路径
        """
        temp_dir = os.path.join(self.base_dir, "temp", f"temp_{int(time.time())}")
        os.makedirs(temp_dir, exist_ok=True)
        return temp_dir
    
    def cleanup_temp_dirs(self, max_age_hours: int = 24):
        """
        清理过期的临时目录
        
        :param max_age_hours: 最大保留时间（小时）
        """
        temp_base = os.path.join(self.base_dir, "temp")
        if not os.path.exists(temp_base):
            return
        
        current_time = time.time()
        max_age_seconds = max_age_hours * 3600
        
        for item in os.listdir(temp_base):
            item_path = os.path.join(temp_base, item)
            if os.path.isdir(item_path) and item.startswith("temp_"):
                try:
                    item_age = current_time - os.path.getctime(item_path)
                    if item_age > max_age_seconds:
                        shutil.rmtree(item_path)
                        logger.info(f"清理过期临时目录: {item_path}")
                except Exception as e:
                    logger.warning(f"清理临时目录失败: {item_path}, 错误: {e}")
```

### 5. ConfigValidator 配置验证器

```python
class ConfigValidator:
    """
    配置验证器
    
    功能：
    - 验证配置的完整性和正确性
    - 提供详细的验证错误信息
    - 支持自定义验证规则
    """
    
    def __init__(self):
        self.validation_errors = []
    
    def validate(self, config: dict, schema: dict) -> bool:
        """
        验证配置
        
        :param config: 配置数据
        :param schema: 配置模式
        :return: 是否验证通过
        """
        self.validation_errors = []
        
        try:
            # 使用JSON Schema验证
            jsonschema.validate(config, schema)
            
            # 自定义验证规则
            self._validate_custom_rules(config)
            
            return len(self.validation_errors) == 0
            
        except jsonschema.ValidationError as e:
            self.validation_errors.append(f"JSON Schema验证失败: {e}")
            return False
    
    def _validate_custom_rules(self, config: dict):
        """
        自定义验证规则
        
        :param config: 配置数据
        """
        # 验证chunk_overlap不能大于chunk_size
        chunk_size = config.get('document_processing', {}).get('chunk_size', 0)
        chunk_overlap = config.get('document_processing', {}).get('chunk_overlap', 0)
        
        if chunk_overlap >= chunk_size:
            self.validation_errors.append(
                f"chunk_overlap ({chunk_overlap}) 不能大于或等于 chunk_size ({chunk_size})"
            )
        
        # 验证路径配置
        paths = config.get('paths', {})
        if paths:
            # 检查路径是否包含非法字符
            for key, path in paths.items():
                if path and ('<' in path or '>' in path or '|' in path):
                    self.validation_errors.append(
                        f"路径配置包含非法字符: {key} = {path}"
                    )
        
        # 验证API限流配置
        api_config = config.get('api_rate_limiting', {})
        if api_config:
            enhancement_batch = api_config.get('enhancement_batch_size', 0)
            vectorization_batch = api_config.get('vectorization_batch_size', 0)
            
            if enhancement_batch <= 0 or vectorization_batch <= 0:
                self.validation_errors.append(
                    "API批量大小必须大于0"
                )
    
    def get_validation_errors(self) -> list:
        """
        获取验证错误信息
        
        :return: 验证错误列表
        """
        return self.validation_errors
```

### 6. ConfigLoader 配置加载器

```python
class ConfigLoader:
    """
    配置加载器
    
    功能：
    - 加载配置文件
    - 支持多种文件格式
    - 提供配置备份和恢复功能
    """
    
    def __init__(self):
        self.supported_formats = ['.json', '.yaml', '.yml']
    
    def load_json(self, file_path: str) -> dict:
        """
        加载JSON配置文件
        
        :param file_path: 文件路径
        :return: 配置数据
        """
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                return json.load(f)
        except Exception as e:
            raise ConfigLoadError(f"加载配置文件失败: {e}")
    
    def save_json(self, file_path: str, data: dict):
        """
        保存配置到JSON文件
        
        :param file_path: 文件路径
        :param data: 配置数据
        """
        try:
            # 创建备份
            self._create_backup(file_path)
            
            # 保存新配置
            with open(file_path, 'w', encoding='utf-8') as f:
                json.dump(data, f, indent=2, ensure_ascii=False)
                
        except Exception as e:
            raise ConfigSaveError(f"保存配置文件失败: {e}")
    
    def _create_backup(self, file_path: str):
        """
        创建配置文件备份
        
        :param file_path: 原文件路径
        """
        if os.path.exists(file_path):
            backup_path = f"{file_path}.backup.{int(time.time())}"
            shutil.copy2(file_path, backup_path)
            logger.info(f"配置文件已备份到: {backup_path}")
```

## 🔄 配置管理流程

### 1. 配置加载流程

```
启动程序 → 检查配置文件 → 加载配置文件 → 验证配置 → 处理环境变量 → 验证路径 → 初始化失败处理器 → 配置就绪
```

### 2. 配置更新流程

```
用户修改配置 → 验证新配置 → 创建备份 → 保存新配置 → 通知相关模块 → 配置生效
```

### 3. 环境变量处理流程

```
加载配置文件 → 检查环境变量 → 验证必需变量 → 配置就绪
```

### 4. 失败处理流程

```
图片处理失败 → 记录失败信息 → 跳过失败图片 → 继续处理 → 生成失败报告 → 支持后续补做
```

## 📝 使用示例

### 1. 基本使用

```python
# 初始化配置管理器
config_manager = ConfigManager()

# 加载配置
if config_manager.load_config():
    # 获取配置值
    chunk_size = config_manager.get('document_processing.chunk_size', 1000)
    pdf_dir = config_manager.get_path('input_pdf_dir')
    
    # 获取失败处理器
    failure_handler = config_manager.get_failure_handler()
    
    print(f"Chunk size: {chunk_size}")
    print(f"PDF目录: {pdf_dir}")
else:
    print("配置加载失败")
```

### 2. 失败处理使用

```python
# 在图片处理过程中记录失败
try:
    # 处理图片
    enhanced_info = image_enhancer.enhance_image_description(image_path)
except Exception as e:
    # 记录失败
    failure_handler = config_manager.get_failure_handler()
    failure_handler.record_failure(
        image_info=img_info,
        error_type="enhancement_api_error",
        error_message=str(e),
        retry_count=3
    )
    # 跳过失败，继续处理下一张
    continue

# 获取失败图片列表，用于后续补做
failed_images = failure_handler.get_failed_images()
if failed_images:
    print(f"发现 {len(failed_images)} 张失败的图片，可以通过V502_image_enhancer_new.py补做")
```

### 3. 环境变量设置（Windows）

#### PowerShell（临时）
```powershell
$env:DASHSCOPE_API_KEY="your_api_key_here"
$env:MINERU_API_KEY="your_mineru_key_here"
```

#### 命令提示符（临时）
```cmd
set DASHSCOPE_API_KEY=your_api_key_here
set MINERU_API_KEY=your_mineru_key_here
```

#### 系统环境变量（永久）
1. 右键"此电脑" → 属性 → 高级系统设置
2. 环境变量 → 新建
3. 变量名: `DASHSCOPE_API_KEY`, 变量值: `your_api_key_here`
4. 变量名: `MINERU_API_KEY`, 变量值: `your_mineru_key_here`

### 4. 配置文件示例

```json
{
  "system": {
    "mode": "auto"
  },
  "paths": {
    "input_pdf_dir": "./document/orig_pdf",
    "mineru_output_dir": "./document/md",
    "final_image_dir": "./central/images",
    "vector_db_dir": "./central/vector_db"
  },
  "document_processing": {
    "chunk_size": 1200,
    "chunk_overlap": 300
  },
  "image_processing": {
    "enable_enhancement": true,
    "enhancement_model": "qwen-vl-plus"
  },
  "api_rate_limiting": {
    "enhancement_batch_size": 5,
    "enhancement_delay_seconds": 2,
    "vectorization_batch_size": 10,
    "vectorization_delay_seconds": 1
  },
  "failure_handling": {
    "skip_failed_images": true,
    "generate_failure_report": true,
    "mark_for_later_processing": true
  }
}
```

## �� 扩展性设计

### 1. 路径配置扩展
- 支持新增文件类型目录
- 支持自定义输出目录结构
- 支持多环境路径配置

### 2. 模型配置扩展
- 支持新增向量化模型
- 支持新增图片增强模型
- 支持模型参数配置

### 3. 配置版本管理
- 支持配置版本升级
- 支持配置向后兼容
- 支持配置迁移工具

### 4. 失败处理扩展
- 支持新增失败类型
- 支持自定义失败处理策略
- 支持失败处理插件

## 安全性设计

### 1. 敏感信息保护
- API密钥等敏感信息通过环境变量管理
- 配置文件不包含敏感信息
- 支持配置加密存储

### 2. 路径安全
- 路径验证，防止路径遍历攻击
- 路径权限检查
- 临时文件安全清理

### 3. 失败信息安全
- 失败报告不包含敏感信息
- 失败日志安全存储
- 失败信息访问控制

## 性能优化

### 1. 配置缓存
- 配置加载后缓存在内存中
- 支持配置热更新
- 减少文件I/O操作

### 2. 路径缓存
- 绝对路径计算结果缓存
- 目录存在性检查缓存
- 减少文件系统访问

### 3. 失败处理优化
- 失败记录批量写入
- 失败报告增量更新
- 失败信息索引优化

## 测试策略

### 1. 单元测试
- 配置加载测试
- 配置验证测试
- 环境变量处理测试
- 路径管理测试
- 失败处理测试

### 2. 集成测试
- 配置管理流程测试
- 配置更新流程测试
- 失败处理流程测试
- 错误处理测试

### 3. 跨平台测试
- Windows环境测试
- Linux环境测试
- macOS环境测试

### 4. 失败处理测试
- 失败记录测试
- 失败报告生成测试
- 失败恢复测试
- 与V502_image_enhancer_new.py集成测试

---

这就是完整的配置管理系统详细设计文档。现在包含了所有必要的配置参数，特别是：

1. **文件路径配置**：PDF输入、MinerU输出、图片存储、向量数据库等
2. **模型选择配置**：图片增强模型、向量化模型等
3. **API限流配置**：批量处理、延迟控制、重试机制等
4. **失败处理配置**：跳过失败、生成报告、支持后续补做等
5. **Windows兼容性**：环境变量设置指南等

这个设计完全支持你提到的"跳过失败，但可以让后面的专门处理增强图片的程序补做"的需求，与V502_image_enhancer_new.py完美配合。