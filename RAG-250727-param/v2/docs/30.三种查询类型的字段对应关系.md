您说得对！我应该全面列出三种查询类型的字段对应关系。让我完整地整理一下：

## 三种查询类型的完整字段对应关系

### 1. **Image查询的字段对应关系**

| 前端字段 | 后端字段 | 数据库字段 | 数据类型 | 说明 |
|----------|----------|------------|----------|------|
| `document_name` | `document_name` | `document_name` | string | 文档名称 |
| `page_number` | `page_number` | `page_number` | int | 页码 |
| `chunk_type` | `chunk_type` | `chunk_type` | string | 内容类型 |
| `caption` | `caption` | `img_caption` | list[string] | 图片标题 |
| `footnote` | `footnote` | `img_footnote` | list[string] | 图片脚注 |
| `enhanced_description` | `enhanced_description` | `enhanced_description` | string | 增强描述 |
| `image_id` | `image_id` | `image_id` | string | 图片ID |
| `image_path` | `image_path` | `image_path` | string | 图片路径 |
| `image_filename` | `image_filename` | `image_filename` | string | 图片文件名 |
| `image_type` | `image_type` | `image_type` | string | 图片类型 |
| `extension` | `extension` | `extension` | string | 文件扩展名 |
| `semantic_features` | `semantic_features` | `semantic_features` | dict | 语义特征 |
| `enhancement_enabled` | `enhancement_enabled` | `enhancement_enabled` | bool | 增强启用状态 |
| `enhancement_timestamp` | `enhancement_timestamp` | `enhancement_timestamp` | string | 增强时间戳 |

### 2. **Table查询的字段对应关系**

| 前端字段 | 后端字段 | 数据库字段 | 数据类型 | 说明 |
|----------|----------|------------|----------|------|
| `document_name` | `document_name` | `document_name` | string | 文档名称 |
| `page_number` | `page_number` | `page_number` | int | 页码 |
| `chunk_type` | `chunk_type` | `chunk_type` | string | 内容类型 |
| `table_id` | `table_id` | `table_id` | string | 表格ID |
| `table_type` | `table_type` | `table_type` | string | 表格类型 |
| `table_title` | `table_title` | `table_title` | string | 表格标题 |
| `table_summary` | `table_summary` | `table_summary` | string | 表格摘要 |
| `table_headers` | `table_headers` | `table_headers` | list[string] | 表格表头 |
| `table_row_count` | `table_row_count` | `table_row_count` | int | 表格行数 |
| `table_column_count` | `table_column_count` | `table_column_count` | int | 表格列数 |
| `html_content` | `html_content` | `page_content` | string | HTML格式内容 |
| `processed_content` | `processed_content` | `processed_table_content` | string | 语义化内容 |
| `related_text` | `related_text` | `related_text` | string | 相关文本 |
| `chunk_index` | `chunk_index` | `chunk_index` | int | 分块索引 |

### 3. **Text查询的字段对应关系**

| 前端字段 | 后端字段 | 数据库字段 | 数据类型 | 说明 |
|----------|----------|------------|----------|------|
| `document_name` | `document_name` | `document_name` | string | 文档名称 |
| `page_number` | `page_number` | `page_number` | int | 页码 |
| `chunk_type` | `chunk_type` | `chunk_type` | string | 内容类型 |
| `content` | `content` | `page_content` | string | 文本内容 |
| `content_preview` | `content_preview` | `page_content` | string | 内容预览 |
| `chunk_index` | `chunk_index` | `chunk_index` | int | 分块索引 |

### 4. **通用字段对应关系**

| 前端字段 | 后端字段 | 数据库字段 | 数据类型 | 说明 |
|----------|----------|------------|----------|------|
| `document_name` | `document_name` | `document_name` | string | 文档名称 |
| `page_number` | `page_number` | `page_number` | int | 页码 |
| `chunk_type` | `chunk_type` | `chunk_type` | string | 内容类型 |

### 5. **完整的后端字段提取逻辑**

#### 5.1 **明确的字段提取函数**
```python
def _extract_sources(self, retrieved_docs: List[Any]) -> List[Dict[str, Any]]:
    """提取来源信息 - 明确的字段对应关系"""
    
    sources = []
    
    for doc in retrieved_docs:
        source_info = {}
        
        if hasattr(doc, 'metadata') and doc.metadata:
            doc_metadata = doc.metadata
            
            # 1. 通用字段 - 直接对应
            source_info.update({
                'document_name': doc_metadata.get('document_name', '未知文档'),
                'page_number': doc_metadata.get('page_number', '未知页'),
                'chunk_type': doc_metadata.get('chunk_type', '未知类型')
            })
            
            # 2. 根据chunk_type提取特定字段
            chunk_type = doc_metadata.get('chunk_type', '')
            
            if chunk_type == 'image':
                # 图片字段 - 明确的对应关系
                source_info.update({
                    'caption': doc_metadata.get('img_caption', []),           # 从img_caption获取
                    'footnote': doc_metadata.get('img_footnote', []),         # 从img_footnote获取
                    'enhanced_description': doc_metadata.get('enhanced_description', ''),  # 从enhanced_description获取
                    'image_id': doc_metadata.get('image_id', ''),             # 从image_id获取
                    'image_path': doc_metadata.get('image_path', ''),         # 从image_path获取
                    'image_filename': doc_metadata.get('image_filename', ''), # 从image_filename获取
                    'image_type': doc_metadata.get('image_type', ''),         # 从image_type获取
                    'extension': doc_metadata.get('extension', ''),           # 从extension获取
                    'semantic_features': doc_metadata.get('semantic_features', {}),  # 从semantic_features获取
                    'enhancement_enabled': doc_metadata.get('enhancement_enabled', False),  # 从enhancement_enabled获取
                    'enhancement_timestamp': doc_metadata.get('enhancement_timestamp', ''),  # 从enhancement_timestamp获取
                })
                
            elif chunk_type == 'table':
                # 表格字段 - 明确的对应关系
                source_info.update({
                    'table_id': doc_metadata.get('table_id', ''),             # 从table_id获取
                    'table_type': doc_metadata.get('table_type', ''),         # 从table_type获取
                    'table_title': doc_metadata.get('table_title', ''),       # 从table_title获取
                    'table_summary': doc_metadata.get('table_summary', ''),   # 从table_summary获取
                    'table_headers': doc_metadata.get('table_headers', []),   # 从table_headers获取
                    'table_row_count': doc_metadata.get('table_row_count', 0), # 从table_row_count获取
                    'table_column_count': doc_metadata.get('table_column_count', 0), # 从table_column_count获取
                    'html_content': doc_metadata.get('page_content', ''),     # 从page_content获取（HTML格式）
                    'processed_content': doc_metadata.get('processed_table_content', ''), # 从processed_table_content获取
                    'related_text': doc_metadata.get('related_text', ''),     # 从related_text获取
                    'chunk_index': doc_metadata.get('chunk_index', 0),        # 从chunk_index获取
                })
                
            elif chunk_type == 'text':
                # 文本字段 - 明确的对应关系
                source_info.update({
                    'content': doc.page_content,                              # 从page_content获取
                    'content_preview': doc.page_content[:200] + '...' if len(doc.page_content) > 200 else doc.page_content,
                    'chunk_index': doc_metadata.get('chunk_index', 0),        # 从chunk_index获取
                })
        
        sources.append(source_info)
    
    return sources
```

### 6. **前端字段使用示例**

#### 6.1 **图片查询结果处理**
```javascript
function processImageResults(imageResults) {
    return imageResults.map(result => ({
        // 基础信息
        documentName: result.document_name,
        pageNumber: result.page_number,
        chunkType: result.chunk_type,
        
        // 图片信息（明确对应）
        title: result.caption?.[0] || '无标题',           // 从caption字段获取
        footnote: result.footnote?.join(', ') || '',      // 从footnote字段获取
        description: result.enhanced_description || '',    // 从enhanced_description字段获取
        imageId: result.image_id || '',                   // 从image_id字段获取
        imagePath: result.image_path || '',               // 从image_path字段获取
        imageFilename: result.image_filename || '',        // 从image_filename字段获取
        imageType: result.image_type || '',               // 从image_type字段获取
        extension: result.extension || '',                // 从extension字段获取
        semanticFeatures: result.semantic_features || {}, // 从semantic_features字段获取
        enhancementEnabled: result.enhancement_enabled || false, // 从enhancement_enabled字段获取
        enhancementTimestamp: result.enhancement_timestamp || '' // 从enhancement_timestamp字段获取
    }));
}
```

#### 6.2 **表格查询结果处理**
```javascript
function processTableResults(tableResults) {
    return tableResults.map(result => ({
        // 基础信息
        documentName: result.document_name,
        pageNumber: result.page_number,
        chunkType: result.chunk_type,
        
        // 表格信息（明确对应）
        tableId: result.table_id || '',                   // 从table_id字段获取
        tableType: result.table_type || '',               // 从table_type字段获取
        tableTitle: result.table_title || '',             // 从table_title字段获取
        tableSummary: result.table_summary || '',         // 从table_summary字段获取
        tableHeaders: result.table_headers || [],         // 从table_headers字段获取
        rowCount: result.table_row_count || 0,            // 从table_row_count字段获取
        columnCount: result.table_column_count || 0,      // 从table_column_count字段获取
        htmlContent: result.html_content || '',           // 从html_content字段获取
        processedContent: result.processed_content || '', // 从processed_content字段获取
        relatedText: result.related_text || '',           // 从related_text字段获取
        chunkIndex: result.chunk_index || 0               // 从chunk_index字段获取
    }));
}
```

#### 6.3 **文本查询结果处理**
```javascript
function processTextResults(textResults) {
    return textResults.map(result => ({
        // 基础信息
        documentName: result.document_name,
        pageNumber: result.page_number,
        chunkType: result.chunk_type,
        
        // 文本信息（明确对应）
        content: result.content || '',                    // 从content字段获取
        contentPreview: result.content_preview || '',     // 从content_preview字段获取
        chunkIndex: result.chunk_index || 0               // 从chunk_index字段获取
    }));
}
```

### 7. **字段对应关系总结**

**核心原则**：
1. **一一对应**：每个前端字段都有明确的后端字段和数据库字段对应
2. **不猜测**：不使用猜测或备选字段名
3. **类型一致**：确保字段类型的一致性
4. **可追溯**：建立清晰的字段映射关系

**三种查询类型的字段结构**：
- **Image查询**：包含图片特有的字段（caption、footnote、image_id等）
- **Table查询**：包含表格特有的字段（table_id、table_headers、html_content等）
- **Text查询**：包含文本特有的字段（content、content_preview等）

**通用字段**：所有类型都包含的基础字段（document_name、page_number、chunk_type）

这样的设计确保了前后端数据的一致性和可维护性，避免了字段对应错误的问题。