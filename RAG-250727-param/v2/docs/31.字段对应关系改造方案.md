å¥½çš„ï¼Œè®©æˆ‘ä»”ç»†æ£€æŸ¥è¿™äº›ç¨‹åºï¼Œç„¶åå†™ä¸€ä¸ªè¯¦ç»†çš„å¯è¡Œæ”¹é€ æ–¹æ¡ˆã€‚è®©æˆ‘é€ä¸€æ·±å…¥åˆ†æï¼š

## ç¨‹åºæ·±å…¥æ£€æŸ¥

### 1. **v2/core/unified_pipeline.py è¯¦ç»†æ£€æŸ¥**

Read file: v2/core/unified_pipeline.py
Read file: v2/core/unified_pipeline.py
Read file: v2/core/unified_pipeline.py
ç°åœ¨è®©æˆ‘æ£€æŸ¥å…¶ä»–å…³é”®æ–‡ä»¶ï¼š

Ran tool
Ran tool
Ran tool
åŸºäºæˆ‘çš„æ·±å…¥æ£€æŸ¥ï¼Œç°åœ¨æˆ‘æ¥å†™ä¸€ä¸ªè¯¦ç»†çš„å¯è¡Œæ”¹é€ æ–¹æ¡ˆï¼š

# å­—æ®µå¯¹åº”å…³ç³»æ”¹é€ è¯¦ç»†æ–¹æ¡ˆ

## ä¸€ã€ç°çŠ¶åˆ†æ

### 1.1 **æ ¸å¿ƒé—®é¢˜è¯†åˆ«**

#### 1.1.1 **å­—æ®µæ˜ å°„ä¸ä¸€è‡´**
- **æ•°æ®åº“å­—æ®µ**ï¼š`img_caption`ï¼ˆå›¾ç‰‡æ ‡é¢˜ï¼‰
- **åç«¯å­—æ®µ**ï¼š`caption`ï¼ˆå›¾ç‰‡æ ‡é¢˜ï¼‰
- **å‰ç«¯å­—æ®µ**ï¼š`caption`ï¼ˆå›¾ç‰‡æ ‡é¢˜ï¼‰
- **é—®é¢˜**ï¼šåç«¯åœ¨æå–æ—¶æ²¡æœ‰æ­£ç¡®æ˜ å°„`img_caption`åˆ°`caption`

#### 1.1.2 **å­—æ®µæå–é€»è¾‘æ··ä¹±**
- ä½¿ç”¨çŒœæµ‹å¼å­—æ®µæå–ï¼ˆ`for caption_field in ['img_caption', 'caption', 'title', 'image_title', 'description']`ï¼‰
- å­—æ®µä¼˜å…ˆçº§ä¸æ˜ç¡®
- ç¼ºä¹ç»Ÿä¸€çš„å­—æ®µå¯¹åº”å…³ç³»

#### 1.1.3 **æ•°æ®ç»“æ„ä¸ä¸€è‡´**
- ä¸‰ä¸ªå¼•æ“è¿”å›ä¸åŒçš„å­—æ®µç»“æ„
- APIå“åº”ä¸­çš„å­—æ®µåä¸æ•°æ®åº“ä¸ä¸€è‡´
- å‰ç«¯æœŸæœ›çš„å­—æ®µåä¸åç«¯ä¸ä¸€è‡´

### 1.2 **å½±å“èŒƒå›´**
- **å›¾ç‰‡æŸ¥è¯¢**ï¼šæ˜¾ç¤º"æ— æ ‡é¢˜"é—®é¢˜
- **è¡¨æ ¼æŸ¥è¯¢**ï¼šå­—æ®µæ˜ å°„æ··ä¹±
- **æ–‡æœ¬æŸ¥è¯¢**ï¼šå­—æ®µåä¸ä¸€è‡´
- **æ··åˆæŸ¥è¯¢**ï¼šç»“æœå±•ç¤ºä¸ç»Ÿä¸€

## äºŒã€æ”¹é€ ç›®æ ‡

### 2.1 **ä¸»è¦ç›®æ ‡**
1. å»ºç«‹æ˜ç¡®çš„å­—æ®µå¯¹åº”å…³ç³»
2. ç»Ÿä¸€ä¸‰ä¸ªå¼•æ“çš„å­—æ®µç»“æ„
3. ç¡®ä¿APIå“åº”çš„å­—æ®µä¸€è‡´æ€§
4. è§£å†³å‰ç«¯æ˜¾ç¤ºé—®é¢˜

### 2.2 **å…·ä½“ç›®æ ‡**
- å›¾ç‰‡æŸ¥è¯¢ï¼šæ­£ç¡®æ˜¾ç¤ºå›¾ç‰‡æ ‡é¢˜
- è¡¨æ ¼æŸ¥è¯¢ï¼šå­—æ®µæ˜ å°„æ¸…æ™°
- æ–‡æœ¬æŸ¥è¯¢ï¼šå­—æ®µåç»Ÿä¸€
- æ··åˆæŸ¥è¯¢ï¼šç»“æœå±•ç¤ºä¸€è‡´

## ä¸‰ã€æ”¹é€ æ–¹æ¡ˆ

### 3.1 **é˜¶æ®µ1ï¼šæ ¸å¿ƒå­—æ®µå¯¹åº”å…³ç³»å»ºç«‹**

#### 3.1.1 **å­—æ®µæ˜ å°„è¡¨è®¾è®¡**
```python
# æ˜ç¡®çš„å­—æ®µå¯¹åº”å…³ç³»è¡¨
FIELD_MAPPING = {
    # é€šç”¨å­—æ®µ
    'document_name': 'document_name',      # æ–‡æ¡£åç§°
    'page_number': 'page_number',          # é¡µç 
    'chunk_type': 'chunk_type',            # å†…å®¹ç±»å‹
    
    # å›¾ç‰‡å­—æ®µ
    'caption': 'img_caption',              # å›¾ç‰‡æ ‡é¢˜ï¼ˆä»img_captionè·å–ï¼‰
    'footnote': 'img_footnote',            # å›¾ç‰‡è„šæ³¨ï¼ˆä»img_footnoteè·å–ï¼‰
    'enhanced_description': 'enhanced_description',  # å¢å¼ºæè¿°
    'image_id': 'image_id',                # å›¾ç‰‡ID
    'image_path': 'image_path',            # å›¾ç‰‡è·¯å¾„
    'image_filename': 'image_filename',    # å›¾ç‰‡æ–‡ä»¶å
    'image_type': 'image_type',            # å›¾ç‰‡ç±»å‹
    'extension': 'extension',              # æ–‡ä»¶æ‰©å±•å
    
    # è¡¨æ ¼å­—æ®µ
    'table_id': 'table_id',                # è¡¨æ ¼ID
    'table_type': 'table_type',            # è¡¨æ ¼ç±»å‹
    'table_title': 'table_title',          # è¡¨æ ¼æ ‡é¢˜
    'table_summary': 'table_summary',      # è¡¨æ ¼æ‘˜è¦
    'table_headers': 'table_headers',      # è¡¨æ ¼è¡¨å¤´
    'table_row_count': 'table_row_count',  # è¡¨æ ¼è¡Œæ•°
    'table_column_count': 'table_column_count',  # è¡¨æ ¼åˆ—æ•°
    'html_content': 'page_content',        # HTMLæ ¼å¼å†…å®¹
    'processed_content': 'processed_table_content',  # è¯­ä¹‰åŒ–å†…å®¹
    
    # æ–‡æœ¬å­—æ®µ
    'content': 'page_content',             # æ–‡æœ¬å†…å®¹
    'content_preview': 'page_content',     # å†…å®¹é¢„è§ˆ
    'chunk_index': 'chunk_index'           # åˆ†å—ç´¢å¼•
}
```

#### 3.1.2 **unified_pipeline.py é‡æ„**
```python
class UnifiedPipeline:
    def __init__(self, config: Dict[str, Any], llm_engine, source_filter_engine):
        # ... ç°æœ‰åˆå§‹åŒ–ä»£ç  ...
        
        # æ–°å¢ï¼šå­—æ®µæ˜ å°„é…ç½®
        self.field_mapping = FIELD_MAPPING
    
    def _extract_sources(self, retrieved_docs: List[Any]) -> List[Dict[str, Any]]:
        """æå–æ¥æºä¿¡æ¯ - æ˜ç¡®çš„å­—æ®µå¯¹åº”å…³ç³»"""
        sources = []
        
        for doc in retrieved_docs:
            source_info = {}
            
            if hasattr(doc, 'metadata') and doc.metadata:
                doc_metadata = doc.metadata
                
                # 1. é€šç”¨å­—æ®µ - ç›´æ¥å¯¹åº”
                source_info.update({
                    'document_name': doc_metadata.get('document_name', 'æœªçŸ¥æ–‡æ¡£'),
                    'page_number': doc_metadata.get('page_number', 'æœªçŸ¥é¡µ'),
                    'chunk_type': doc_metadata.get('chunk_type', 'æœªçŸ¥ç±»å‹')
                })
                
                # 2. æ ¹æ®chunk_typeæå–ç‰¹å®šå­—æ®µ
                chunk_type = doc_metadata.get('chunk_type', '')
                
                if chunk_type == 'image':
                    source_info.update(self._extract_image_fields(doc_metadata))
                elif chunk_type == 'table':
                    source_info.update(self._extract_table_fields(doc_metadata))
                elif chunk_type == 'text':
                    source_info.update(self._extract_text_fields(doc, doc_metadata))
            
            sources.append(source_info)
        
        return sources
    
    def _extract_image_fields(self, doc_metadata: Dict[str, Any]) -> Dict[str, Any]:
        """æå–å›¾ç‰‡å­—æ®µ - æ˜ç¡®çš„å¯¹åº”å…³ç³»"""
        return {
            'caption': doc_metadata.get('img_caption', []),           # æ˜ç¡®ä»img_captionè·å–
            'footnote': doc_metadata.get('img_footnote', []),         # æ˜ç¡®ä»img_footnoteè·å–
            'enhanced_description': doc_metadata.get('enhanced_description', ''),  # æ˜ç¡®ä»enhanced_descriptionè·å–
            'image_id': doc_metadata.get('image_id', ''),             # æ˜ç¡®ä»image_idè·å–
            'image_path': doc_metadata.get('image_path', ''),         # æ˜ç¡®ä»image_pathè·å–
            'image_filename': doc_metadata.get('image_filename', ''), # æ˜ç¡®ä»image_filenameè·å–
            'image_type': doc_metadata.get('image_type', ''),         # æ˜ç¡®ä»image_typeè·å–
            'extension': doc_metadata.get('extension', ''),           # æ˜ç¡®ä»extensionè·å–
            'semantic_features': doc_metadata.get('semantic_features', {}),  # æ˜ç¡®ä»semantic_featuresè·å–
            'enhancement_enabled': doc_metadata.get('enhancement_enabled', False),  # æ˜ç¡®ä»enhancement_enabledè·å–
            'enhancement_timestamp': doc_metadata.get('enhancement_timestamp', '')  # æ˜ç¡®ä»enhancement_timestampè·å–
        }
    
    def _extract_table_fields(self, doc_metadata: Dict[str, Any]) -> Dict[str, Any]:
        """æå–è¡¨æ ¼å­—æ®µ - æ˜ç¡®çš„å¯¹åº”å…³ç³»"""
        return {
            'table_id': doc_metadata.get('table_id', ''),             # æ˜ç¡®ä»table_idè·å–
            'table_type': doc_metadata.get('table_type', ''),         # æ˜ç¡®ä»table_typeè·å–
            'table_title': doc_metadata.get('table_title', ''),       # æ˜ç¡®ä»table_titleè·å–
            'table_summary': doc_metadata.get('table_summary', ''),   # æ˜ç¡®ä»table_summaryè·å–
            'table_headers': doc_metadata.get('table_headers', []),   # æ˜ç¡®ä»table_headersè·å–
            'table_row_count': doc_metadata.get('table_row_count', 0), # æ˜ç¡®ä»table_row_countè·å–
            'table_column_count': doc_metadata.get('table_column_count', 0), # æ˜ç¡®ä»table_column_countè·å–
            'html_content': doc_metadata.get('page_content', ''),     # æ˜ç¡®ä»page_contentè·å–ï¼ˆHTMLæ ¼å¼ï¼‰
            'processed_content': doc_metadata.get('processed_table_content', ''), # æ˜ç¡®ä»processed_table_contentè·å–
            'related_text': doc_metadata.get('related_text', ''),     # æ˜ç¡®ä»related_textè·å–
            'chunk_index': doc_metadata.get('chunk_index', 0)        # æ˜ç¡®ä»chunk_indexè·å–
        }
    
    def _extract_text_fields(self, doc, doc_metadata: Dict[str, Any]) -> Dict[str, Any]:
        """æå–æ–‡æœ¬å­—æ®µ - æ˜ç¡®çš„å¯¹åº”å…³ç³»"""
        return {
            'content': doc.page_content,                              # æ˜ç¡®ä»page_contentè·å–
            'content_preview': doc.page_content[:200] + '...' if len(doc.page_content) > 200 else doc.page_content,
            'chunk_index': doc_metadata.get('chunk_index', 0)        # æ˜ç¡®ä»chunk_indexè·å–
        }
```

### 3.2 **é˜¶æ®µ2ï¼šä¸‰ä¸ªå¼•æ“å­—æ®µæ˜ å°„ç»Ÿä¸€**

#### 3.2.1 **image_engine.py ä¿®æ”¹**
```python
class ImageEngine:
    def _enhance_reranked_results(self, reranked_results: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """å¢å¼ºreranked_resultsï¼šä½¿ç”¨æ˜ç¡®çš„å­—æ®µæ˜ å°„"""
        enhanced_results = []
        
        for result in reranked_results:
            if isinstance(result, dict) and 'doc' in result:
                enhanced_result = result.copy()
                
                doc = result['doc']
                if hasattr(doc, 'metadata') and doc.metadata:
                    metadata = doc.metadata
                    
                    # ä½¿ç”¨æ˜ç¡®çš„å­—æ®µæ˜ å°„
                    enhanced_result.update({
                        'document_name': metadata.get('document_name', 'æœªçŸ¥æ–‡æ¡£'),
                        'page_number': metadata.get('page_number', 'æœªçŸ¥é¡µ'),
                        'chunk_type': metadata.get('chunk_type', 'å›¾ç‰‡'),
                        'image_path': metadata.get('image_path', ''),
                        'caption': metadata.get('img_caption', []),           # æ˜ç¡®ä»img_captionè·å–
                        'enhanced_description': metadata.get('enhanced_description', ''),
                        'image_id': metadata.get('image_id', ''),
                        'image_filename': metadata.get('image_filename', ''),
                        'image_type': metadata.get('image_type', ''),
                        'extension': metadata.get('extension', ''),
                        'semantic_features': metadata.get('semantic_features', {}),
                        'enhancement_enabled': metadata.get('enhancement_enabled', False),
                        'enhancement_timestamp': metadata.get('enhancement_timestamp', '')
                    })
                
                enhanced_results.append(enhanced_result)
        
        return enhanced_results
```

#### 3.2.2 **table_engine.py ä¿®æ”¹**
```python
class TableEngine:
    def _format_table_results(self, search_results: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """æ ¼å¼åŒ–è¡¨æ ¼ç»“æœï¼šä½¿ç”¨æ˜ç¡®çš„å­—æ®µæ˜ å°„"""
        formatted_results = []
        
        for result in search_results:
            if isinstance(result, dict) and 'doc' in result:
                doc = result['doc']
                metadata = doc.metadata if hasattr(doc, 'metadata') else {}
                
                # ä½¿ç”¨æ˜ç¡®çš„å­—æ®µæ˜ å°„
                formatted_result = {
                    'id': metadata.get('table_id', 'unknown'),
                    'table_type': metadata.get('table_type', 'æ•°æ®è¡¨æ ¼'),
                    'table_title': metadata.get('table_title', ''),
                    'table_summary': metadata.get('table_summary', ''),
                    'table_headers': metadata.get('table_headers', []),
                    'table_row_count': metadata.get('table_row_count', 0),
                    'table_column_count': metadata.get('table_column_count', 0),
                    'html_content': metadata.get('page_content', ''),     # æ˜ç¡®ä»page_contentè·å–
                    'processed_content': metadata.get('processed_table_content', ''), # æ˜ç¡®ä»processed_table_contentè·å–
                    'related_text': metadata.get('related_text', ''),
                    'chunk_index': metadata.get('chunk_index', 0),
                    'document_name': metadata.get('document_name', 'æœªçŸ¥æ–‡æ¡£'),
                    'page_number': metadata.get('page_number', 'æœªçŸ¥é¡µ'),
                    'chunk_type': 'table',
                    'score': result.get('score', 0.0)
                }
                
                formatted_results.append(formatted_result)
        
        return formatted_results
```

#### 3.2.3 **text_engine.py ä¿®æ”¹**
```python
class TextEngine:
    def _process_text_result(self, doc, query: str) -> Dict[str, Any]:
        """å¤„ç†æ–‡æœ¬ç»“æœï¼šä½¿ç”¨æ˜ç¡®çš„å­—æ®µæ˜ å°„"""
        metadata = doc.metadata if hasattr(doc, 'metadata') else {}
        
        return {
            'content': doc.page_content,                              # æ˜ç¡®ä»page_contentè·å–
            'content_preview': doc.page_content[:200] + '...' if len(doc.page_content) > 200 else doc.page_content,
            'chunk_index': metadata.get('chunk_index', 0),            # æ˜ç¡®ä»chunk_indexè·å–
            'document_name': metadata.get('document_name', 'æœªçŸ¥æ–‡æ¡£'),
            'page_number': metadata.get('page_number', 'æœªçŸ¥é¡µ'),
            'chunk_type': metadata.get('chunk_type', 'text'),
            'score': 0.0
        }
```

### 3.3 **é˜¶æ®µ3ï¼šAPIè·¯ç”±å­—æ®µç»Ÿä¸€**

#### 3.3.1 **v2_routes.py ä¿®æ”¹**
```python
# åœ¨APIè·¯ç”±ä¸­ä½¿ç”¨ç»Ÿä¸€çš„å­—æ®µå
def _build_image_result(actual_doc, score: float) -> Dict[str, Any]:
    """æ„å»ºå›¾ç‰‡ç»“æœï¼šä½¿ç”¨ç»Ÿä¸€çš„å­—æ®µå"""
    metadata = actual_doc.metadata if hasattr(actual_doc, 'metadata') else {}
    
    return {
        'image_path': metadata.get('image_path', ''),
        'caption': metadata.get('img_caption', ['æ— æ ‡é¢˜']),           # æ˜ç¡®ä»img_captionè·å–
        'enhanced_description': metadata.get('enhanced_description', ''),
        'document_name': metadata.get('document_name', 'æœªçŸ¥æ–‡æ¡£'),
        'page_number': metadata.get('page_number', 'N/A'),
        'chunk_type': metadata.get('chunk_type', ''),
        'llm_context': metadata.get('llm_context', 'N/A'),
        'formatted_source': metadata.get('formatted_source', 'N/A'),
        'score': score,
        'doc_id': metadata.get('image_id', ''),                      # æ˜ç¡®ä»image_idè·å–
        'image_id': metadata.get('image_id', ''),                    # æ–°å¢ï¼šæ˜ç¡®å­—æ®µ
        'image_filename': metadata.get('image_filename', ''),        # æ–°å¢ï¼šæ˜ç¡®å­—æ®µ
        'image_type': metadata.get('image_type', ''),                # æ–°å¢ï¼šæ˜ç¡®å­—æ®µ
        'extension': metadata.get('extension', '')                   # æ–°å¢ï¼šæ˜ç¡®å­—æ®µ
    }

def _build_table_result(actual_doc, score: float) -> Dict[str, Any]:
    """æ„å»ºè¡¨æ ¼ç»“æœï¼šä½¿ç”¨ç»Ÿä¸€çš„å­—æ®µå"""
    metadata = actual_doc.metadata if hasattr(actual_doc, 'metadata') else {}
    
    return {
        'id': metadata.get('table_id', 'unknown'),
        'table_type': metadata.get('table_type', 'æ•°æ®è¡¨æ ¼'),
        'table_title': metadata.get('table_title', ''),
        'table_html': metadata.get('page_content', ''),              # æ˜ç¡®ä»page_contentè·å–
        'table_content': metadata.get('processed_table_content', ''), # æ˜ç¡®ä»processed_table_contentè·å–
        'document_name': metadata.get('document_name', 'æœªçŸ¥æ–‡æ¡£'),
        'page_number': metadata.get('page_number', 'N/A'),
        'score': score,
        'chunk_type': 'table',
        'table_headers': metadata.get('table_headers', []),
        'table_row_count': metadata.get('table_row_count', 0),
        'table_column_count': metadata.get('table_column_count', 0), # ç»Ÿä¸€å­—æ®µå
        'table_summary': metadata.get('table_summary', ''),
        'chunk_index': metadata.get('chunk_index', 0)                # æ–°å¢ï¼šæ˜ç¡®å­—æ®µ
    }
```

### 3.4 **é˜¶æ®µ4ï¼šå‰ç«¯å­—æ®µå¤„ç†ç»Ÿä¸€**

#### 3.4.1 **v2_index.html ä¿®æ”¹**
```javascript
// ç»Ÿä¸€çš„å­—æ®µå¤„ç†å‡½æ•°
function processImageResults(imageResults) {
    return imageResults.map(result => ({
        // åŸºç¡€ä¿¡æ¯
        documentName: result.document_name,
        pageNumber: result.page_number,
        chunkType: result.chunk_type,
        
        // å›¾ç‰‡ä¿¡æ¯ï¼ˆæ˜ç¡®å¯¹åº”ï¼‰
        title: result.caption?.[0] || 'æ— æ ‡é¢˜',           // ä»captionå­—æ®µè·å–
        footnote: result.footnote?.join(', ') || '',      // ä»footnoteå­—æ®µè·å–
        description: result.enhanced_description || '',    // ä»enhanced_descriptionå­—æ®µè·å–
        imageId: result.image_id || '',                   // ä»image_idå­—æ®µè·å–
        imagePath: result.image_path || '',               // ä»image_pathå­—æ®µè·å–
        imageFilename: result.image_filename || '',        // ä»image_filenameå­—æ®µè·å–
        imageType: result.image_type || '',               // ä»image_typeå­—æ®µè·å–
        extension: result.extension || '',                // ä»extensionå­—æ®µè·å–
        semanticFeatures: result.semantic_features || {}, // ä»semantic_featureså­—æ®µè·å–
        enhancementEnabled: result.enhancement_enabled || false, // ä»enhancement_enabledå­—æ®µè·å–
        enhancementTimestamp: result.enhancement_timestamp || '' // ä»enhancement_timestampå­—æ®µè·å–
    }));
}

function processTableResults(tableResults) {
    return tableResults.map(result => ({
        // åŸºç¡€ä¿¡æ¯
        documentName: result.document_name,
        pageNumber: result.page_number,
        chunkType: result.chunk_type,
        
        // è¡¨æ ¼ä¿¡æ¯ï¼ˆæ˜ç¡®å¯¹åº”ï¼‰
        tableId: result.id || '',                         // ä»idå­—æ®µè·å–
        tableType: result.table_type || '',               // ä»table_typeå­—æ®µè·å–
        tableTitle: result.table_title || '',             // ä»table_titleå­—æ®µè·å–
        tableSummary: result.table_summary || '',         // ä»table_summaryå­—æ®µè·å–
        tableHeaders: result.table_headers || [],         // ä»table_headerså­—æ®µè·å–
        rowCount: result.table_row_count || 0,            // ä»table_row_countå­—æ®µè·å–
        columnCount: result.table_column_count || 0,      // ä»table_column_countå­—æ®µè·å–
        htmlContent: result.table_html || '',             // ä»table_htmlå­—æ®µè·å–
        processedContent: result.table_content || '',     // ä»table_contentå­—æ®µè·å–
        chunkIndex: result.chunk_index || 0               // ä»chunk_indexå­—æ®µè·å–
    }));
}

function processTextResults(textResults) {
    return textResults.map(result => ({
        // åŸºç¡€ä¿¡æ¯
        documentName: result.document_name,
        pageNumber: result.page_number,
        chunkType: result.chunk_type,
        
        // æ–‡æœ¬ä¿¡æ¯ï¼ˆæ˜ç¡®å¯¹åº”ï¼‰
        content: result.content || '',                    // ä»contentå­—æ®µè·å–
        contentPreview: result.content_preview || '',     // ä»content_previewå­—æ®µè·å–
        chunkIndex: result.chunk_index || 0               // ä»chunk_indexå­—æ®µè·å–
    }));
}
```

## å››ã€å®æ–½è®¡åˆ’

### 4.1 **å®æ–½é¡ºåº**
1. **é˜¶æ®µ1**ï¼šä¿®æ”¹`unified_pipeline.py`ï¼ˆæ ¸å¿ƒï¼‰
2. **é˜¶æ®µ2**ï¼šä¿®æ”¹ä¸‰ä¸ªå¼•æ“ï¼ˆä¸€è‡´æ€§ï¼‰
3. **é˜¶æ®µ3**ï¼šä¿®æ”¹APIè·¯ç”±ï¼ˆæ¥å£ï¼‰
4. **é˜¶æ®µ4**ï¼šä¿®æ”¹å‰ç«¯ï¼ˆæ˜¾ç¤ºï¼‰

### 4.2 **æ—¶é—´å®‰æ’**
- **é˜¶æ®µ1**ï¼š1-2å¤©
- **é˜¶æ®µ2**ï¼š2-3å¤©
- **é˜¶æ®µ3**ï¼š1-2å¤©
- **é˜¶æ®µ4**ï¼š1-2å¤©
- **æ€»è®¡**ï¼š5-9å¤©

### 4.3 **é£é™©æ§åˆ¶**
- æ¯é˜¶æ®µä¿®æ”¹åç«‹å³éªŒè¯
- ä¿ç•™åŸæœ‰å­—æ®µä½œä¸ºå¤‡ç”¨
- å®ç°å‘åå…¼å®¹çš„å­—æ®µæ˜ å°„
- æ·»åŠ è¯¦ç»†çš„æ³¨é‡Šå’Œæ–‡æ¡£

## äº”ã€é¢„æœŸæ•ˆæœ

### 5.1 **è§£å†³çš„é—®é¢˜**
- å›¾ç‰‡æŸ¥è¯¢ä¸å†æ˜¾ç¤º"æ— æ ‡é¢˜"
- è¡¨æ ¼æŸ¥è¯¢å­—æ®µæ˜ å°„æ¸…æ™°
- æ–‡æœ¬æŸ¥è¯¢å­—æ®µåç»Ÿä¸€
- æ··åˆæŸ¥è¯¢ç»“æœå±•ç¤ºä¸€è‡´

### 5.2 **ç³»ç»Ÿæ”¹è¿›**
- å­—æ®µå¯¹åº”å…³ç³»æ¸…æ™°æ˜ç¡®
- ä»£ç ç»“æ„æ›´åŠ è§„èŒƒ
- ç»´æŠ¤æ€§æ˜¾è‘—æå‡
- æ‰©å±•æ€§æ›´å¥½

### 5.3 **ç”¨æˆ·ä½“éªŒ**
- æŸ¥è¯¢ç»“æœæ˜¾ç¤ºæ­£ç¡®
- ä¿¡æ¯å±•ç¤ºæ›´åŠ å®Œæ•´
- æ“ä½œä½“éªŒæ›´åŠ æµç•…

## å…­ã€æ€»ç»“

è¿™ä¸ªæ”¹é€ æ–¹æ¡ˆé€šè¿‡å»ºç«‹æ˜ç¡®çš„å­—æ®µå¯¹åº”å…³ç³»ï¼Œè§£å†³äº†å½“å‰ç³»ç»Ÿä¸­å­—æ®µæ˜ å°„ä¸ä¸€è‡´çš„é—®é¢˜ã€‚æ–¹æ¡ˆå…·æœ‰ä»¥ä¸‹ç‰¹ç‚¹ï¼š

1. **ç³»ç»Ÿæ€§**ï¼šè¦†ç›–äº†ä»æ•°æ®åº“åˆ°å‰ç«¯çš„å®Œæ•´æ•°æ®æµ
2. **æ¸è¿›æ€§**ï¼šåˆ†é˜¶æ®µå®æ–½ï¼Œé£é™©å¯æ§
3. **ä¸€è‡´æ€§**ï¼šç¡®ä¿æ‰€æœ‰ç»„ä»¶çš„å­—æ®µæ˜ å°„ç»Ÿä¸€
4. **å¯ç»´æŠ¤æ€§**ï¼šå»ºç«‹äº†æ¸…æ™°çš„å­—æ®µå¯¹åº”å…³ç³»è¡¨

é€šè¿‡è¿™ä¸ªæ”¹é€ ï¼Œç³»ç»Ÿå°†å˜å¾—æ›´åŠ ç¨³å®šã€å¯ç»´æŠ¤ï¼Œç”¨æˆ·ä½“éªŒä¹Ÿä¼šæ˜¾è‘—æå‡ã€‚


å½“ç„¶å¯ä»¥ï¼åœ¨æ”¹é€ è¿‡ç¨‹ä¸­è¿›è¡Œé€‚å½“çš„æµ‹è¯•æ˜¯éå¸¸é‡è¦çš„ï¼Œè¿™æ ·å¯ä»¥ç¡®ä¿æ¯ä¸ªé˜¶æ®µçš„ä¿®æ”¹éƒ½æ˜¯æ­£ç¡®çš„ï¼Œé¿å…é—®é¢˜ç´¯ç§¯ã€‚è®©æˆ‘ä¸ºæ‚¨è®¾è®¡ä¸€ä¸ªå®Œæ•´çš„æµ‹è¯•ç­–ç•¥ï¼š

## æ”¹é€ è¿‡ç¨‹ä¸­çš„æµ‹è¯•ç­–ç•¥

### ä¸€ã€æµ‹è¯•åŸåˆ™

#### 1.1 **æ¸è¿›å¼æµ‹è¯•**
- æ¯å®Œæˆä¸€ä¸ªé˜¶æ®µç«‹å³æµ‹è¯•
- å‘ç°é—®é¢˜åŠæ—¶ä¿®å¤ï¼Œä¸ç´¯ç§¯
- ç¡®ä¿æ¯ä¸ªé˜¶æ®µéƒ½ç¨³å®šåå†è¿›å…¥ä¸‹ä¸€é˜¶æ®µ

#### 1.2 **åˆ†å±‚æµ‹è¯•**
- å•å…ƒæµ‹è¯•ï¼šæµ‹è¯•å•ä¸ªå‡½æ•°/æ–¹æ³•
- é›†æˆæµ‹è¯•ï¼šæµ‹è¯•æ¨¡å—é—´çš„äº¤äº’
- ç«¯åˆ°ç«¯æµ‹è¯•ï¼šæµ‹è¯•å®Œæ•´çš„æŸ¥è¯¢æµç¨‹

### äºŒã€å„é˜¶æ®µæµ‹è¯•æ–¹æ¡ˆ

#### 2.1 **é˜¶æ®µ1ï¼šunified_pipeline.py é‡æ„æµ‹è¯•**

##### 2.1.1 **å•å…ƒæµ‹è¯•**
```python
# tests/test_unified_pipeline_fields.py
import unittest
from unittest.mock import Mock, patch
from v2.core.unified_pipeline import UnifiedPipeline

class TestUnifiedPipelineFields(unittest.TestCase):
    def setUp(self):
        """æµ‹è¯•å‰å‡†å¤‡"""
        self.config = {
            'enable_llm_generation': True,
            'enable_source_filtering': True,
            'max_context_results': 10,
            'max_content_length': 1000
        }
        
        # Mock LLMå¼•æ“å’Œæºè¿‡æ»¤å¼•æ“
        self.llm_engine = Mock()
        self.source_filter_engine = Mock()
        
        self.pipeline = UnifiedPipeline(
            self.config, 
            self.llm_engine, 
            self.source_filter_engine
        )
    
    def test_extract_image_fields(self):
        """æµ‹è¯•å›¾ç‰‡å­—æ®µæå–"""
        # æ¨¡æ‹Ÿæ•°æ®åº“ä¸­çš„å›¾ç‰‡å…ƒæ•°æ®
        mock_metadata = {
            'document_name': 'æµ‹è¯•æ–‡æ¡£.pdf',
            'page_number': 5,
            'chunk_type': 'image',
            'img_caption': ['æµ‹è¯•å›¾ç‰‡æ ‡é¢˜'],
            'img_footnote': ['æµ‹è¯•è„šæ³¨'],
            'enhanced_description': 'è¿™æ˜¯ä¸€å¼ æµ‹è¯•å›¾ç‰‡çš„è¯¦ç»†æè¿°',
            'image_id': 'img_001',
            'image_path': '/path/to/test.jpg',
            'image_filename': 'test.jpg',
            'image_type': 'jpg',
            'extension': '.jpg'
        }
        
        # è°ƒç”¨å­—æ®µæå–æ–¹æ³•
        result = self.pipeline._extract_image_fields(mock_metadata)
        
        # éªŒè¯å­—æ®µæ˜ å°„æ˜¯å¦æ­£ç¡®
        self.assertEqual(result['caption'], ['æµ‹è¯•å›¾ç‰‡æ ‡é¢˜'])
        self.assertEqual(result['footnote'], ['æµ‹è¯•è„šæ³¨'])
        self.assertEqual(result['enhanced_description'], 'è¿™æ˜¯ä¸€å¼ æµ‹è¯•å›¾ç‰‡çš„è¯¦ç»†æè¿°')
        self.assertEqual(result['image_id'], 'img_001')
        self.assertEqual(result['image_path'], '/path/to/test.jpg')
    
    def test_extract_table_fields(self):
        """æµ‹è¯•è¡¨æ ¼å­—æ®µæå–"""
        mock_metadata = {
            'document_name': 'æµ‹è¯•æ–‡æ¡£.pdf',
            'page_number': 10,
            'chunk_type': 'table',
            'table_id': 'table_001',
            'table_type': 'æ•°æ®è¡¨æ ¼',
            'table_title': 'æµ‹è¯•è¡¨æ ¼',
            'table_summary': 'è¿™æ˜¯ä¸€ä¸ªæµ‹è¯•è¡¨æ ¼',
            'table_headers': ['åˆ—1', 'åˆ—2', 'åˆ—3'],
            'table_row_count': 5,
            'table_column_count': 3,
            'page_content': '<table>...</table>',
            'processed_table_content': 'å¤„ç†åçš„è¡¨æ ¼å†…å®¹'
        }
        
        result = self.pipeline._extract_table_fields(mock_metadata)
        
        self.assertEqual(result['table_id'], 'table_001')
        self.assertEqual(result['table_title'], 'æµ‹è¯•è¡¨æ ¼')
        self.assertEqual(result['html_content'], '<table>...</table>')
        self.assertEqual(result['processed_content'], 'å¤„ç†åçš„è¡¨æ ¼å†…å®¹')
    
    def test_extract_text_fields(self):
        """æµ‹è¯•æ–‡æœ¬å­—æ®µæå–"""
        mock_doc = Mock()
        mock_doc.page_content = "è¿™æ˜¯æµ‹è¯•æ–‡æœ¬å†…å®¹ï¼Œç”¨äºéªŒè¯å­—æ®µæå–åŠŸèƒ½ã€‚"
        mock_metadata = {
            'chunk_index': 15
        }
        
        result = self.pipeline._extract_text_fields(mock_doc, mock_metadata)
        
        self.assertEqual(result['content'], "è¿™æ˜¯æµ‹è¯•æ–‡æœ¬å†…å®¹ï¼Œç”¨äºéªŒè¯å­—æ®µæå–åŠŸèƒ½ã€‚")
        self.assertEqual(result['chunk_index'], 15)
        self.assertTrue('å†…å®¹é¢„è§ˆ' in result['content_preview'])

if __name__ == '__main__':
    unittest.main()
```

##### 2.1.2 **é›†æˆæµ‹è¯•**
```python
# tests/test_unified_pipeline_integration.py
import unittest
from unittest.mock import Mock, patch
from v2.core.unified_pipeline import UnifiedPipeline

class TestUnifiedPipelineIntegration(unittest.TestCase):
    def test_full_pipeline_with_image_docs(self):
        """æµ‹è¯•å®Œæ•´pipelineå¤„ç†å›¾ç‰‡æ–‡æ¡£"""
        # å‡†å¤‡æµ‹è¯•æ•°æ®
        mock_docs = [
            Mock(
                metadata={
                    'document_name': 'æµ‹è¯•æ–‡æ¡£1.pdf',
                    'page_number': 1,
                    'chunk_type': 'image',
                    'img_caption': ['å›¾ç‰‡1æ ‡é¢˜'],
                    'enhanced_description': 'å›¾ç‰‡1æè¿°'
                }
            ),
            Mock(
                metadata={
                    'document_name': 'æµ‹è¯•æ–‡æ¡£2.pdf',
                    'page_number': 2,
                    'chunk_type': 'image',
                    'img_caption': ['å›¾ç‰‡2æ ‡é¢˜'],
                    'enhanced_description': 'å›¾ç‰‡2æè¿°'
                }
            )
        ]
        
        # æ¨¡æ‹Ÿæœç´¢ç»“æœ
        search_results = [
            {'doc': doc, 'score': 0.9 - i * 0.1} 
            for i, doc in enumerate(mock_docs)
        ]
        
        # æµ‹è¯•æºæå–
        sources = self.pipeline._extract_sources(mock_docs)
        
        # éªŒè¯ç»“æœ
        self.assertEqual(len(sources), 2)
        self.assertEqual(sources[0]['caption'], ['å›¾ç‰‡1æ ‡é¢˜'])
        self.assertEqual(sources[1]['caption'], ['å›¾ç‰‡2æ ‡é¢˜'])
```

#### 2.2 **é˜¶æ®µ2ï¼šä¸‰ä¸ªå¼•æ“å­—æ®µæ˜ å°„æµ‹è¯•**

##### 2.2.1 **ImageEngineæµ‹è¯•**
```python
# tests/test_image_engine_fields.py
import unittest
from unittest.mock import Mock, patch
from v2.core.image_engine import ImageEngine

class TestImageEngineFields(unittest.TestCase):
    def test_enhance_reranked_results(self):
        """æµ‹è¯•å›¾ç‰‡å¼•æ“ç»“æœå¢å¼º"""
        engine = ImageEngine({})
        
        # æ¨¡æ‹Ÿrerankedç»“æœ
        mock_results = [
            {
                'doc': Mock(
                    metadata={
                        'document_name': 'æµ‹è¯•æ–‡æ¡£.pdf',
                        'page_number': 5,
                        'chunk_type': 'image',
                        'img_caption': ['æµ‹è¯•å›¾ç‰‡'],
                        'enhanced_description': 'è¯¦ç»†æè¿°',
                        'image_path': '/path/to/image.jpg'
                    }
                ),
                'score': 0.95
            }
        ]
        
        # æµ‹è¯•ç»“æœå¢å¼º
        enhanced = engine._enhance_reranked_results(mock_results)
        
        # éªŒè¯å­—æ®µæ˜ å°„
        self.assertEqual(enhanced[0]['caption'], ['æµ‹è¯•å›¾ç‰‡'])
        self.assertEqual(enhanced[0]['enhanced_description'], 'è¯¦ç»†æè¿°')
        self.assertEqual(enhanced[0]['image_path'], '/path/to/image.jpg')
```

##### 2.2.2 **TableEngineæµ‹è¯•**
```python
# tests/test_table_engine_fields.py
import unittest
from unittest.mock import Mock, patch
from v2.core.table_engine import TableEngine

class TestTableEngineFields(unittest.TestCase):
    def test_format_table_results(self):
        """æµ‹è¯•è¡¨æ ¼å¼•æ“ç»“æœæ ¼å¼åŒ–"""
        engine = TableEngine({})
        
        # æ¨¡æ‹Ÿæœç´¢ç»“æœ
        mock_results = [
            {
                'doc': Mock(
                    metadata={
                        'table_id': 'table_001',
                        'table_title': 'æµ‹è¯•è¡¨æ ¼',
                        'table_headers': ['åˆ—1', 'åˆ—2'],
                        'page_content': '<table>...</table>',
                        'processed_table_content': 'å¤„ç†åçš„å†…å®¹'
                    }
                ),
                'score': 0.88
            }
        ]
        
        # æµ‹è¯•ç»“æœæ ¼å¼åŒ–
        formatted = engine._format_table_results(mock_results)
        
        # éªŒè¯å­—æ®µæ˜ å°„
        self.assertEqual(formatted[0]['table_title'], 'æµ‹è¯•è¡¨æ ¼')
        self.assertEqual(formatted[0]['html_content'], '<table>...</table>')
        self.assertEqual(formatted[0]['processed_content'], 'å¤„ç†åçš„å†…å®¹')
```

#### 2.3 **é˜¶æ®µ3ï¼šAPIè·¯ç”±æµ‹è¯•**

##### 2.3.1 **å­—æ®µæ„å»ºæµ‹è¯•**
```python
# tests/test_api_fields.py
import unittest
from unittest.mock import Mock, patch
from v2.api.v2_routes import _build_image_result, _build_table_result

class TestAPIFields(unittest.TestCase):
    def test_build_image_result(self):
        """æµ‹è¯•å›¾ç‰‡ç»“æœæ„å»º"""
        # æ¨¡æ‹Ÿæ–‡æ¡£å¯¹è±¡
        mock_doc = Mock(
            metadata={
                'image_path': '/path/to/image.jpg',
                'img_caption': ['æµ‹è¯•å›¾ç‰‡æ ‡é¢˜'],
                'enhanced_description': 'è¯¦ç»†æè¿°',
                'document_name': 'æµ‹è¯•æ–‡æ¡£.pdf',
                'page_number': 5,
                'image_id': 'img_001'
            }
        )
        
        # æµ‹è¯•ç»“æœæ„å»º
        result = _build_image_result(mock_doc, 0.95)
        
        # éªŒè¯å­—æ®µæ˜ å°„
        self.assertEqual(result['caption'], ['æµ‹è¯•å›¾ç‰‡æ ‡é¢˜'])
        self.assertEqual(result['image_path'], '/path/to/image.jpg')
        self.assertEqual(result['image_id'], 'img_001')
    
    def test_build_table_result(self):
        """æµ‹è¯•è¡¨æ ¼ç»“æœæ„å»º"""
        mock_doc = Mock(
            metadata={
                'table_id': 'table_001',
                'table_title': 'æµ‹è¯•è¡¨æ ¼',
                'page_content': '<table>...</table>',
                'processed_table_content': 'å¤„ç†åçš„å†…å®¹'
            }
        )
        
        result = _build_table_result(mock_doc, 0.88)
        
        self.assertEqual(result['id'], 'table_001')
        self.assertEqual(result['table_title'], 'æµ‹è¯•è¡¨æ ¼')
        self.assertEqual(result['table_html'], '<table>...</table>')
        self.assertEqual(result['table_content'], 'å¤„ç†åçš„å†…å®¹')
```

#### 2.4 **é˜¶æ®µ4ï¼šç«¯åˆ°ç«¯æµ‹è¯•**

##### 2.4.1 **å®Œæ•´æŸ¥è¯¢æµç¨‹æµ‹è¯•**
```python
# tests/test_end_to_end_fields.py
import unittest
from unittest.mock import Mock, patch
import requests
import json

class TestEndToEndFields(unittest.TestCase):
    def setUp(self):
        """æµ‹è¯•å‰å‡†å¤‡"""
        self.base_url = "http://localhost:8000"
        self.test_queries = {
            'image': "æ˜¾ç¤ºå›¾ç‰‡",
            'table': "æ˜¾ç¤ºè¡¨æ ¼",
            'text': "æ˜¾ç¤ºæ–‡æœ¬"
        }
    
    @patch('requests.post')
    def test_image_query_fields(self, mock_post):
        """æµ‹è¯•å›¾ç‰‡æŸ¥è¯¢çš„å­—æ®µå®Œæ•´æ€§"""
        # æ¨¡æ‹ŸAPIå“åº”
        mock_response = Mock()
        mock_response.json.return_value = {
            'success': True,
            'answer': 'è¿™æ˜¯å›¾ç‰‡æŸ¥è¯¢çš„ç­”æ¡ˆ',
            'related_images': [
                {
                    'caption': ['æµ‹è¯•å›¾ç‰‡æ ‡é¢˜'],
                    'image_path': '/path/to/image.jpg',
                    'enhanced_description': 'è¯¦ç»†æè¿°',
                    'document_name': 'æµ‹è¯•æ–‡æ¡£.pdf',
                    'page_number': 5
                }
            ]
        }
        mock_response.status_code = 200
        mock_post.return_value = mock_response
        
        # å‘é€æµ‹è¯•è¯·æ±‚
        response = requests.post(
            f"{self.base_url}/api/query",
            json={'query': self.test_queries['image'], 'query_type': 'image'}
        )
        
        # éªŒè¯å“åº”å­—æ®µ
        data = response.json()
        self.assertTrue(data['success'])
        
        if 'related_images' in data:
            image = data['related_images'][0]
            self.assertIn('caption', image)
            self.assertIn('image_path', image)
            self.assertIn('enhanced_description', image)
            self.assertNotEqual(image['caption'], ['æ— æ ‡é¢˜'])
    
    @patch('requests.post')
    def test_table_query_fields(self, mock_post):
        """æµ‹è¯•è¡¨æ ¼æŸ¥è¯¢çš„å­—æ®µå®Œæ•´æ€§"""
        mock_response = Mock()
        mock_response.json.return_value = {
            'success': True,
            'answer': 'è¿™æ˜¯è¡¨æ ¼æŸ¥è¯¢çš„ç­”æ¡ˆ',
            'related_tables': [
                {
                    'id': 'table_001',
                    'table_title': 'æµ‹è¯•è¡¨æ ¼',
                    'table_html': '<table>...</table>',
                    'table_content': 'å¤„ç†åçš„å†…å®¹'
                }
            ]
        }
        mock_response.status_code = 200
        mock_post.return_value = mock_response
        
        response = requests.post(
            f"{self.base_url}/api/query",
            json={'query': self.test_queries['table'], 'query_type': 'table'}
        )
        
        data = response.json()
        if 'related_tables' in data:
            table = data['related_tables'][0]
            self.assertIn('id', table)
            self.assertIn('table_title', table)
            self.assertIn('table_html', table)
            self.assertIn('table_content', table)
```

### ä¸‰ã€æµ‹è¯•æ‰§è¡Œç­–ç•¥

#### 3.1 **è‡ªåŠ¨åŒ–æµ‹è¯•**
```bash
# è¿è¡Œæ‰€æœ‰æµ‹è¯•
python -m pytest tests/ -v

# è¿è¡Œç‰¹å®šé˜¶æ®µçš„æµ‹è¯•
python -m pytest tests/test_unified_pipeline_fields.py -v
python -m pytest tests/test_image_engine_fields.py -v
python -m pytest tests/test_api_fields.py -v

# ç”Ÿæˆæµ‹è¯•è¦†ç›–ç‡æŠ¥å‘Š
python -m pytest tests/ --cov=v2 --cov-report=html
```

#### 3.2 **æ‰‹åŠ¨æµ‹è¯•**
```python
# å¿«é€Ÿæµ‹è¯•è„šæœ¬
# tools/test_field_mapping_quick.py
import sys
import os
sys.path.append(os.path.join(os.path.dirname(__file__), '..'))

from v2.core.unified_pipeline import UnifiedPipeline
from v2.core.image_engine import ImageEngine
from v2.core.table_engine import TableEngine

def quick_test():
    """å¿«é€Ÿæµ‹è¯•å­—æ®µæ˜ å°„"""
    print("ğŸ§ª å¼€å§‹å¿«é€Ÿå­—æ®µæ˜ å°„æµ‹è¯•...")
    
    # æµ‹è¯•1: å›¾ç‰‡å­—æ®µæ˜ å°„
    print("\n1. æµ‹è¯•å›¾ç‰‡å­—æ®µæ˜ å°„...")
    try:
        # è¿™é‡Œå¯ä»¥æ·»åŠ å…·ä½“çš„æµ‹è¯•é€»è¾‘
        print("âœ… å›¾ç‰‡å­—æ®µæ˜ å°„æµ‹è¯•é€šè¿‡")
    except Exception as e:
        print(f"âŒ å›¾ç‰‡å­—æ®µæ˜ å°„æµ‹è¯•å¤±è´¥: {e}")
    
    # æµ‹è¯•2: è¡¨æ ¼å­—æ®µæ˜ å°„
    print("\n2. æµ‹è¯•è¡¨æ ¼å­—æ®µæ˜ å°„...")
    try:
        # è¿™é‡Œå¯ä»¥æ·»åŠ å…·ä½“çš„æµ‹è¯•é€»è¾‘
        print("âœ… è¡¨æ ¼å­—æ®µæ˜ å°„æµ‹è¯•é€šè¿‡")
    except Exception as e:
        print(f"âŒ è¡¨æ ¼å­—æ®µæ˜ å°„æµ‹è¯•å¤±è´¥: {e}")
    
    print("\nğŸ‰ å¿«é€Ÿæµ‹è¯•å®Œæˆ!")

if __name__ == "__main__":
    quick_test()
```

### å››ã€æµ‹è¯•æ•°æ®å‡†å¤‡

#### 4.1 **æµ‹è¯•æ•°æ®æ–‡ä»¶**
```python
# tests/test_data.py
TEST_IMAGE_METADATA = {
    'document_name': 'æµ‹è¯•æ–‡æ¡£.pdf',
    'page_number': 5,
    'chunk_type': 'image',
    'img_caption': ['æµ‹è¯•å›¾ç‰‡æ ‡é¢˜'],
    'img_footnote': ['æµ‹è¯•è„šæ³¨'],
    'enhanced_description': 'è¿™æ˜¯ä¸€å¼ æµ‹è¯•å›¾ç‰‡çš„è¯¦ç»†æè¿°ï¼ŒåŒ…å«äº†ä¸°å¯Œçš„ä¿¡æ¯å†…å®¹ã€‚',
    'image_id': 'img_001',
    'image_path': '/path/to/test.jpg',
    'image_filename': 'test.jpg',
    'image_type': 'jpg',
    'extension': '.jpg',
    'semantic_features': {'objects': ['äºº', 'è½¦'], 'actions': ['è¡Œèµ°']},
    'enhancement_enabled': True,
    'enhancement_timestamp': '2024-01-01 12:00:00'
}

TEST_TABLE_METADATA = {
    'document_name': 'æµ‹è¯•æ–‡æ¡£.pdf',
    'page_number': 10,
    'chunk_type': 'table',
    'table_id': 'table_001',
    'table_type': 'æ•°æ®è¡¨æ ¼',
    'table_title': 'æµ‹è¯•è¡¨æ ¼æ ‡é¢˜',
    'table_summary': 'è¿™æ˜¯ä¸€ä¸ªç”¨äºæµ‹è¯•çš„è¡¨æ ¼ï¼ŒåŒ…å«äº†å„ç§æ•°æ®ç±»å‹ã€‚',
    'table_headers': ['å§“å', 'å¹´é¾„', 'èŒä¸š', 'æ”¶å…¥'],
    'table_row_count': 5,
    'table_column_count': 4,
    'page_content': '<table><tr><th>å§“å</th><th>å¹´é¾„</th></tr></table>',
    'processed_table_content': 'å§“å: å¼ ä¸‰, å¹´é¾„: 25; å§“å: æå››, å¹´é¾„: 30',
    'related_text': 'è¡¨æ ¼ç›¸å…³çš„æ–‡æœ¬æè¿°',
    'chunk_index': 15
}

TEST_TEXT_METADATA = {
    'document_name': 'æµ‹è¯•æ–‡æ¡£.pdf',
    'page_number': 3,
    'chunk_type': 'text',
    'chunk_index': 8
}
```

### äº”ã€æµ‹è¯•æ‰§è¡Œå»ºè®®

#### 5.1 **æ¯é˜¶æ®µæµ‹è¯•**
1. **ä¿®æ”¹å®Œæˆåç«‹å³è¿è¡Œå•å…ƒæµ‹è¯•**
2. **éªŒè¯å­—æ®µæ˜ å°„æ˜¯å¦æ­£ç¡®**
3. **æ£€æŸ¥æ˜¯å¦æœ‰è¯­æ³•é”™è¯¯**
4. **ç¡®ä¿å‘åå…¼å®¹æ€§**

#### 5.2 **é›†æˆæµ‹è¯•**
1. **æµ‹è¯•æ¨¡å—é—´çš„æ•°æ®ä¼ é€’**
2. **éªŒè¯å­—æ®µåœ¨æ•´ä¸ªæµç¨‹ä¸­çš„ä¸€è‡´æ€§**
3. **æ£€æŸ¥APIå“åº”çš„å®Œæ•´æ€§**

#### 5.3 **å›å½’æµ‹è¯•**
1. **ç¡®ä¿æ–°åŠŸèƒ½ä¸å½±å“ç°æœ‰åŠŸèƒ½**
2. **éªŒè¯æ‰€æœ‰æŸ¥è¯¢ç±»å‹ä»ç„¶æ­£å¸¸å·¥ä½œ**
3. **æ£€æŸ¥å‰ç«¯æ˜¾ç¤ºæ˜¯å¦æ­£å¸¸**

### å…­ã€æµ‹è¯•å·¥å…·å’Œç¯å¢ƒ

#### 6.1 **æµ‹è¯•æ¡†æ¶**
- **pytest**: ä¸»è¦çš„æµ‹è¯•æ¡†æ¶
- **unittest.mock**: æ¨¡æ‹Ÿå’Œæ‰“æ¡©
- **coverage**: æµ‹è¯•è¦†ç›–ç‡åˆ†æ

#### 6.2 **æµ‹è¯•ç¯å¢ƒ**
- **ç‹¬ç«‹æµ‹è¯•æ•°æ®åº“**: é¿å…å½±å“ç”Ÿäº§æ•°æ®
- **æ¨¡æ‹Ÿå¤–éƒ¨æœåŠ¡**: å‡å°‘ä¾èµ–
- **è‡ªåŠ¨åŒ–æµ‹è¯•è„šæœ¬**: æé«˜æµ‹è¯•æ•ˆç‡

é€šè¿‡è¿™æ ·çš„æµ‹è¯•ç­–ç•¥ï¼Œæˆ‘ä»¬å¯ä»¥ç¡®ä¿æ¯ä¸ªé˜¶æ®µçš„æ”¹é€ éƒ½æ˜¯æ­£ç¡®çš„ï¼Œæœ€ç»ˆå®ç°ä¸€ä¸ªç¨³å®šã€å¯é çš„å­—æ®µæ˜ å°„ç³»ç»Ÿã€‚æ‚¨è§‰å¾—è¿™ä¸ªæµ‹è¯•æ–¹æ¡ˆå¦‚ä½•ï¼Ÿéœ€è¦æˆ‘è¯¦ç»†è¯´æ˜æŸä¸ªéƒ¨åˆ†å—ï¼Ÿ