好的，让我仔细检查这些程序，然后写一个详细的可行改造方案。让我逐一深入分析：

## 程序深入检查

### 1. **v2/core/unified_pipeline.py 详细检查**

Read file: v2/core/unified_pipeline.py
Read file: v2/core/unified_pipeline.py
Read file: v2/core/unified_pipeline.py
现在让我检查其他关键文件：

Ran tool
Ran tool
Ran tool
基于我的深入检查，现在我来写一个详细的可行改造方案：

# 字段对应关系改造详细方案

## 一、现状分析

### 1.1 **核心问题识别**

#### 1.1.1 **字段映射不一致**
- **数据库字段**：`img_caption`（图片标题）
- **后端字段**：`caption`（图片标题）
- **前端字段**：`caption`（图片标题）
- **问题**：后端在提取时没有正确映射`img_caption`到`caption`

#### 1.1.2 **字段提取逻辑混乱**
- 使用猜测式字段提取（`for caption_field in ['img_caption', 'caption', 'title', 'image_title', 'description']`）
- 字段优先级不明确
- 缺乏统一的字段对应关系

#### 1.1.3 **数据结构不一致**
- 三个引擎返回不同的字段结构
- API响应中的字段名与数据库不一致
- 前端期望的字段名与后端不一致

### 1.2 **影响范围**
- **图片查询**：显示"无标题"问题
- **表格查询**：字段映射混乱
- **文本查询**：字段名不一致
- **混合查询**：结果展示不统一

## 二、改造目标

### 2.1 **主要目标**
1. 建立明确的字段对应关系
2. 统一三个引擎的字段结构
3. 确保API响应的字段一致性
4. 解决前端显示问题

### 2.2 **具体目标**
- 图片查询：正确显示图片标题
- 表格查询：字段映射清晰
- 文本查询：字段名统一
- 混合查询：结果展示一致

## 三、改造方案

### 3.1 **阶段1：核心字段对应关系建立**

#### 3.1.1 **字段映射表设计**
```python
# 明确的字段对应关系表
FIELD_MAPPING = {
    # 通用字段
    'document_name': 'document_name',      # 文档名称
    'page_number': 'page_number',          # 页码
    'chunk_type': 'chunk_type',            # 内容类型
    
    # 图片字段
    'caption': 'img_caption',              # 图片标题（从img_caption获取）
    'footnote': 'img_footnote',            # 图片脚注（从img_footnote获取）
    'enhanced_description': 'enhanced_description',  # 增强描述
    'image_id': 'image_id',                # 图片ID
    'image_path': 'image_path',            # 图片路径
    'image_filename': 'image_filename',    # 图片文件名
    'image_type': 'image_type',            # 图片类型
    'extension': 'extension',              # 文件扩展名
    
    # 表格字段
    'table_id': 'table_id',                # 表格ID
    'table_type': 'table_type',            # 表格类型
    'table_title': 'table_title',          # 表格标题
    'table_summary': 'table_summary',      # 表格摘要
    'table_headers': 'table_headers',      # 表格表头
    'table_row_count': 'table_row_count',  # 表格行数
    'table_column_count': 'table_column_count',  # 表格列数
    'html_content': 'page_content',        # HTML格式内容
    'processed_content': 'processed_table_content',  # 语义化内容
    
    # 文本字段
    'content': 'page_content',             # 文本内容
    'content_preview': 'page_content',     # 内容预览
    'chunk_index': 'chunk_index'           # 分块索引
}
```

#### 3.1.2 **unified_pipeline.py 重构**
```python
class UnifiedPipeline:
    def __init__(self, config: Dict[str, Any], llm_engine, source_filter_engine):
        # ... 现有初始化代码 ...
        
        # 新增：字段映射配置
        self.field_mapping = FIELD_MAPPING
    
    def _extract_sources(self, retrieved_docs: List[Any]) -> List[Dict[str, Any]]:
        """提取来源信息 - 明确的字段对应关系"""
        sources = []
        
        for doc in retrieved_docs:
            source_info = {}
            
            if hasattr(doc, 'metadata') and doc.metadata:
                doc_metadata = doc.metadata
                
                # 1. 通用字段 - 直接对应
                source_info.update({
                    'document_name': doc_metadata.get('document_name', '未知文档'),
                    'page_number': doc_metadata.get('page_number', '未知页'),
                    'chunk_type': doc_metadata.get('chunk_type', '未知类型')
                })
                
                # 2. 根据chunk_type提取特定字段
                chunk_type = doc_metadata.get('chunk_type', '')
                
                if chunk_type == 'image':
                    source_info.update(self._extract_image_fields(doc_metadata))
                elif chunk_type == 'table':
                    source_info.update(self._extract_table_fields(doc_metadata))
                elif chunk_type == 'text':
                    source_info.update(self._extract_text_fields(doc, doc_metadata))
            
            sources.append(source_info)
        
        return sources
    
    def _extract_image_fields(self, doc_metadata: Dict[str, Any]) -> Dict[str, Any]:
        """提取图片字段 - 明确的对应关系"""
        return {
            'caption': doc_metadata.get('img_caption', []),           # 明确从img_caption获取
            'footnote': doc_metadata.get('img_footnote', []),         # 明确从img_footnote获取
            'enhanced_description': doc_metadata.get('enhanced_description', ''),  # 明确从enhanced_description获取
            'image_id': doc_metadata.get('image_id', ''),             # 明确从image_id获取
            'image_path': doc_metadata.get('image_path', ''),         # 明确从image_path获取
            'image_filename': doc_metadata.get('image_filename', ''), # 明确从image_filename获取
            'image_type': doc_metadata.get('image_type', ''),         # 明确从image_type获取
            'extension': doc_metadata.get('extension', ''),           # 明确从extension获取
            'semantic_features': doc_metadata.get('semantic_features', {}),  # 明确从semantic_features获取
            'enhancement_enabled': doc_metadata.get('enhancement_enabled', False),  # 明确从enhancement_enabled获取
            'enhancement_timestamp': doc_metadata.get('enhancement_timestamp', '')  # 明确从enhancement_timestamp获取
        }
    
    def _extract_table_fields(self, doc_metadata: Dict[str, Any]) -> Dict[str, Any]:
        """提取表格字段 - 明确的对应关系"""
        return {
            'table_id': doc_metadata.get('table_id', ''),             # 明确从table_id获取
            'table_type': doc_metadata.get('table_type', ''),         # 明确从table_type获取
            'table_title': doc_metadata.get('table_title', ''),       # 明确从table_title获取
            'table_summary': doc_metadata.get('table_summary', ''),   # 明确从table_summary获取
            'table_headers': doc_metadata.get('table_headers', []),   # 明确从table_headers获取
            'table_row_count': doc_metadata.get('table_row_count', 0), # 明确从table_row_count获取
            'table_column_count': doc_metadata.get('table_column_count', 0), # 明确从table_column_count获取
            'html_content': doc_metadata.get('page_content', ''),     # 明确从page_content获取（HTML格式）
            'processed_content': doc_metadata.get('processed_table_content', ''), # 明确从processed_table_content获取
            'related_text': doc_metadata.get('related_text', ''),     # 明确从related_text获取
            'chunk_index': doc_metadata.get('chunk_index', 0)        # 明确从chunk_index获取
        }
    
    def _extract_text_fields(self, doc, doc_metadata: Dict[str, Any]) -> Dict[str, Any]:
        """提取文本字段 - 明确的对应关系"""
        return {
            'content': doc.page_content,                              # 明确从page_content获取
            'content_preview': doc.page_content[:200] + '...' if len(doc.page_content) > 200 else doc.page_content,
            'chunk_index': doc_metadata.get('chunk_index', 0)        # 明确从chunk_index获取
        }
```

### 3.2 **阶段2：三个引擎字段映射统一**

#### 3.2.1 **image_engine.py 修改**
```python
class ImageEngine:
    def _enhance_reranked_results(self, reranked_results: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """增强reranked_results：使用明确的字段映射"""
        enhanced_results = []
        
        for result in reranked_results:
            if isinstance(result, dict) and 'doc' in result:
                enhanced_result = result.copy()
                
                doc = result['doc']
                if hasattr(doc, 'metadata') and doc.metadata:
                    metadata = doc.metadata
                    
                    # 使用明确的字段映射
                    enhanced_result.update({
                        'document_name': metadata.get('document_name', '未知文档'),
                        'page_number': metadata.get('page_number', '未知页'),
                        'chunk_type': metadata.get('chunk_type', '图片'),
                        'image_path': metadata.get('image_path', ''),
                        'caption': metadata.get('img_caption', []),           # 明确从img_caption获取
                        'enhanced_description': metadata.get('enhanced_description', ''),
                        'image_id': metadata.get('image_id', ''),
                        'image_filename': metadata.get('image_filename', ''),
                        'image_type': metadata.get('image_type', ''),
                        'extension': metadata.get('extension', ''),
                        'semantic_features': metadata.get('semantic_features', {}),
                        'enhancement_enabled': metadata.get('enhancement_enabled', False),
                        'enhancement_timestamp': metadata.get('enhancement_timestamp', '')
                    })
                
                enhanced_results.append(enhanced_result)
        
        return enhanced_results
```

#### 3.2.2 **table_engine.py 修改**
```python
class TableEngine:
    def _format_table_results(self, search_results: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """格式化表格结果：使用明确的字段映射"""
        formatted_results = []
        
        for result in search_results:
            if isinstance(result, dict) and 'doc' in result:
                doc = result['doc']
                metadata = doc.metadata if hasattr(doc, 'metadata') else {}
                
                # 使用明确的字段映射
                formatted_result = {
                    'id': metadata.get('table_id', 'unknown'),
                    'table_type': metadata.get('table_type', '数据表格'),
                    'table_title': metadata.get('table_title', ''),
                    'table_summary': metadata.get('table_summary', ''),
                    'table_headers': metadata.get('table_headers', []),
                    'table_row_count': metadata.get('table_row_count', 0),
                    'table_column_count': metadata.get('table_column_count', 0),
                    'html_content': metadata.get('page_content', ''),     # 明确从page_content获取
                    'processed_content': metadata.get('processed_table_content', ''), # 明确从processed_table_content获取
                    'related_text': metadata.get('related_text', ''),
                    'chunk_index': metadata.get('chunk_index', 0),
                    'document_name': metadata.get('document_name', '未知文档'),
                    'page_number': metadata.get('page_number', '未知页'),
                    'chunk_type': 'table',
                    'score': result.get('score', 0.0)
                }
                
                formatted_results.append(formatted_result)
        
        return formatted_results
```

#### 3.2.3 **text_engine.py 修改**
```python
class TextEngine:
    def _process_text_result(self, doc, query: str) -> Dict[str, Any]:
        """处理文本结果：使用明确的字段映射"""
        metadata = doc.metadata if hasattr(doc, 'metadata') else {}
        
        return {
            'content': doc.page_content,                              # 明确从page_content获取
            'content_preview': doc.page_content[:200] + '...' if len(doc.page_content) > 200 else doc.page_content,
            'chunk_index': metadata.get('chunk_index', 0),            # 明确从chunk_index获取
            'document_name': metadata.get('document_name', '未知文档'),
            'page_number': metadata.get('page_number', '未知页'),
            'chunk_type': metadata.get('chunk_type', 'text'),
            'score': 0.0
        }
```

### 3.3 **阶段3：API路由字段统一**

#### 3.3.1 **v2_routes.py 修改**
```python
# 在API路由中使用统一的字段名
def _build_image_result(actual_doc, score: float) -> Dict[str, Any]:
    """构建图片结果：使用统一的字段名"""
    metadata = actual_doc.metadata if hasattr(actual_doc, 'metadata') else {}
    
    return {
        'image_path': metadata.get('image_path', ''),
        'caption': metadata.get('img_caption', ['无标题']),           # 明确从img_caption获取
        'enhanced_description': metadata.get('enhanced_description', ''),
        'document_name': metadata.get('document_name', '未知文档'),
        'page_number': metadata.get('page_number', 'N/A'),
        'chunk_type': metadata.get('chunk_type', ''),
        'llm_context': metadata.get('llm_context', 'N/A'),
        'formatted_source': metadata.get('formatted_source', 'N/A'),
        'score': score,
        'doc_id': metadata.get('image_id', ''),                      # 明确从image_id获取
        'image_id': metadata.get('image_id', ''),                    # 新增：明确字段
        'image_filename': metadata.get('image_filename', ''),        # 新增：明确字段
        'image_type': metadata.get('image_type', ''),                # 新增：明确字段
        'extension': metadata.get('extension', '')                   # 新增：明确字段
    }

def _build_table_result(actual_doc, score: float) -> Dict[str, Any]:
    """构建表格结果：使用统一的字段名"""
    metadata = actual_doc.metadata if hasattr(actual_doc, 'metadata') else {}
    
    return {
        'id': metadata.get('table_id', 'unknown'),
        'table_type': metadata.get('table_type', '数据表格'),
        'table_title': metadata.get('table_title', ''),
        'table_html': metadata.get('page_content', ''),              # 明确从page_content获取
        'table_content': metadata.get('processed_table_content', ''), # 明确从processed_table_content获取
        'document_name': metadata.get('document_name', '未知文档'),
        'page_number': metadata.get('page_number', 'N/A'),
        'score': score,
        'chunk_type': 'table',
        'table_headers': metadata.get('table_headers', []),
        'table_row_count': metadata.get('table_row_count', 0),
        'table_column_count': metadata.get('table_column_count', 0), # 统一字段名
        'table_summary': metadata.get('table_summary', ''),
        'chunk_index': metadata.get('chunk_index', 0)                # 新增：明确字段
    }
```

### 3.4 **阶段4：前端字段处理统一**

#### 3.4.1 **v2_index.html 修改**
```javascript
// 统一的字段处理函数
function processImageResults(imageResults) {
    return imageResults.map(result => ({
        // 基础信息
        documentName: result.document_name,
        pageNumber: result.page_number,
        chunkType: result.chunk_type,
        
        // 图片信息（明确对应）
        title: result.caption?.[0] || '无标题',           // 从caption字段获取
        footnote: result.footnote?.join(', ') || '',      // 从footnote字段获取
        description: result.enhanced_description || '',    // 从enhanced_description字段获取
        imageId: result.image_id || '',                   // 从image_id字段获取
        imagePath: result.image_path || '',               // 从image_path字段获取
        imageFilename: result.image_filename || '',        // 从image_filename字段获取
        imageType: result.image_type || '',               // 从image_type字段获取
        extension: result.extension || '',                // 从extension字段获取
        semanticFeatures: result.semantic_features || {}, // 从semantic_features字段获取
        enhancementEnabled: result.enhancement_enabled || false, // 从enhancement_enabled字段获取
        enhancementTimestamp: result.enhancement_timestamp || '' // 从enhancement_timestamp字段获取
    }));
}

function processTableResults(tableResults) {
    return tableResults.map(result => ({
        // 基础信息
        documentName: result.document_name,
        pageNumber: result.page_number,
        chunkType: result.chunk_type,
        
        // 表格信息（明确对应）
        tableId: result.id || '',                         // 从id字段获取
        tableType: result.table_type || '',               // 从table_type字段获取
        tableTitle: result.table_title || '',             // 从table_title字段获取
        tableSummary: result.table_summary || '',         // 从table_summary字段获取
        tableHeaders: result.table_headers || [],         // 从table_headers字段获取
        rowCount: result.table_row_count || 0,            // 从table_row_count字段获取
        columnCount: result.table_column_count || 0,      // 从table_column_count字段获取
        htmlContent: result.table_html || '',             // 从table_html字段获取
        processedContent: result.table_content || '',     // 从table_content字段获取
        chunkIndex: result.chunk_index || 0               // 从chunk_index字段获取
    }));
}

function processTextResults(textResults) {
    return textResults.map(result => ({
        // 基础信息
        documentName: result.document_name,
        pageNumber: result.page_number,
        chunkType: result.chunk_type,
        
        // 文本信息（明确对应）
        content: result.content || '',                    // 从content字段获取
        contentPreview: result.content_preview || '',     // 从content_preview字段获取
        chunkIndex: result.chunk_index || 0               // 从chunk_index字段获取
    }));
}
```

## 四、实施计划

### 4.1 **实施顺序**
1. **阶段1**：修改`unified_pipeline.py`（核心）
2. **阶段2**：修改三个引擎（一致性）
3. **阶段3**：修改API路由（接口）
4. **阶段4**：修改前端（显示）

### 4.2 **时间安排**
- **阶段1**：1-2天
- **阶段2**：2-3天
- **阶段3**：1-2天
- **阶段4**：1-2天
- **总计**：5-9天

### 4.3 **风险控制**
- 每阶段修改后立即验证
- 保留原有字段作为备用
- 实现向后兼容的字段映射
- 添加详细的注释和文档

## 五、预期效果

### 5.1 **解决的问题**
- 图片查询不再显示"无标题"
- 表格查询字段映射清晰
- 文本查询字段名统一
- 混合查询结果展示一致

### 5.2 **系统改进**
- 字段对应关系清晰明确
- 代码结构更加规范
- 维护性显著提升
- 扩展性更好

### 5.3 **用户体验**
- 查询结果显示正确
- 信息展示更加完整
- 操作体验更加流畅

## 六、总结

这个改造方案通过建立明确的字段对应关系，解决了当前系统中字段映射不一致的问题。方案具有以下特点：

1. **系统性**：覆盖了从数据库到前端的完整数据流
2. **渐进性**：分阶段实施，风险可控
3. **一致性**：确保所有组件的字段映射统一
4. **可维护性**：建立了清晰的字段对应关系表

通过这个改造，系统将变得更加稳定、可维护，用户体验也会显著提升。


当然可以！在改造过程中进行适当的测试是非常重要的，这样可以确保每个阶段的修改都是正确的，避免问题累积。让我为您设计一个完整的测试策略：

## 改造过程中的测试策略

### 一、测试原则

#### 1.1 **渐进式测试**
- 每完成一个阶段立即测试
- 发现问题及时修复，不累积
- 确保每个阶段都稳定后再进入下一阶段

#### 1.2 **分层测试**
- 单元测试：测试单个函数/方法
- 集成测试：测试模块间的交互
- 端到端测试：测试完整的查询流程

### 二、各阶段测试方案

#### 2.1 **阶段1：unified_pipeline.py 重构测试**

##### 2.1.1 **单元测试**
```python
# tests/test_unified_pipeline_fields.py
import unittest
from unittest.mock import Mock, patch
from v2.core.unified_pipeline import UnifiedPipeline

class TestUnifiedPipelineFields(unittest.TestCase):
    def setUp(self):
        """测试前准备"""
        self.config = {
            'enable_llm_generation': True,
            'enable_source_filtering': True,
            'max_context_results': 10,
            'max_content_length': 1000
        }
        
        # Mock LLM引擎和源过滤引擎
        self.llm_engine = Mock()
        self.source_filter_engine = Mock()
        
        self.pipeline = UnifiedPipeline(
            self.config, 
            self.llm_engine, 
            self.source_filter_engine
        )
    
    def test_extract_image_fields(self):
        """测试图片字段提取"""
        # 模拟数据库中的图片元数据
        mock_metadata = {
            'document_name': '测试文档.pdf',
            'page_number': 5,
            'chunk_type': 'image',
            'img_caption': ['测试图片标题'],
            'img_footnote': ['测试脚注'],
            'enhanced_description': '这是一张测试图片的详细描述',
            'image_id': 'img_001',
            'image_path': '/path/to/test.jpg',
            'image_filename': 'test.jpg',
            'image_type': 'jpg',
            'extension': '.jpg'
        }
        
        # 调用字段提取方法
        result = self.pipeline._extract_image_fields(mock_metadata)
        
        # 验证字段映射是否正确
        self.assertEqual(result['caption'], ['测试图片标题'])
        self.assertEqual(result['footnote'], ['测试脚注'])
        self.assertEqual(result['enhanced_description'], '这是一张测试图片的详细描述')
        self.assertEqual(result['image_id'], 'img_001')
        self.assertEqual(result['image_path'], '/path/to/test.jpg')
    
    def test_extract_table_fields(self):
        """测试表格字段提取"""
        mock_metadata = {
            'document_name': '测试文档.pdf',
            'page_number': 10,
            'chunk_type': 'table',
            'table_id': 'table_001',
            'table_type': '数据表格',
            'table_title': '测试表格',
            'table_summary': '这是一个测试表格',
            'table_headers': ['列1', '列2', '列3'],
            'table_row_count': 5,
            'table_column_count': 3,
            'page_content': '<table>...</table>',
            'processed_table_content': '处理后的表格内容'
        }
        
        result = self.pipeline._extract_table_fields(mock_metadata)
        
        self.assertEqual(result['table_id'], 'table_001')
        self.assertEqual(result['table_title'], '测试表格')
        self.assertEqual(result['html_content'], '<table>...</table>')
        self.assertEqual(result['processed_content'], '处理后的表格内容')
    
    def test_extract_text_fields(self):
        """测试文本字段提取"""
        mock_doc = Mock()
        mock_doc.page_content = "这是测试文本内容，用于验证字段提取功能。"
        mock_metadata = {
            'chunk_index': 15
        }
        
        result = self.pipeline._extract_text_fields(mock_doc, mock_metadata)
        
        self.assertEqual(result['content'], "这是测试文本内容，用于验证字段提取功能。")
        self.assertEqual(result['chunk_index'], 15)
        self.assertTrue('内容预览' in result['content_preview'])

if __name__ == '__main__':
    unittest.main()
```

##### 2.1.2 **集成测试**
```python
# tests/test_unified_pipeline_integration.py
import unittest
from unittest.mock import Mock, patch
from v2.core.unified_pipeline import UnifiedPipeline

class TestUnifiedPipelineIntegration(unittest.TestCase):
    def test_full_pipeline_with_image_docs(self):
        """测试完整pipeline处理图片文档"""
        # 准备测试数据
        mock_docs = [
            Mock(
                metadata={
                    'document_name': '测试文档1.pdf',
                    'page_number': 1,
                    'chunk_type': 'image',
                    'img_caption': ['图片1标题'],
                    'enhanced_description': '图片1描述'
                }
            ),
            Mock(
                metadata={
                    'document_name': '测试文档2.pdf',
                    'page_number': 2,
                    'chunk_type': 'image',
                    'img_caption': ['图片2标题'],
                    'enhanced_description': '图片2描述'
                }
            )
        ]
        
        # 模拟搜索结果
        search_results = [
            {'doc': doc, 'score': 0.9 - i * 0.1} 
            for i, doc in enumerate(mock_docs)
        ]
        
        # 测试源提取
        sources = self.pipeline._extract_sources(mock_docs)
        
        # 验证结果
        self.assertEqual(len(sources), 2)
        self.assertEqual(sources[0]['caption'], ['图片1标题'])
        self.assertEqual(sources[1]['caption'], ['图片2标题'])
```

#### 2.2 **阶段2：三个引擎字段映射测试**

##### 2.2.1 **ImageEngine测试**
```python
# tests/test_image_engine_fields.py
import unittest
from unittest.mock import Mock, patch
from v2.core.image_engine import ImageEngine

class TestImageEngineFields(unittest.TestCase):
    def test_enhance_reranked_results(self):
        """测试图片引擎结果增强"""
        engine = ImageEngine({})
        
        # 模拟reranked结果
        mock_results = [
            {
                'doc': Mock(
                    metadata={
                        'document_name': '测试文档.pdf',
                        'page_number': 5,
                        'chunk_type': 'image',
                        'img_caption': ['测试图片'],
                        'enhanced_description': '详细描述',
                        'image_path': '/path/to/image.jpg'
                    }
                ),
                'score': 0.95
            }
        ]
        
        # 测试结果增强
        enhanced = engine._enhance_reranked_results(mock_results)
        
        # 验证字段映射
        self.assertEqual(enhanced[0]['caption'], ['测试图片'])
        self.assertEqual(enhanced[0]['enhanced_description'], '详细描述')
        self.assertEqual(enhanced[0]['image_path'], '/path/to/image.jpg')
```

##### 2.2.2 **TableEngine测试**
```python
# tests/test_table_engine_fields.py
import unittest
from unittest.mock import Mock, patch
from v2.core.table_engine import TableEngine

class TestTableEngineFields(unittest.TestCase):
    def test_format_table_results(self):
        """测试表格引擎结果格式化"""
        engine = TableEngine({})
        
        # 模拟搜索结果
        mock_results = [
            {
                'doc': Mock(
                    metadata={
                        'table_id': 'table_001',
                        'table_title': '测试表格',
                        'table_headers': ['列1', '列2'],
                        'page_content': '<table>...</table>',
                        'processed_table_content': '处理后的内容'
                    }
                ),
                'score': 0.88
            }
        ]
        
        # 测试结果格式化
        formatted = engine._format_table_results(mock_results)
        
        # 验证字段映射
        self.assertEqual(formatted[0]['table_title'], '测试表格')
        self.assertEqual(formatted[0]['html_content'], '<table>...</table>')
        self.assertEqual(formatted[0]['processed_content'], '处理后的内容')
```

#### 2.3 **阶段3：API路由测试**

##### 2.3.1 **字段构建测试**
```python
# tests/test_api_fields.py
import unittest
from unittest.mock import Mock, patch
from v2.api.v2_routes import _build_image_result, _build_table_result

class TestAPIFields(unittest.TestCase):
    def test_build_image_result(self):
        """测试图片结果构建"""
        # 模拟文档对象
        mock_doc = Mock(
            metadata={
                'image_path': '/path/to/image.jpg',
                'img_caption': ['测试图片标题'],
                'enhanced_description': '详细描述',
                'document_name': '测试文档.pdf',
                'page_number': 5,
                'image_id': 'img_001'
            }
        )
        
        # 测试结果构建
        result = _build_image_result(mock_doc, 0.95)
        
        # 验证字段映射
        self.assertEqual(result['caption'], ['测试图片标题'])
        self.assertEqual(result['image_path'], '/path/to/image.jpg')
        self.assertEqual(result['image_id'], 'img_001')
    
    def test_build_table_result(self):
        """测试表格结果构建"""
        mock_doc = Mock(
            metadata={
                'table_id': 'table_001',
                'table_title': '测试表格',
                'page_content': '<table>...</table>',
                'processed_table_content': '处理后的内容'
            }
        )
        
        result = _build_table_result(mock_doc, 0.88)
        
        self.assertEqual(result['id'], 'table_001')
        self.assertEqual(result['table_title'], '测试表格')
        self.assertEqual(result['table_html'], '<table>...</table>')
        self.assertEqual(result['table_content'], '处理后的内容')
```

#### 2.4 **阶段4：端到端测试**

##### 2.4.1 **完整查询流程测试**
```python
# tests/test_end_to_end_fields.py
import unittest
from unittest.mock import Mock, patch
import requests
import json

class TestEndToEndFields(unittest.TestCase):
    def setUp(self):
        """测试前准备"""
        self.base_url = "http://localhost:8000"
        self.test_queries = {
            'image': "显示图片",
            'table': "显示表格",
            'text': "显示文本"
        }
    
    @patch('requests.post')
    def test_image_query_fields(self, mock_post):
        """测试图片查询的字段完整性"""
        # 模拟API响应
        mock_response = Mock()
        mock_response.json.return_value = {
            'success': True,
            'answer': '这是图片查询的答案',
            'related_images': [
                {
                    'caption': ['测试图片标题'],
                    'image_path': '/path/to/image.jpg',
                    'enhanced_description': '详细描述',
                    'document_name': '测试文档.pdf',
                    'page_number': 5
                }
            ]
        }
        mock_response.status_code = 200
        mock_post.return_value = mock_response
        
        # 发送测试请求
        response = requests.post(
            f"{self.base_url}/api/query",
            json={'query': self.test_queries['image'], 'query_type': 'image'}
        )
        
        # 验证响应字段
        data = response.json()
        self.assertTrue(data['success'])
        
        if 'related_images' in data:
            image = data['related_images'][0]
            self.assertIn('caption', image)
            self.assertIn('image_path', image)
            self.assertIn('enhanced_description', image)
            self.assertNotEqual(image['caption'], ['无标题'])
    
    @patch('requests.post')
    def test_table_query_fields(self, mock_post):
        """测试表格查询的字段完整性"""
        mock_response = Mock()
        mock_response.json.return_value = {
            'success': True,
            'answer': '这是表格查询的答案',
            'related_tables': [
                {
                    'id': 'table_001',
                    'table_title': '测试表格',
                    'table_html': '<table>...</table>',
                    'table_content': '处理后的内容'
                }
            ]
        }
        mock_response.status_code = 200
        mock_post.return_value = mock_response
        
        response = requests.post(
            f"{self.base_url}/api/query",
            json={'query': self.test_queries['table'], 'query_type': 'table'}
        )
        
        data = response.json()
        if 'related_tables' in data:
            table = data['related_tables'][0]
            self.assertIn('id', table)
            self.assertIn('table_title', table)
            self.assertIn('table_html', table)
            self.assertIn('table_content', table)
```

### 三、测试执行策略

#### 3.1 **自动化测试**
```bash
# 运行所有测试
python -m pytest tests/ -v

# 运行特定阶段的测试
python -m pytest tests/test_unified_pipeline_fields.py -v
python -m pytest tests/test_image_engine_fields.py -v
python -m pytest tests/test_api_fields.py -v

# 生成测试覆盖率报告
python -m pytest tests/ --cov=v2 --cov-report=html
```

#### 3.2 **手动测试**
```python
# 快速测试脚本
# tools/test_field_mapping_quick.py
import sys
import os
sys.path.append(os.path.join(os.path.dirname(__file__), '..'))

from v2.core.unified_pipeline import UnifiedPipeline
from v2.core.image_engine import ImageEngine
from v2.core.table_engine import TableEngine

def quick_test():
    """快速测试字段映射"""
    print("🧪 开始快速字段映射测试...")
    
    # 测试1: 图片字段映射
    print("\n1. 测试图片字段映射...")
    try:
        # 这里可以添加具体的测试逻辑
        print("✅ 图片字段映射测试通过")
    except Exception as e:
        print(f"❌ 图片字段映射测试失败: {e}")
    
    # 测试2: 表格字段映射
    print("\n2. 测试表格字段映射...")
    try:
        # 这里可以添加具体的测试逻辑
        print("✅ 表格字段映射测试通过")
    except Exception as e:
        print(f"❌ 表格字段映射测试失败: {e}")
    
    print("\n🎉 快速测试完成!")

if __name__ == "__main__":
    quick_test()
```

### 四、测试数据准备

#### 4.1 **测试数据文件**
```python
# tests/test_data.py
TEST_IMAGE_METADATA = {
    'document_name': '测试文档.pdf',
    'page_number': 5,
    'chunk_type': 'image',
    'img_caption': ['测试图片标题'],
    'img_footnote': ['测试脚注'],
    'enhanced_description': '这是一张测试图片的详细描述，包含了丰富的信息内容。',
    'image_id': 'img_001',
    'image_path': '/path/to/test.jpg',
    'image_filename': 'test.jpg',
    'image_type': 'jpg',
    'extension': '.jpg',
    'semantic_features': {'objects': ['人', '车'], 'actions': ['行走']},
    'enhancement_enabled': True,
    'enhancement_timestamp': '2024-01-01 12:00:00'
}

TEST_TABLE_METADATA = {
    'document_name': '测试文档.pdf',
    'page_number': 10,
    'chunk_type': 'table',
    'table_id': 'table_001',
    'table_type': '数据表格',
    'table_title': '测试表格标题',
    'table_summary': '这是一个用于测试的表格，包含了各种数据类型。',
    'table_headers': ['姓名', '年龄', '职业', '收入'],
    'table_row_count': 5,
    'table_column_count': 4,
    'page_content': '<table><tr><th>姓名</th><th>年龄</th></tr></table>',
    'processed_table_content': '姓名: 张三, 年龄: 25; 姓名: 李四, 年龄: 30',
    'related_text': '表格相关的文本描述',
    'chunk_index': 15
}

TEST_TEXT_METADATA = {
    'document_name': '测试文档.pdf',
    'page_number': 3,
    'chunk_type': 'text',
    'chunk_index': 8
}
```

### 五、测试执行建议

#### 5.1 **每阶段测试**
1. **修改完成后立即运行单元测试**
2. **验证字段映射是否正确**
3. **检查是否有语法错误**
4. **确保向后兼容性**

#### 5.2 **集成测试**
1. **测试模块间的数据传递**
2. **验证字段在整个流程中的一致性**
3. **检查API响应的完整性**

#### 5.3 **回归测试**
1. **确保新功能不影响现有功能**
2. **验证所有查询类型仍然正常工作**
3. **检查前端显示是否正常**

### 六、测试工具和环境

#### 6.1 **测试框架**
- **pytest**: 主要的测试框架
- **unittest.mock**: 模拟和打桩
- **coverage**: 测试覆盖率分析

#### 6.2 **测试环境**
- **独立测试数据库**: 避免影响生产数据
- **模拟外部服务**: 减少依赖
- **自动化测试脚本**: 提高测试效率

通过这样的测试策略，我们可以确保每个阶段的改造都是正确的，最终实现一个稳定、可靠的字段映射系统。您觉得这个测试方案如何？需要我详细说明某个部分吗？