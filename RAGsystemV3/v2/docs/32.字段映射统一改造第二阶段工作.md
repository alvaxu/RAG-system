您说得非常对！既然我们已经完成了字段映射的统一改造，在 `v2_routes.py` 中确实不需要再考虑向后兼容问题。这样可以大大简化代码，让系统更加清晰和高效。

## 🎯 **简化后的改造计划**

### **当前完成情况**
- ✅ **阶段1：unified_pipeline.py 重构** - 100% 完成
- ⚠️ **阶段2：三个引擎字段映射统一** - 70% 完成
- ⚠️ **阶段3：API路由字段统一** - 40% 完成
- ❌ **阶段4：前端字段处理统一** - 0% 完成

## 📋 **简化后的TODO List**

### **🔧 阶段2补完：TableEngine字段映射统一**

#### **TODO 2.1：在TableEngine中添加统一的字段映射方法**
- [ ] 在 `v2/core/table_engine.py` 中添加 `_format_table_results()` 方法
- [ ] 使用明确的字段映射关系（参考 `unified_pipeline.py` 中的 `_extract_table_fields`）
- [ ] 确保返回的字段结构与ImageEngine和TextEngine一致

### **�� 阶段3补完：API路由字段统一（简化版）**

#### **TODO 3.1：在v2_routes.py中添加统一的字段构建方法**
- [ ] 添加 `_build_unified_image_result()` 方法
- [ ] 添加 `_build_unified_table_result()` 方法  
- [ ] 添加 `_build_unified_text_result()` 方法
- [ ] **只使用标准化的字段映射，不考虑向后兼容**

**简化后的实现：**
```python
def _build_unified_image_result(actual_doc, score: float) -> Dict[str, Any]:
    """构建统一的图片结果：使用明确的字段映射"""
    metadata = actual_doc.metadata
    return {
        'image_path': metadata.get('image_path', ''),
        'caption': metadata.get('img_caption', ['无标题']),           # 明确从img_caption获取
        'footnote': metadata.get('img_footnote', []),                 # 明确从img_footnote获取
        'enhanced_description': metadata.get('enhanced_description', ''),
        'document_name': metadata.get('document_name', '未知文档'),
        'page_number': metadata.get('page_number', 'N/A'),
        'chunk_type': metadata.get('chunk_type', ''),
        'llm_context': metadata.get('llm_context', 'N/A'),
        'formatted_source': metadata.get('formatted_source', 'N/A'),
        'score': score,
        'image_id': metadata.get('image_id', ''),                    # 明确从image_id获取
        'image_filename': metadata.get('image_filename', ''),        # 明确从image_filename获取
        'image_type': metadata.get('image_type', ''),                # 明确从image_type获取
        'extension': metadata.get('extension', '')                   # 明确从extension获取
    }

def _build_unified_table_result(actual_doc, score: float) -> Dict[str, Any]:
    """构建统一的表格结果：使用明确的字段映射"""
    metadata = actual_doc.metadata
    return {
        'id': metadata.get('table_id', 'unknown'),
        'table_type': metadata.get('table_type', '数据表格'),
        'table_title': metadata.get('table_title', ''),
        'table_html': metadata.get('page_content', ''),              # 明确从page_content获取
        'table_content': metadata.get('processed_table_content', ''), # 明确从processed_table_content获取
        'document_name': metadata.get('document_name', '未知文档'),
        'page_number': metadata.get('page_number', 'N/A'),
        'score': score,
        'chunk_type': 'table',
        'table_headers': metadata.get('table_headers', []),
        'table_row_count': metadata.get('table_row_count', 0),
        'table_column_count': metadata.get('table_column_count', 0), # 统一字段名
        'table_summary': metadata.get('table_summary', ''),
        'chunk_index': metadata.get('chunk_index', 0)                # 明确字段
    }

def _build_unified_text_result(actual_doc, score: float) -> Dict[str, Any]:
    """构建统一的文本结果：使用明确的字段映射"""
    metadata = actual_doc.metadata
    return {
        'content': actual_doc.page_content,                              # 明确从page_content获取
        'content_preview': actual_doc.page_content[:200] + '...' if len(actual_doc.page_content) > 200 else actual_doc.page_content,
        'chunk_index': metadata.get('chunk_index', 0),                   # 明确从chunk_index获取
        'document_name': metadata.get('document_name', '未知文档'),
        'page_number': metadata.get('page_number', 'N/A'),
        'chunk_type': metadata.get('chunk_type', 'text'),
        'score': score
    }
```

#### **TODO 3.2：简化v2_ask_question函数中的处理逻辑**
- [ ] 替换现有的复杂表格处理逻辑
- [ ] 使用统一的字段构建方法
- [ ] **删除所有扁平化处理逻辑**
- [ ] **删除所有向后兼容代码**

**简化后的实现：**
```python
# 在v2_ask_question函数中，使用统一的处理逻辑
for actual_doc, score in processed_docs:
    chunk_type = actual_doc.metadata.get('chunk_type', '')
    
    if chunk_type == 'image':
        # 使用统一的图片字段映射
        image_result = _build_unified_image_result(actual_doc, score)
        image_results.append(image_result)
        
    elif chunk_type == 'table':
        # 使用统一的表格字段映射
        table_result = _build_unified_table_result(actual_doc, score)
        table_results.append(table_result)
        
    elif chunk_type == 'text':
        # 使用统一的文本字段映射
        text_result = _build_unified_text_result(actual_doc, score)
        text_results.append(text_result)
```

#### **TODO 3.3：大幅简化_extract_actual_doc_and_score函数**
- [ ] **删除所有复杂的嵌套检查逻辑**
- [ ] **删除所有扁平化结构处理**
- [ ] **只保留标准Document对象的处理**

**简化后的实现：**
```python
def _extract_actual_doc_and_score(doc):
    """简化的文档提取函数 - 只处理标准Document对象"""
    try:
        # 只处理标准Document对象
        if hasattr(doc, 'metadata') and doc.metadata:
            return doc, getattr(doc, 'score', 0.0)
        else:
            logger.warning(f"文档对象格式不正确: {type(doc)}")
            return None, 0.0
            
    except Exception as e:
        logger.warning(f"提取文档对象时出错: {e}")
        return None, 0.0
```

#### **TODO 3.4：简化_extract_sources_from_result函数**
- [ ] **删除所有扁平化结构处理**
- [ ] **只保留标准Document对象的处理**
- [ ] **使用统一的字段提取逻辑**

**简化后的实现：**
```python
def _extract_sources_from_result(result):
    """从QueryResult提取来源信息 - 简化版本，只处理标准Document对象"""
    if not result:
        return []
    
    # 处理HybridQueryResult对象
    if hasattr(result, 'combined_results'):
        docs = result.combined_results
    elif hasattr(result, 'results'):
        docs = result.results
    else:
        return []
    
    sources = []
    for doc in docs:
        try:
            # 只处理标准Document对象
            if hasattr(doc, 'metadata') and doc.metadata:
                metadata = doc.metadata
                chunk_type = metadata.get('chunk_type', '文本')
                document_name = metadata.get('document_name', '未知文档')
                page_number = metadata.get('page_number', 'N/A')
                page_content = getattr(doc, 'page_content', '')
                
                # 类型转换
                if chunk_type == 'image':
                    chunk_type = '图片'
                elif chunk_type == 'table':
                    chunk_type = '表格'
                
                # 构建来源信息
                sources.append({
                    'title': f'{document_name} - 第{page_number}页',
                    'page_number': page_number,
                    'document_name': document_name,
                    'source_type': chunk_type,
                    'score': 0.0,
                    'content_preview': page_content[:200] + '...' if len(page_content) > 200 else page_content,
                    'formatted_source': _format_source_display(document_name, page_content, page_number, chunk_type)
                })
            else:
                logger.warning(f"跳过非标准文档对象: {type(doc)}")
                
        except Exception as e:
            logger.warning(f"处理文档时出错: {e}")
            continue
    
    return sources
```

### **🔧 阶段4：前端字段处理统一（简化版）**

#### **TODO 4.1：在v2_index.html中添加统一的字段处理函数**
- [ ] 添加 `processImageResults()` 函数
- [ ] 添加 `processTableResults()` 函数
- [ ] 添加 `processTextResults()` 函数
- [ ] **只使用标准化的字段名，不考虑向后兼容**

### **🔧 阶段5：清理和优化**

#### **TODO 5.1：删除所有旧的复杂代码**
- [ ] **删除所有扁平化处理逻辑**
- [ ] **删除所有向后兼容代码**
- [ ] **删除所有猜测式字段提取代码**
- [ ] **删除所有复杂的嵌套检查**

#### **TODO 5.2：代码优化**
- [ ] 统一错误处理机制
- [ ] 优化日志输出
- [ ] 添加详细的注释

## �� **简化后的优势**

### **1. 代码更清晰**
- 不再有复杂的条件判断
- 字段映射关系一目了然
- 逻辑流程更加直观

### **2. 维护性更好**
- 不需要维护多套处理逻辑
- 错误更容易定位和修复
- 新功能开发更容易

### **3. 性能更优**
- 减少了不必要的条件检查
- 减少了数据转换步骤
- 响应速度更快

### **4. 扩展性更强**
- 新增查询类型更容易
- 字段修改影响范围更小
- 系统架构更清晰

## 🚀 **执行建议**

既然不考虑向后兼容，我建议：

1. **立即执行**：从 **TODO 2.1** 开始，补完TableEngine
2. **快速推进**：简化所有API路由代码，删除复杂逻辑
3. **一步到位**：直接实现完全统一的处理模式
4. **彻底清理**：删除所有旧的复杂代码

您觉得这个简化方案如何？如果同意，我现在就开始执行 **TODO 2.1**：补完TableEngine的字段映射方法。