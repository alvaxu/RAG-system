
统一加载器内部：_docs_cache 是 dict 类型(text\image\table都是)
对外接口：get_documents_by_type() 返回 list 类型
TextEngine期望：dict 类型
imageEngine和tableEngine期望：list
但是在tableEngine内部，数据流又都用dict



## 仔细分析代码后的发现

### 1. **TableEngine 内部确实使用 `list` 类型**

```python
# 在 TableEngine 中
self.table_docs = []  # 列表类型

# 从统一加载器获取
self.table_docs = self.document_loader.get_documents_by_type('table')  # 返回list
```

### 2. **但在数据传输过程中，我们做了大量的转换和补全工作**

#### 在 `_search_tables()` 方法中：
```python
# 第一层：表格结构精确匹配
for i, table_doc in enumerate(self.table_docs):  # 遍历list
    # 但是构造结果时，我们创建了dict格式
    results.append({
        'doc': table_doc,           # 原始Document对象
        'content': table_doc.page_content,
        'metadata': table_doc.metadata,
        'score': title_score,
        'source': 'structure_search',
        'layer': 1,
        # ... 其他字段
    })
```

#### 在 `process_query()` 方法中：
```python
# 格式化结果时，我们构造了dict格式
formatted_result = {
    'id': metadata.get('table_id', 'unknown'),
    'table_type': metadata.get('table_type', '数据表格'),
    'table_title': metadata.get('table_title', ''),
    'table_html': metadata.get('page_content', ''),
    'table_content': metadata.get('processed_table_content', ''),
    'document_name': metadata.get('document_name', '未知文档'),
    'page_number': metadata.get('page_number', '未知页'),
    # ... 其他字段
}
```

### 3. **在 Reranking 过程中，我们继续使用 dict 格式**

#### 在 `TableRerankingService` 中：
```python
# 输入是dict格式的candidates
def rerank(self, query: str, candidates: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
    # 处理的是dict格式
    for candidate in candidates:
        if 'doc' in candidate and candidate['doc']:
            doc = candidate['doc']  # 从dict中提取doc
            metadata = getattr(doc, 'metadata', {})
            content = getattr(doc, 'page_content', '')
```

### 4. **在 UnifiedPipeline 中，我们继续处理 dict 格式**

#### 在 `UnifiedPipeline` 中：
```python
# 输入是dict格式的reranked_results
def process(self, query: str, reranked_results: List[Dict[str, Any]], query_type: str = None):
    # 处理的是dict格式
    for i, result in enumerate(reranked_results):
        if 'doc' in result and isinstance(result['doc'], dict):
            # 处理嵌套的doc结构
            doc_dict = result['doc']
            content = doc_dict.get('content', '')
            metadata = doc_dict.get('metadata', {})
```

### 5. **在 v2_routes 中，我们最终输出 dict 格式**

#### 在 `v2_routes.py` 中：
```python
# 最终输出是dict格式
def _build_unified_table_result(actual_doc, score: float) -> Dict[str, Any]:
    return {
        'id': getattr(actual_doc, 'id', 'unknown'),
        'table_html': getattr(actual_doc, 'page_content', ''),
        'table_content': metadata.get('processed_table_content', ''),
        'document_name': metadata.get('document_name', '未知文档'),
        'page_number': metadata.get('page_number', 'N/A'),
        'score': score
    }
```

## 问题的根源

**虽然 TableEngine 内部使用 `list` 存储文档，但在整个数据传输过程中，我们做了大量的转换工作，最终输出的仍然是 `dict` 格式！**

### 具体问题：

1. **内部存储**：`self.table_docs = []` (list)
2. **搜索过程**：遍历 list，但构造 dict 格式的结果
3. **重排序**：处理 dict 格式的输入和输出
4. **Pipeline**：继续处理 dict 格式
5. **最终输出**：仍然是 dict 格式

### 这种设计的矛盾：

- **统一加载器**：返回 `list` 类型
- **TableEngine**：内部使用 `list`，但输出 `dict`
- **整个流程**：在 list 和 dict 之间反复转换
- **最终结果**：仍然是 `dict` 格式

你说得对，这确实是一个设计问题。我们做了大量的数据补全和转换工作，而不是直接使用 list 的简单性。这种设计增加了复杂性，也增加了出错的可能性。