# V1è€ç‰ˆæœ¬é…ç½®ç®¡ç†æŠ€æœ¯å®ç°

## 1. é…ç½®æ¶æ„æ€»è§ˆ

### 1.1 æ•´ä½“æ¶æ„
è€ç‰ˆæœ¬ç³»ç»Ÿé‡‡ç”¨åˆ†å±‚é…ç½®ç®¡ç†æ¶æ„ï¼Œä¸»è¦ç‰¹ç‚¹ï¼š

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   é…ç½®æ–‡ä»¶      â”‚    â”‚   é…ç½®ç®¡ç†å™¨    â”‚    â”‚   ä¸šåŠ¡ç»„ä»¶      â”‚
â”‚  (config.json)  â”‚â”€â”€â”€â†’â”‚  (ConfigMgr)    â”‚â”€â”€â”€â†’â”‚  (å„ç§æ¨¡å—)     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â”‚
                              â–¼
                       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                       â”‚   é…ç½®éªŒè¯å™¨    â”‚
                       â”‚  (Settings)     â”‚
                       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 1.2 æŠ€æœ¯ç‰¹ç‚¹
- **JSONé…ç½®**: ä½¿ç”¨JSONæ ¼å¼å­˜å‚¨é…ç½®ä¿¡æ¯
- **ç±»å°è£…**: é€šè¿‡`Settings`ç±»å°è£…é…ç½®å‚æ•°
- **ç»Ÿä¸€ç®¡ç†**: é€šè¿‡`ConfigManager`ç»Ÿä¸€ç®¡ç†é…ç½®

## 2. æ ¸å¿ƒé…ç½®ç±»è®¾è®¡

### 2.1 Settingsç±» (config/settings.py)

#### 2.1.1 åŸºç¡€ç»“æ„
```python
class Settings:
    """ç³»ç»Ÿé…ç½®è®¾ç½®ç±»"""
    
    def __init__(self):
        # ç³»ç»ŸåŸºç¡€é…ç½®
        self.system_name: str = "RAGæ™ºèƒ½é—®ç­”ç³»ç»Ÿ"
        self.version: str = "1.2.0"
        self.debug_mode: bool = False
        
        # è·¯å¾„é…ç½®
        self.pdf_dir: str = "document/pdf"
        self.md_dir: str = "document/md"
        self.output_dir: str = "document/output"
        self.vector_db_dir: str = "central/vector_db"
        self.memory_db_dir: str = "central/memory_db"
        self.central_images_dir: str = "central/images"
        self.web_app_dir: str = "web_app"
        
        # å¤„ç†é…ç½®
        self.chunk_size: int = 1000
        self.chunk_overlap: int = 200
        self.max_table_rows: int = 100
        self.enable_logging: bool = True
        
        # å‘é‡å­˜å‚¨é…ç½®
        self.vector_dimension: int = 1536
        self.similarity_top_k: int = 5
        
        # è®°å¿†é…ç½®
        self.memory_enabled: bool = True
        self.memory_max_size: int = 1000
        
        # APIé…ç½®
        self.dashscope_api_key: str = ""
        self.mineru_api_key: str = ""
        
        # é—®ç­”ç³»ç»Ÿé…ç½®
        self.model_name: str = "qwen-turbo"
        self.temperature: float = 0.7
        self.max_tokens: int = 2048
```

#### 2.1.2 é…ç½®éªŒè¯æ–¹æ³•
```python
def validate(self) -> Dict[str, bool]:
    """éªŒè¯é…ç½®æœ‰æ•ˆæ€§"""
    validation_results = {}
    
    # éªŒè¯å¿…éœ€è·¯å¾„
    validation_results['pdf_dir'] = self._validate_path(self.pdf_dir)
    validation_results['output_dir'] = self._validate_path(self.output_dir)
    validation_results['vector_db_dir'] = self._validate_path(self.vector_db_dir)
    
    # éªŒè¯æ•°å€¼å‚æ•°
    validation_results['chunk_size'] = self.chunk_size > 0
    validation_results['chunk_overlap'] = 0 <= self.chunk_overlap < self.chunk_size
    validation_results['vector_dimension'] = self.vector_dimension > 0
    
    # éªŒè¯APIé…ç½®
    validation_results['api_key'] = bool(self.dashscope_api_key and 
                                       self.dashscope_api_key != 'ä½ çš„APIKEY')
    
    return validation_results

def _validate_path(self, path: str) -> bool:
    """éªŒè¯è·¯å¾„æœ‰æ•ˆæ€§"""
    try:
        # æ£€æŸ¥è·¯å¾„æ˜¯å¦ä¸ºç©º
        if not path or not path.strip():
            return False
        
        # æ£€æŸ¥è·¯å¾„æ ¼å¼
        path_obj = Path(path)
        
        # å¦‚æœæ˜¯ç›¸å¯¹è·¯å¾„ï¼Œè½¬æ¢ä¸ºç»å¯¹è·¯å¾„
        if not path_obj.is_absolute():
            path_obj = Path.cwd() / path
        
        # æ£€æŸ¥çˆ¶ç›®å½•æ˜¯å¦å­˜åœ¨
        parent_dir = path_obj.parent
        if not parent_dir.exists():
            # å°è¯•åˆ›å»ºçˆ¶ç›®å½•
            try:
                parent_dir.mkdir(parents=True, exist_ok=True)
                return True
            except Exception:
                return False
        
        return True
        
    except Exception:
        return False
```

### 2.2 ConfigManagerç±» (config/config_manager.py)

#### 2.2.1 æ ¸å¿ƒç®¡ç†åŠŸèƒ½
```python
class ConfigManager:
    """é…ç½®ç®¡ç†å™¨"""
    
    def __init__(self, config_file: str = 'config.json'):
        self.config_file = config_file
        self.settings = Settings()
        self._load_config()
    
    def _load_config(self):
        """åŠ è½½é…ç½®æ–‡ä»¶"""
        try:
            if os.path.exists(self.config_file):
                with open(self.config_file, 'r', encoding='utf-8') as f:
                    config_data = json.load(f)
                
                # æ›´æ–°è®¾ç½®
                self._update_settings_from_dict(config_data)
                logger.info(f"é…ç½®åŠ è½½æˆåŠŸ: {self.config_file}")
            else:
                logger.warning(f"é…ç½®æ–‡ä»¶ä¸å­˜åœ¨: {self.config_file}")
                self._create_default_config()
                
        except Exception as e:
            logger.error(f"é…ç½®åŠ è½½å¤±è´¥: {str(e)}")
            self._create_default_config()
    
    def _update_settings_from_dict(self, config_data: dict):
        """ä»å­—å…¸æ›´æ–°è®¾ç½®"""
        for key, value in config_data.items():
            if hasattr(self.settings, key):
                setattr(self.settings, key, value)
                logger.debug(f"æ›´æ–°é…ç½®: {key} = {value}")
            else:
                logger.warning(f"æœªçŸ¥é…ç½®é¡¹: {key}")
    
    def _create_default_config(self):
        """åˆ›å»ºé»˜è®¤é…ç½®"""
        try:
            # ä½¿ç”¨Settingsç±»çš„é»˜è®¤å€¼
            default_config = self.settings.__dict__.copy()
            
            # ä¿å­˜é»˜è®¤é…ç½®
            self.save_config()
            logger.info("å·²åˆ›å»ºé»˜è®¤é…ç½®æ–‡ä»¶")
            
        except Exception as e:
            logger.error(f"åˆ›å»ºé»˜è®¤é…ç½®å¤±è´¥: {str(e)}")
```

#### 2.2.2 é…ç½®ä¿å­˜å’Œæ›´æ–°
```python
def save_config(self):
    """ä¿å­˜é…ç½®åˆ°æ–‡ä»¶"""
    try:
        # è·å–å½“å‰è®¾ç½®
        config_data = self.settings.__dict__.copy()
        
        # è¿‡æ»¤æ‰ç§æœ‰å±æ€§
        config_data = {k: v for k, v in config_data.items() 
                      if not k.startswith('_')}
        
        # ä¿å­˜åˆ°æ–‡ä»¶
        with open(self.config_file, 'w', encoding='utf-8') as f:
            json.dump(config_data, f, ensure_ascii=False, indent=2)
        
        logger.info(f"é…ç½®ä¿å­˜æˆåŠŸ: {self.config_file}")
        return True
        
    except Exception as e:
        logger.error(f"é…ç½®ä¿å­˜å¤±è´¥: {str(e)}")
        return False

def update_config(self, updates: dict) -> bool:
    """æ›´æ–°é…ç½®"""
    try:
        # éªŒè¯æ›´æ–°é¡¹
        valid_updates = {}
        for key, value in updates.items():
            if hasattr(self.settings, key):
                # ç±»å‹éªŒè¯
                current_value = getattr(self.settings, key)
                if isinstance(value, type(current_value)):
                    valid_updates[key] = value
                else:
                    logger.warning(f"ç±»å‹ä¸åŒ¹é…: {key}, æœŸæœ› {type(current_value)}, å®é™… {type(value)}")
            else:
                logger.warning(f"æœªçŸ¥é…ç½®é¡¹: {key}")
        
        # åº”ç”¨æ›´æ–°
        for key, value in valid_updates.items():
            setattr(self.settings, key, value)
            logger.info(f"é…ç½®æ›´æ–°: {key} = {value}")
        
        # ä¿å­˜é…ç½®
        if valid_updates:
            self.save_config()
        
        return True
        
    except Exception as e:
        logger.error(f"é…ç½®æ›´æ–°å¤±è´¥: {str(e)}")
        return False
```

## 3. é…ç½®éªŒè¯ä¸å®‰å…¨

### 3.1 é…ç½®éªŒè¯æœºåˆ¶

#### 3.1.1 è·¯å¾„éªŒè¯
```python
def validate_paths(self) -> Dict[str, bool]:
    """éªŒè¯æ‰€æœ‰è·¯å¾„é…ç½®"""
    path_validations = {}
    
    # æ£€æŸ¥å¿…éœ€ç›®å½•
    required_paths = [
        'pdf_dir', 'output_dir', 'vector_db_dir', 'memory_db_dir'
    ]
    
    for path_name in required_paths:
        path_value = getattr(self.settings, path_name)
        path_validations[path_name] = self._validate_and_create_path(path_value)
    
    # æ£€æŸ¥å¯é€‰ç›®å½•
    optional_paths = ['md_dir', 'central_images_dir', 'web_app_dir']
    
    for path_name in optional_paths:
        path_value = getattr(self.settings, path_name)
        if path_value:
            path_validations[path_name] = self._validate_and_create_path(path_value)
        else:
            path_validations[path_name] = True  # å¯é€‰è·¯å¾„ä¸ºç©ºæ˜¯æœ‰æ•ˆçš„
    
    return path_validations

def _validate_and_create_path(self, path: str) -> bool:
    """éªŒè¯å¹¶åˆ›å»ºè·¯å¾„"""
    try:
        if not path or not path.strip():
            return False
        
        path_obj = Path(path)
        
        # è½¬æ¢ä¸ºç»å¯¹è·¯å¾„
        if not path_obj.is_absolute():
            path_obj = Path.cwd() / path
        
        # å¦‚æœè·¯å¾„ä¸å­˜åœ¨ï¼Œå°è¯•åˆ›å»º
        if not path_obj.exists():
            try:
                path_obj.mkdir(parents=True, exist_ok=True)
                logger.info(f"åˆ›å»ºç›®å½•: {path_obj}")
            except Exception as e:
                logger.error(f"åˆ›å»ºç›®å½•å¤±è´¥: {path_obj}, é”™è¯¯: {str(e)}")
                return False
        
        return True
        
    except Exception as e:
        logger.error(f"è·¯å¾„éªŒè¯å¤±è´¥: {path}, é”™è¯¯: {str(e)}")
        return False
```

#### 3.1.2 å‚æ•°éªŒè¯
```python
def validate_parameters(self) -> Dict[str, bool]:
    """éªŒè¯å‚æ•°é…ç½®"""
    param_validations = {}
    
    # éªŒè¯åˆ†å—å‚æ•°
    param_validations['chunk_size'] = (
        isinstance(self.settings.chunk_size, int) and 
        self.settings.chunk_size > 0
    )
    
    param_validations['chunk_overlap'] = (
        isinstance(self.settings.chunk_overlap, int) and
        0 <= self.settings.chunk_overlap < self.settings.chunk_size
    )
    
    # éªŒè¯å‘é‡å­˜å‚¨å‚æ•°
    param_validations['vector_dimension'] = (
        isinstance(self.settings.vector_dimension, int) and
        self.settings.vector_dimension > 0
    )
    
    param_validations['similarity_top_k'] = (
        isinstance(self.settings.similarity_top_k, int) and
        self.settings.similarity_top_k > 0
    )
    
    # éªŒè¯æ¨¡å‹å‚æ•°
    param_validations['temperature'] = (
        isinstance(self.settings.temperature, (int, float)) and
        0.0 <= self.settings.temperature <= 1.0
    )
    
    param_validations['max_tokens'] = (
        isinstance(self.settings.max_tokens, int) and
        self.settings.max_tokens > 0
    )
    
    return param_validations
```

### 3.2 é…ç½®å®‰å…¨

#### 3.2.1 æ•æ„Ÿä¿¡æ¯ä¿æŠ¤
```python
def sanitize_config_for_display(self) -> dict:
    """æ¸…ç†æ•æ„Ÿé…ç½®ä¿¡æ¯ç”¨äºæ˜¾ç¤º"""
    config_copy = self.settings.__dict__.copy()
    
    # éšè—æ•æ„Ÿä¿¡æ¯
    sensitive_fields = ['dashscope_api_key', 'mineru_api_key']
    
    for field in sensitive_fields:
        if field in config_copy:
            value = config_copy[field]
            if value and value != 'ä½ çš„APIKEY':
                config_copy[field] = '***' + value[-4:] if len(value) > 4 else '***'
            else:
                config_copy[field] = 'æœªé…ç½®'
    
    return config_copy

def get_api_key_status(self) -> Dict[str, bool]:
    """è·å–APIå¯†é’¥çŠ¶æ€"""
    return {
        'dashscope': bool(self.settings.dashscope_api_key and 
                         self.settings.dashscope_api_key != 'ä½ çš„APIKEY'),
        'mineru': bool(self.settings.mineru_api_key and 
                      self.settings.mineru_api_key != 'ä½ çš„APIKEY')
    }
```

## 4. é…ç½®ç¼–è¾‘å™¨å®ç°

### 4.1 äº¤äº’å¼é…ç½®ç¼–è¾‘ (V501_config_editor.py)

#### 4.1.1 ç¼–è¾‘å™¨æ¶æ„
```python
class ConfigEditor:
    """é…ç½®ç¼–è¾‘å™¨"""
    
    def __init__(self, config_file: str = 'config.json'):
        self.config_file = config_file
        self.config_manager = ConfigManager(config_file)
    
    def show_menu(self):
        """æ˜¾ç¤ºä¸»èœå•"""
        print("\n" + "="*50)
        print("RAGç³»ç»Ÿé…ç½®ç¼–è¾‘å™¨")
        print("="*50)
        print("1. æŸ¥çœ‹å½“å‰é…ç½®")
        print("2. ä¿®æ”¹è·¯å¾„é…ç½®")
        print("3. ä¿®æ”¹å¤„ç†é…ç½®")
        print("4. ä¿®æ”¹å‘é‡å­˜å‚¨é…ç½®")
        print("5. ä¿®æ”¹é—®ç­”ç³»ç»Ÿé…ç½®")
        print("6. ä¿®æ”¹è®°å¿†é…ç½®")
        print("7. ä¿®æ”¹APIé…ç½®")
        print("8. éªŒè¯é…ç½®")
        print("9. ä¿å­˜é…ç½®")
        print("0. é€€å‡º")
        print("="*50)
```

#### 4.1.2 è·¯å¾„é…ç½®ç¼–è¾‘
```python
def edit_paths(self):
    """ä¿®æ”¹è·¯å¾„é…ç½®"""
    print("\nä¿®æ”¹è·¯å¾„é…ç½®:")
    print("å½“å‰è·¯å¾„é…ç½®:")
    
    # æ˜¾ç¤ºå½“å‰è·¯å¾„
    paths = {
        'pdf_dir': 'PDFæ–‡ä»¶ç›®å½•',
        'md_dir': 'Markdownæ–‡ä»¶ç›®å½•',
        'output_dir': 'è¾“å‡ºç›®å½•',
        'vector_db_dir': 'å‘é‡æ•°æ®åº“ç›®å½•',
        'memory_db_dir': 'è®°å¿†æ•°æ®åº“ç›®å½•',
        'central_images_dir': 'ç»Ÿä¸€å›¾ç‰‡ç›®å½•',
        'web_app_dir': 'Webåº”ç”¨ç›®å½•'
    }
    
    for key, description in paths.items():
        current_value = getattr(self.config_manager.settings, key)
        print(f"  {description}: {current_value}")
    
    # é€‰æ‹©è¦ä¿®æ”¹çš„è·¯å¾„
    choice = input("\nè¯·é€‰æ‹©è¦ä¿®æ”¹çš„è·¯å¾„ (1-7, 0è¿”å›): ").strip()
    
    if choice == '0':
        return
    
    path_map = {
        '1': 'pdf_dir', '2': 'md_dir', '3': 'output_dir',
        '4': 'vector_db_dir', '5': 'memory_db_dir',
        '6': 'central_images_dir', '7': 'web_app_dir'
    }
    
    if choice in path_map:
        path_name = path_map[choice]
        current_path = getattr(self.config_manager.settings, path_name)
        
        print(f"\nå½“å‰ {path_name}: {current_path}")
        new_path = input(f"è¯·è¾“å…¥æ–°çš„ {path_name} è·¯å¾„: ").strip()
        
        if new_path:
            # éªŒè¯æ–°è·¯å¾„
            if self._validate_new_path(new_path):
                setattr(self.config_manager.settings, path_name, new_path)
                print(f"å·²æ›´æ–° {path_name} ä¸º: {new_path}")
            else:
                print("è·¯å¾„æ— æ•ˆï¼Œè¯·é‡æ–°è¾“å…¥")
    
    input("\næŒ‰å›è½¦é”®ç»§ç»­...")

def _validate_new_path(self, path: str) -> bool:
    """éªŒè¯æ–°è·¯å¾„"""
    try:
        if not path or not path.strip():
            return False
        
        path_obj = Path(path)
        
        # æ£€æŸ¥è·¯å¾„æ ¼å¼
        if path_obj.parts and '..' in path_obj.parts:
            print("è­¦å‘Š: è·¯å¾„åŒ…å« '..'ï¼Œå¯èƒ½å­˜åœ¨å®‰å…¨é£é™©")
            return False
        
        return True
        
    except Exception:
        return False
```

### 4.2 é…ç½®éªŒè¯åŠŸèƒ½

#### 4.2.1 ç»¼åˆéªŒè¯
```python
def validate_config(self):
    """éªŒè¯é…ç½®"""
    print("\néªŒè¯é…ç½®...")
    
    # è·¯å¾„éªŒè¯
    path_validations = self.config_manager.validate_paths()
    print("\nè·¯å¾„é…ç½®éªŒè¯ç»“æœ:")
    for path_name, is_valid in path_validations.items():
        status = "âœ…" if is_valid else "âŒ"
        print(f"  {status} {path_name}: {'é€šè¿‡' if is_valid else 'å¤±è´¥'}")
    
    # å‚æ•°éªŒè¯
    param_validations = self.config_manager.validate_parameters()
    print("\nå‚æ•°é…ç½®éªŒè¯ç»“æœ:")
    for param_name, is_valid in param_validations.items():
        status = "âœ…" if is_valid else "âŒ"
        print(f"  {status} {param_name}: {'é€šè¿‡' if is_valid else 'å¤±è´¥'}")
    
    # ç³»ç»ŸçŠ¶æ€éªŒè¯
    system_validations = self.config_manager.validate_system_status()
    print("\nç³»ç»ŸçŠ¶æ€éªŒè¯ç»“æœ:")
    for status_name, is_valid in system_validations.items():
        status = "âœ…" if is_valid else "âŒ"
        print(f"  {status} {status_name}: {'æ­£å¸¸' if is_valid else 'å¼‚å¸¸'}")
    
    # ç»Ÿè®¡ç»“æœ
    all_validations = {**path_validations, **param_validations, **system_validations}
    passed_count = sum(all_validations.values())
    total_count = len(all_validations)
    
    print(f"\næ€»ä½“éªŒè¯ç»“æœ: {passed_count}/{total_count} é¡¹é€šè¿‡")
    
    if passed_count == total_count:
        print("ğŸ‰ æ‰€æœ‰é…ç½®éªŒè¯é€šè¿‡ï¼")
    else:
        print("âš ï¸  å­˜åœ¨é…ç½®é—®é¢˜ï¼Œè¯·æ£€æŸ¥ä¸Šè¿°å¤±è´¥é¡¹")
    
    input("\næŒ‰å›è½¦é”®ç»§ç»­...")
```

## 5. é…ç½®ç›‘æ§ä¸å¤‡ä»½

### 5.1 é…ç½®å˜æ›´ç›‘æ§

#### 5.1.1 æ–‡ä»¶ç›‘æ§
```python
class ConfigMonitor:
    """é…ç½®ç›‘æ§å™¨"""
    
    def __init__(self, config_manager: ConfigManager):
        self.config_manager = config_manager
        self.last_modified = 0
        self.monitoring = False
    
    def start_monitoring(self):
        """å¼€å§‹ç›‘æ§é…ç½®å˜æ›´"""
        self.monitoring = True
        self._monitor_loop()
    
    def _monitor_loop(self):
        """ç›‘æ§å¾ªç¯"""
        while self.monitoring:
            try:
                current_mtime = os.path.getmtime(self.config_manager.config_file)
                
                if current_mtime != self.last_modified:
                    logger.info("æ£€æµ‹åˆ°é…ç½®æ–‡ä»¶å˜æ›´")
                    self._handle_config_change()
                    self.last_modified = current_mtime
                
                time.sleep(5)  # 5ç§’æ£€æŸ¥ä¸€æ¬¡
                
            except Exception as e:
                logger.error(f"é…ç½®ç›‘æ§é”™è¯¯: {str(e)}")
                time.sleep(10)
    
    def _handle_config_change(self):
        """å¤„ç†é…ç½®å˜æ›´"""
        try:
            # é‡æ–°åŠ è½½é…ç½®
            self.config_manager._load_config()
            
            # éªŒè¯æ–°é…ç½®
            if self.config_manager.validate_config():
                logger.info("æ–°é…ç½®éªŒè¯é€šè¿‡")
            else:
                logger.warning("æ–°é…ç½®éªŒè¯å¤±è´¥")
                
        except Exception as e:
            logger.error(f"å¤„ç†é…ç½®å˜æ›´å¤±è´¥: {str(e)}")
```

### 5.2 é…ç½®å¤‡ä»½ä¸æ¢å¤

#### 5.2.1 è‡ªåŠ¨å¤‡ä»½
```python
def create_backup(self) -> str:
    """åˆ›å»ºé…ç½®å¤‡ä»½"""
    try:
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        backup_file = f"{self.config_file}.backup_{timestamp}"
        
        # å¤åˆ¶é…ç½®æ–‡ä»¶
        import shutil
        shutil.copy2(self.config_file, backup_file)
        
        logger.info(f"é…ç½®å¤‡ä»½åˆ›å»ºæˆåŠŸ: {backup_file}")
        return backup_file
        
    except Exception as e:
        logger.error(f"é…ç½®å¤‡ä»½å¤±è´¥: {str(e)}")
        return ""

def restore_from_backup(self, backup_file: str) -> bool:
    """ä»å¤‡ä»½æ¢å¤é…ç½®"""
    try:
        if not os.path.exists(backup_file):
            logger.error(f"å¤‡ä»½æ–‡ä»¶ä¸å­˜åœ¨: {backup_file}")
            return False
        
        # åˆ›å»ºå½“å‰é…ç½®çš„å¤‡ä»½
        current_backup = self.create_backup()
        
        # æ¢å¤é…ç½®
        import shutil
        shutil.copy2(backup_file, self.config_file)
        
        # é‡æ–°åŠ è½½é…ç½®
        self.config_manager._load_config()
        
        logger.info(f"é…ç½®æ¢å¤æˆåŠŸ: {backup_file}")
        return True
        
    except Exception as e:
        logger.error(f"é…ç½®æ¢å¤å¤±è´¥: {str(e)}")
        return False
```

## 6. å…³é”®æŠ€æœ¯ç‚¹æ€»ç»“

### 6.1 é…ç½®ç®¡ç†
- **åˆ†å±‚æ¶æ„**: é…ç½®æ–‡ä»¶ã€ç®¡ç†å™¨ã€éªŒè¯å™¨åˆ†ç¦»
- **ç±»å‹å®‰å…¨**: é€šè¿‡ç±»å°è£…ç¡®ä¿é…ç½®ç±»å‹æ­£ç¡®
- **è‡ªåŠ¨éªŒè¯**: é…ç½®åŠ è½½æ—¶è‡ªåŠ¨éªŒè¯æœ‰æ•ˆæ€§

### 6.2 é…ç½®å®‰å…¨
- **æ•æ„Ÿä¿¡æ¯ä¿æŠ¤**: APIå¯†é’¥ç­‰æ•æ„Ÿä¿¡æ¯éšè—æ˜¾ç¤º
- **è·¯å¾„éªŒè¯**: é˜²æ­¢æ¶æ„è·¯å¾„æ³¨å…¥
- **å¤‡ä»½æ¢å¤**: é…ç½®å˜æ›´å‰è‡ªåŠ¨å¤‡ä»½

### 6.3 ç”¨æˆ·ä½“éªŒ
- **äº¤äº’å¼ç¼–è¾‘**: å‘½ä»¤è¡Œç•Œé¢é…ç½®ç¼–è¾‘
- **å®æ—¶éªŒè¯**: é…ç½®ä¿®æ”¹åç«‹å³éªŒè¯
- **å‹å¥½æç¤º**: æ¸…æ™°çš„é”™è¯¯ä¿¡æ¯å’Œæ“ä½œæŒ‡å¯¼

### 6.4 å¯ç»´æŠ¤æ€§
- **æ¨¡å—åŒ–è®¾è®¡**: é…ç½®ç®¡ç†åŠŸèƒ½æ¨¡å—åŒ–
- **æ—¥å¿—è®°å½•**: å®Œå–„çš„é…ç½®æ“ä½œæ—¥å¿—
- **é”™è¯¯å¤„ç†**: å¥å£®çš„é”™è¯¯å¤„ç†æœºåˆ¶

## 7. ä¸V2ç‰ˆæœ¬çš„å¯¹æ¯”

### 7.1 æ¶æ„å·®å¼‚
- **V1**: åŸºäºç±»çš„é…ç½®ç®¡ç†ï¼ŒJSONæ–‡ä»¶å­˜å‚¨
- **V2**: åŸºäºdataclassçš„é…ç½®ç®¡ç†ï¼Œæ”¯æŒåŠ¨æ€é…ç½®

### 7.2 åŠŸèƒ½å·®å¼‚
- **V1**: åŸºç¡€é…ç½®éªŒè¯å’Œç¼–è¾‘åŠŸèƒ½
- **V2**: é«˜çº§é…ç½®ç®¡ç†ã€ç›‘æ§ã€å®¡è®¡åŠŸèƒ½

### 7.3 æ‰©å±•æ€§å·®å¼‚
- **V1**: ç›¸å¯¹å›ºå®šçš„é…ç½®ç»“æ„
- **V2**: é«˜åº¦å¯æ‰©å±•çš„é…ç½®æ¶æ„

è€ç‰ˆæœ¬ç³»ç»Ÿçš„é…ç½®ç®¡ç†ä¸ºV2ç‰ˆæœ¬æä¾›äº†é‡è¦çš„è®¾è®¡æ€è·¯å’Œå®ç°ç»éªŒï¼Œå…¶ç®€å•æœ‰æ•ˆçš„é…ç½®ç®¡ç†æ–¹å¼ä»ç„¶å€¼å¾—å€Ÿé‰´ã€‚
