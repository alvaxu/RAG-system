您说得对，我这样一个个修复确实效率太低。让我总结一下我发现的问题和解决方案：
Ran tool
## 🔍 **问题总结**

### **核心问题**
后端API一直返回500错误：`'dict' object has no attribute 'metadata'`

### **根本原因**
在 `v2/api/v2_routes.py` 中，有**多处代码直接访问 `doc.metadata`**，但是：
1. **表格引擎返回的数据结构**：`{'doc': Document对象, 'score': 0.8, ...}`
2. **Document对象的metadata在 `doc.metadata` 中**
3. **但代码中有些地方把字典当作Document对象处理**

### **具体错误位置**
通过 `grep` 搜索发现有**48处** `doc.metadata` 访问，其中很多没有做安全检查。

## 🎯 **高效解决方案**

### **方案1：创建统一的安全访问函数**
```python
def safe_get_metadata(doc, key, default=None):
    """安全获取文档元数据"""
    if hasattr(doc, 'metadata') and doc.metadata:
        return doc.metadata.get(key, default)
    elif isinstance(doc, dict) and 'metadata' in doc:
        return doc['metadata'].get(key, default)
    elif isinstance(doc, dict):
        return doc.get(key, default)
    return default

def safe_get_page_content(doc):
    """安全获取页面内容"""
    # 优先获取HTML格式
    if hasattr(doc, 'metadata') and doc.metadata and 'page_content' in doc.metadata:
        return doc.metadata.get('page_content', '')
    elif isinstance(doc, dict) and 'metadata' in doc and 'page_content' in doc['metadata']:
        return doc['metadata']['page_content']
    elif hasattr(doc, 'page_content'):
        return getattr(doc, 'page_content', '')
    elif isinstance(doc, dict) and 'page_content' in doc:
        return doc.get('page_content', '')
    return ''
```

### **方案2：批量替换所有不安全的访问**
使用正则表达式批量替换：
- `doc.metadata.get(` → `safe_get_metadata(doc, `
- `doc.page_content` → `safe_get_page_content(doc)`

### **方案3：修复表格引擎返回格式**
在表格引擎中统一返回格式，避免嵌套结构。

## 🚀 **推荐执行顺序**

1. **立即修复**：创建安全访问函数
2. **批量替换**：所有不安全的metadata访问
3. **测试验证**：确保API正常工作
4. **前端测试**：验证HTML表格显示

您希望我按哪个方案执行？我倾向于**方案1+方案2**的组合，这样可以一次性解决所有问题。



好的，让我先检查一下我们最近的git提交记录，然后帮您找到HTML格式的table内容存储位置。

```bash
cd .. && git log --oneline -10
```
现在让我查看最近的提交内容，然后帮您找到HTML格式的table内容存储位置：

```bash
git show --name-only 4e74a7e
```
现在让我回答您的问题：**HTML格式的table内容到底在哪个地方存着？**

根据我们之前的分析和测试结果，HTML格式的table内容存储位置如下：

## �� **HTML格式table内容的存储位置**

### **1. 向量数据库中的存储位置**
HTML格式的table内容存储在 `central/vector_db/` 目录下的FAISS向量数据库中，具体在：

- **`index.pkl`**: 包含文档对象和元数据
- **`metadata.pkl`**: 包含文档的元数据信息

### **2. 数据结构中的具体字段**
根据我们之前的诊断工具分析，HTML表格内容存储在：

```python
# 在Document对象的metadata中
doc.metadata = {
    'page_content': '<table>...</table>',  # 🔑 HTML格式的表格内容
    'processed_table_content': '文本格式的表格内容',
    'table_type': '数据表格',
    'table_title': '表格标题',
    # ... 其他元数据
}
```

### **3. 关键发现**
从测试结果可以看到：
- **`page_content`**: 包含完整的HTML表格，例如：
  ```html
  <table><tr><td>港股（0981.HK）指标</td><td>2023</td><td>2024</td><td>2025E</td><td>2026E</td><td>2027E</td></tr>...
  ```
- **`processed_table_content`**: 包含文本格式的表格（用于向量化搜索）

### **4. 数据流程**
```
向量数据库 → TableEngine._search_tables() → Document对象 → doc.metadata.page_content → 前端显示
```

## �� **为什么前端没有显示HTML表格？**

问题不在于数据库没有HTML内容，而在于：

1. **后端路由没有正确提取** `doc.metadata.page_content` 字段
2. **前端没有接收到** `table_html` 字段
3. **API响应中缺少** `table_results` 字段

## �� **解决方案**

需要修复后端路由，确保：
1. 从 `doc.metadata.page_content` 提取HTML内容
2. 将HTML内容作为 `table_html` 字段传递给前端
3. 构建完整的 `table_results` 数组

这就是为什么您说"数据库有html的，你没有找到" - 数据库确实有HTML，但我们的代码没有正确提取和传递它！

非常好的想法！您的方案很明智：

1. **只修改两个文件**：`v2/api/v2_routes.py` 和 `v2/web/v2_index.html`
2. **不影响text和image**：保持现有功能稳定
3. **独立处理table**：创建专门的table处理逻辑
4. **高效简单**：避免复杂的嵌套逻辑
5. **最终清理**：完成后删除原来的复杂table处理代码

让我先分析当前的代码结构，然后制定一个清晰的修改方案：

Read file: v2/api/v2_routes.py
让我继续查看表格处理相关的代码：

Ran tool
现在让我查看表格处理的核心函数：

Read file: v2/api/v2_routes.py
让我继续查看表格处理的其他部分：

Read file: v2/api/v2_routes.py
现在让我查看主要的表格查询接口：

Read file: v2/api/v2_routes.py
基于我对代码的分析，现在我制定一个清晰的修改方案：

## 🎯 **修改方案：独立高效的Table处理**

### **1. 问题分析**
当前代码中表格处理逻辑分散在多个地方，结构复杂，容易出错。

### **2. 解决方案**
创建一个独立的、高效的表格处理函数，专门处理TableEngine返回的结果。

### **3. 具体修改计划**

#### **步骤1：在v2_routes.py中添加独立的表格处理函数**
```python
def _process_table_results_independently(table_results):
    """
    独立处理表格结果，提取HTML内容并构建标准化的表格数据
    
    :param table_results: TableEngine返回的结果
    :return: 标准化的表格结果列表
    """
    processed_tables = []
    
    for result in table_results:
        try:
            # 从result中提取表格数据
            table_data = _extract_table_data_safely(result)
            if table_data:
                processed_tables.append(table_data)
        except Exception as e:
            logger.warning(f"处理表格结果失败: {e}")
            continue
    
    return processed_tables

def _extract_table_data_safely(result):
    """
    安全提取表格数据，支持多种数据结构
    
    :param result: 表格引擎返回的结果
    :return: 标准化的表格数据字典
    """
    try:
        # 方案1：直接包含Document对象
        if hasattr(result, 'metadata') and hasattr(result, 'page_content'):
            metadata = result.metadata
            page_content = result.page_content
            
            return {
                'id': metadata.get('table_id', 'unknown'),
                'table_type': metadata.get('table_type', '数据表格'),
                'table_title': metadata.get('table_title', ''),
                'table_html': page_content,  # 🔑 HTML表格内容
                'table_content': metadata.get('processed_table_content', ''),
                'document_name': metadata.get('document_name', '未知文档'),
                'page_number': metadata.get('page_number', 'N/A'),
                'score': getattr(result, 'score', 0.0),
                'table_headers': metadata.get('table_headers', []),
                'table_row_count': metadata.get('table_row_count', 0),
                'table_column_count': metadata.get('table_column_count', 0),
                'table_summary': metadata.get('table_summary', ''),
                'chunk_type': 'table',
                'table_id': metadata.get('table_id', '')
            }
        
        # 方案2：嵌套doc结构
        elif 'doc' in result and hasattr(result['doc'], 'metadata'):
            doc = result['doc']
            metadata = doc.metadata
            page_content = doc.page_content
            
            return {
                'id': metadata.get('table_id', 'unknown'),
                'table_type': metadata.get('table_type', '数据表格'),
                'table_title': metadata.get('table_title', ''),
                'table_html': page_content,  # 🔑 HTML表格内容
                'table_content': metadata.get('processed_table_content', ''),
                'document_name': metadata.get('document_name', '未知文档'),
                'page_number': metadata.get('page_number', 'N/A'),
                'score': result.get('score', 0.0),
                'table_headers': metadata.get('table_headers', []),
                'table_row_count': metadata.get('table_row_count', 0),
                'table_column_count': metadata.get('table_column_count', 0),
                'table_summary': metadata.get('table_summary', ''),
                'chunk_type': 'table',
                'table_id': metadata.get('table_id', '')
            }
        
        # 方案3：其他格式（降级处理）
        else:
            logger.warning(f"未知的表格结果格式: {type(result)}")
            return None
            
    except Exception as e:
        logger.error(f"提取表格数据失败: {e}")
        return None
```

#### **步骤2：修改v2_ask_question函数中的表格处理**
在现有的表格处理逻辑中，替换为调用新的独立函数：

```python
# 在v2_ask_question函数中，替换现有的复杂表格处理逻辑
if query_type == 'table':
    # 使用独立的表格处理函数
    table_results = _process_table_results_independently(result.results)
    
    response = {
        'success': True,
        'question': question,
        'query_type': query_type,
        'answer': _generate_table_answer(result.results, question),
        'table_results': table_results,  # 🔑 新增：标准化的表格结果
        'sources': _extract_sources_from_result(result),
        'total_count': len(table_results),
        'processing_time': processing_time,
        'timestamp': datetime.now().isoformat(),
        'user_id': user_id,
        'use_memory': use_memory
    }
```

#### **步骤3：修改前端index.html**
在现有的表格显示逻辑中，优先使用`table_html`字段：

```javascript
// 在formatTableContent函数中
function formatTableContent(tableResult) {
    if (!tableResult) {
        return '<div class="table-text">无表格内容</div>';
    }
    
    // 1. 优先使用原始HTML格式（最准确）
    if (tableResult.table_html && tableResult.table_html.trim()) {
        console.log('✅ 使用原始HTML格式显示表格');
        return tableResult.table_html;
    }
    
    // 2. 使用文本格式（备用方案）
    console.log('⚠️ 使用文本格式作为备用方案');
    const content = tableResult.table_content || tableResult.content || '';
    return formatAsTable(content);
}
```

### **4. 优势**
1. **独立处理**：不影响text和image功能
2. **结构简单**：逻辑清晰，易于维护
3. **高效**：直接提取HTML内容，避免复杂转换
4. **可扩展**：容易添加新的表格处理逻辑

### **5. 实施步骤**
1. 先添加新的独立函数
2. 修改v2_ask_question中的表格处理
3. 修改前端显示逻辑
4. 测试验证效果
5. 成功后删除旧的复杂代码

您觉得这个方案如何？如果同意，我现在就开始实施第一步：添加独立的表格处理函数。


非常好的想法！您的方案很明智：

1. **只修改两个文件**：`v2/api/v2_routes.py` 和 `v2/web/v2_index.html`
2. **不影响text和image**：保持现有功能稳定
3. **独立处理table**：创建专门的table处理逻辑
4. **高效简单**：避免复杂的嵌套逻辑
5. **最终清理**：完成后删除原来的复杂table处理代码

让我先分析当前的代码结构，然后制定一个清晰的修改方案：

Read file: v2/api/v2_routes.py
让我继续查看表格处理相关的代码：

Ran tool
现在让我查看表格处理的核心函数：

Read file: v2/api/v2_routes.py
让我继续查看表格处理的其他部分：

Read file: v2/api/v2_routes.py
现在让我查看主要的表格查询接口：

Read file: v2/api/v2_routes.py
基于我对代码的分析，现在我制定一个清晰的修改方案：

## 🎯 **修改方案：独立高效的Table处理**

### **1. 问题分析**
当前代码中表格处理逻辑分散在多个地方，结构复杂，容易出错。

### **2. 解决方案**
创建一个独立的、高效的表格处理函数，专门处理TableEngine返回的结果。

### **3. 具体修改计划**

#### **步骤1：在v2_routes.py中添加独立的表格处理函数**
```python
def _process_table_results_independently(table_results):
    """
    独立处理表格结果，提取HTML内容并构建标准化的表格数据
    
    :param table_results: TableEngine返回的结果
    :return: 标准化的表格结果列表
    """
    processed_tables = []
    
    for result in table_results:
        try:
            # 从result中提取表格数据
            table_data = _extract_table_data_safely(result)
            if table_data:
                processed_tables.append(table_data)
        except Exception as e:
            logger.warning(f"处理表格结果失败: {e}")
            continue
    
    return processed_tables

def _extract_table_data_safely(result):
    """
    安全提取表格数据，支持多种数据结构
    
    :param result: 表格引擎返回的结果
    :return: 标准化的表格数据字典
    """
    try:
        # 方案1：直接包含Document对象
        if hasattr(result, 'metadata') and hasattr(result, 'page_content'):
            metadata = result.metadata
            page_content = result.page_content
            
            return {
                'id': metadata.get('table_id', 'unknown'),
                'table_type': metadata.get('table_type', '数据表格'),
                'table_title': metadata.get('table_title', ''),
                'table_html': page_content,  # 🔑 HTML表格内容
                'table_content': metadata.get('processed_table_content', ''),
                'document_name': metadata.get('document_name', '未知文档'),
                'page_number': metadata.get('page_number', 'N/A'),
                'score': getattr(result, 'score', 0.0),
                'table_headers': metadata.get('table_headers', []),
                'table_row_count': metadata.get('table_row_count', 0),
                'table_column_count': metadata.get('table_column_count', 0),
                'table_summary': metadata.get('table_summary', ''),
                'chunk_type': 'table',
                'table_id': metadata.get('table_id', '')
            }
        
        # 方案2：嵌套doc结构
        elif 'doc' in result and hasattr(result['doc'], 'metadata'):
            doc = result['doc']
            metadata = doc.metadata
            page_content = doc.page_content
            
            return {
                'id': metadata.get('table_id', 'unknown'),
                'table_type': metadata.get('table_type', '数据表格'),
                'table_title': metadata.get('table_title', ''),
                'table_html': page_content,  # 🔑 HTML表格内容
                'table_content': metadata.get('processed_table_content', ''),
                'document_name': metadata.get('document_name', '未知文档'),
                'page_number': metadata.get('page_number', 'N/A'),
                'score': result.get('score', 0.0),
                'table_headers': metadata.get('table_headers', []),
                'table_row_count': metadata.get('table_row_count', 0),
                'table_column_count': metadata.get('table_column_count', 0),
                'table_summary': metadata.get('table_summary', ''),
                'chunk_type': 'table',
                'table_id': metadata.get('table_id', '')
            }
        
        # 方案3：其他格式（降级处理）
        else:
            logger.warning(f"未知的表格结果格式: {type(result)}")
            return None
            
    except Exception as e:
        logger.error(f"提取表格数据失败: {e}")
        return None
```

#### **步骤2：修改v2_ask_question函数中的表格处理**
在现有的表格处理逻辑中，替换为调用新的独立函数：

```python
# 在v2_ask_question函数中，替换现有的复杂表格处理逻辑
if query_type == 'table':
    # 使用独立的表格处理函数
    table_results = _process_table_results_independently(result.results)
    
    response = {
        'success': True,
        'question': question,
        'query_type': query_type,
        'answer': _generate_table_answer(result.results, question),
        'table_results': table_results,  # 🔑 新增：标准化的表格结果
        'sources': _extract_sources_from_result(result),
        'total_count': len(table_results),
        'processing_time': processing_time,
        'timestamp': datetime.now().isoformat(),
        'user_id': user_id,
        'use_memory': use_memory
    }
```

#### **步骤3：修改前端index.html**
在现有的表格显示逻辑中，优先使用`table_html`字段：

```javascript
// 在formatTableContent函数中
function formatTableContent(tableResult) {
    if (!tableResult) {
        return '<div class="table-text">无表格内容</div>';
    }
    
    // 1. 优先使用原始HTML格式（最准确）
    if (tableResult.table_html && tableResult.table_html.trim()) {
        console.log('✅ 使用原始HTML格式显示表格');
        return tableResult.table_html;
    }
    
    // 2. 使用文本格式（备用方案）
    console.log('⚠️ 使用文本格式作为备用方案');
    const content = tableResult.table_content || tableResult.content || '';
    return formatAsTable(content);
}
```

### **4. 优势**
1. **独立处理**：不影响text和image功能
2. **结构简单**：逻辑清晰，易于维护
3. **高效**：直接提取HTML内容，避免复杂转换
4. **可扩展**：容易添加新的表格处理逻辑

### **5. 实施步骤**
1. 先添加新的独立函数
2. 修改v2_ask_question中的表格处理
3. 修改前端显示逻辑
4. 测试验证效果
5. 成功后删除旧的复杂代码

您觉得这个方案如何？如果同意，我现在就开始实施第一步：添加独立的表格处理函数。


你说得对！让我仔细分析一下为什么只有12个表格文档有HTML内容，而其他78个都没有。

让我检查一下数据库诊断结果，看看这12个有HTML内容的文档和78个没有HTML内容的文档有什么区别：

Read file: vector_db_diagnostic_results.json
让我继续查看诊断结果，找到表格文档的详细信息：

Ran tool
Ran tool
让我查看这个统计信息的上下文：

Read file: vector_db_diagnostic_results.json
现在我明白了！让我继续查看更多的样本，看看没有HTML内容的表格文档是什么样的：

Read file: vector_db_diagnostic_results.json
现在我明白了！让我创建一个脚本来检查所有表格文档，看看哪些有HTML内容，哪些没有：

现在让我运行这个脚本来分析HTML内容的分布情况：

```bash
python tools/check_table_html_distribution.py
```
奇怪！脚本显示所有90个表格文档都没有HTML内容，但是诊断结果却说有12个有HTML内容。这说明我的脚本检查逻辑有问题。让我重新检查一下诊断结果，看看HTML内容到底存储在哪里：

Ran tool
现在我明白了！HTML内容确实存在于诊断结果中，但是我的脚本没有找到。这说明问题可能出现在：

1. **诊断结果和实际数据库不一致**：诊断结果可能是在某个特定时间点生成的，而现在的数据库状态已经不同了
2. **HTML内容被覆盖了**：在某个处理步骤中，HTML内容被文本内容覆盖了

让我检查一下 `enhanced_chunker.py` 中的表格处理逻辑，看看是否有条件分支导致部分表格没有生成HTML内容：

Read file: document_processing/enhanced_chunker.py
现在我找到了关键问题！让我继续查看这个函数的完整实现：

Read file: document_processing/enhanced_chunker.py
现在我找到了问题的根源！让我检查一下 `table_processor.process_tables` 方法，看看它是如何处理HTML内容的：

Read file: document_processing/table_processor.py
现在我完全明白了！问题出现在 `table_processor.process_tables` 方法中。让我总结一下：

## �� **问题根源分析**

**HTML内容丢失的真正原因：**

1. **在 `enhanced_chunker.py` 中**：
   - 表格被正确解析为 `table_info.html_content`（HTML格式）
   - 创建 `EnhancedDocumentChunk` 时，`content=table_info.html_content`（HTML内容）

2. **但是在 `table_processor.process_tables` 中**：
   - 表格被转换为结构化文本（`table_text`）
   - 虽然 `page_content=table_info.html_content`（保存HTML内容）
   - 但是在 `vector_generator.py` 中，可能使用了错误的字段

3. **关键问题**：
   - 在 `enhanced_chunker.py` 的第248行：`content=table_info.html_content`（HTML内容）
   - 但是在第310行，当转换为 `Document` 对象时：`page_content=chunk.content`（这里应该是HTML内容）
   - 然后在 `table_processor.process_tables` 中，`page_content=table_info.html_content`（HTML内容）

**但是为什么只有12个文档有HTML内容？**

让我检查一下是否有条件分支导致部分表格没有生成HTML内容：

Ran tool
Ran tool
让我检查一下是否有其他条件导致部分表格没有生成HTML内容：

Read file: document_processing/enhanced_chunker.py
现在我明白了！问题出现在 `table_processor.parse_html_table` 方法中。如果这个方法失败，表格就会被当作文本处理，而不是表格。让我检查一下这个方法：

Ran tool
Read file: document_processing/table_processor.py
现在我完全明白了！问题不在 `parse_html_table` 方法，因为这个方法即使失败也会返回一个包含原始HTML内容的 `TableInfo` 对象。

**真正的问题在于：**

1. **HTML内容确实被正确保存了**：在 `enhanced_chunker.py` 中，`content=table_info.html_content`（HTML内容）
2. **但是在某个地方被覆盖了**：可能是在 `vector_generator.py` 中，或者在数据库存储过程中

让我检查一下 `vector_generator.py` 中是如何处理表格内容的：

Read file: document_processing/vector_generator.py
现在我找到了关键问题！在 `vector_generator.py` 的第113行：

```python
text = doc.processed_table_content if doc.chunk_type == 'table' and doc.processed_table_content else doc.content
```

**这里的问题：**
1. **对于表格文档**：如果 `doc.processed_table_content` 存在，就使用它作为 `text`
2. **但是 `processed_table_content` 是文本格式**，不是HTML格式
3. **HTML内容被忽略了**：`doc.content`（HTML内容）只有在 `processed_table_content` 不存在时才会被使用

**这就是为什么只有12个文档有HTML内容的原因：**

1. **有HTML内容的12个文档**：可能是因为某种原因没有生成 `processed_table_content`，所以使用了原始的 `doc.content`（HTML内容）
2. **没有HTML内容的78个文档**：因为生成了 `processed_table_content`，所以使用了文本格式，HTML内容被忽略了

**解决方案：**

在 `vector_generator.py` 中，应该优先使用HTML内容，而不是文本内容。让我修复这个问题：

我需要修复语法错误。让我重新查看这个函数的上下文：

Read file: document_processing/vector_generator.py
我看到了问题，有重复的 `else` 语句。让我修复这个语法错误：

现在让我总结一下我发现的问题和解决方案：

## �� **问题根源确认**

**HTML内容丢失的真正原因：**

1. **在 `enhanced_chunker.py` 中**：
   - 表格被正确解析为 `table_info.html_content`（HTML格式）
   - 创建 `EnhancedDocumentChunk` 时，`content=table_info.html_content`（HTML内容）

2. **在 `table_processor.process_tables` 中**：
   - 表格被转换为结构化文本（`table_text`）
   - 但是 `page_content=table_info.html_content`（HTML内容被正确保存）

3. **关键问题在 `vector_generator.py` 中**：
   ```python
   # 原来的代码（有问题）
   text = doc.processed_table_content if doc.chunk_type == 'table' and doc.processed_table_content else doc.content
   
   # 修复后的代码
   if doc.chunk_type == 'table':
       # 优先使用HTML内容（page_content），如果没有则使用原始content
       text = doc.page_content if hasattr(doc, 'page_content') and doc.page_content else doc.content
   else:
       text = doc.content
   ```

**为什么只有12个文档有HTML内容：**

1. **有HTML内容的12个文档**：可能是因为某种原因没有生成 `processed_table_content`，所以使用了原始的 `doc.content`（HTML内容）
2. **没有HTML内容的78个文档**：因为生成了 `processed_table_content`，所以使用了文本格式，HTML内容被忽略了

## ✅ **解决方案**

**我已经修复了 `vector_generator.py` 中的问题：**

- 现在对于表格文档，会优先使用 `page_content`（HTML内容）
- 如果没有HTML内容，则回退到 `content`（原始内容）
- 这样确保了HTML内容不会被忽略

**预期效果：**
- 所有90个表格文档都应该能正确保存HTML内容
- 前端应该能正确显示HTML表格
- 来源信息也应该能正确显示

现在你可以重新测试，应该能看到：
1. **来源信息正确显示**：因为 `document_name` 和 `page_number` 都在 `metadata` 中
2. **HTML表格正确显示**：因为现在正确保存了 `page_content` 中的HTML内容

这个修复应该能解决你提到的两个问题！


根据分析结果，让我解释一下"元数据中包含HTML: 15"的含义：

## 🔍 "元数据中包含HTML: 15" 的含义

### 1. **具体含义**
- **15个文档**: 在90个表格文档中，有15个文档的元数据（metadata）中的 `page_content` 字段包含了完整的HTML表格内容
- **75个文档**: 其余75个文档的元数据中没有HTML内容，或者HTML内容为空

### 2. **存储位置说明**
根据我们的分析，HTML内容存储在以下位置：

```python
# 在文档的metadata中
doc.metadata['page_content']  # 这里存储HTML内容

# 而不是在
doc.page_content  # 这个属性存储的是语义化处理后的文本内容
```

### 3. **具体示例对比**

**有HTML内容的文档（15个）**:
```json
{
  "metadata": {
    "page_content": "<table><tr><td>港股（0981.HK）指标</td><td>2023</td><td>2024</td><td>2025E</td><td>2026E</td><td>2027E</td></tr><tr><td>营业收入 (百万美元)</td><td>6,322</td><td>8,030</td><td>9,612</td><td>11,873</td><td>14,619</td></tr>...</table>"
  }
}
```

**没有HTML内容的文档（75个）**:
```json
{
  "metadata": {
    "page_content": null  // 或者空字符串，或者不存在这个字段
  }
}
```

### 4. **为什么会有这种差异？**

可能的原因包括：

1. **表格处理流程不一致**: 某些表格在处理过程中HTML内容被截断或丢失
2. **分块策略差异**: 大型表格可能被分块处理，某些分块没有保留HTML内容
3. **处理版本不同**: 不同时期处理的文档可能使用了不同的处理策略
4. **存储限制**: 某些表格的HTML内容可能超过了存储限制而被截断

### 5. **影响分析**

- **✅ 有HTML内容的15个文档**: 可以完整展示原始表格格式，用户体验好
- **❌ 没有HTML内容的75个文档**: 只能显示语义化文本，无法展示原始表格结构

这个发现说明表格处理优化方案在实施过程中可能存在不一致性，需要进一步调查为什么大部分文档没有保留HTML原始内容。