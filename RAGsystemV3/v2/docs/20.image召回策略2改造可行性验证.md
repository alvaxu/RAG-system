好的，我完全理解您的要求。在修改源代码之前，我们需要先进行全面的测试验证。让我制定一个详细的工作方案。

## **工作方案：策略2改造可行性验证**

### **阶段1：技术可行性验证**

#### **1.1 验证multimodal-embedding-one-peace-v1的文本输入能力**
- **测试目标**：确认multimodal-embedding-one-peace-v1能否接受文本输入并生成向量
- **测试方法**：调用API，传入纯文本查询，检查是否返回向量
- **预期结果**：应该返回与图片向量相同维度的向量

#### **1.2 验证向量空间一致性**
- **测试目标**：确认文本生成的向量与图片向量是否在同一空间
- **测试方法**：计算文本向量与已知图片向量的相似度
- **预期结果**：相似度计算应该有意义，不是随机值

### **阶段2：FAISS功能验证**

#### **2.1 验证filter功能支持**
- **测试目标**：确认FAISS是否支持chunk_type过滤
- **测试方法**：使用filter={'chunk_type': 'image'}进行搜索
- **预期结果**：应该只返回image类型的chunks

#### **2.2 验证跨模态搜索的稳定性**
- **测试目标**：确认跨模态搜索不会导致FAISS崩溃
- **测试方法**：多次执行跨模态搜索，检查错误率
- **预期结果**：搜索应该稳定，错误率低于5%

### **阶段3：召回效果验证**

#### **3.1 策略2独立测试**
- **测试目标**：验证策略2能否找到相关图片
- **测试方法**：使用纯图片查询（无image_text chunks），测试策略2
- **预期结果**：应该能找到语义相关的图片

#### **3.2 召回融合测试**
- **测试目标**：验证image_text和image的召回融合效果
- **测试方法**：对比单独使用策略1 vs 策略1+策略2的召回结果
- **预期结果**：融合后应该提高召回率和多样性

### **阶段4：Reranking兼容性验证**

#### **4.1 验证reranking输入格式**
- **测试目标**：确认image chunks的输出格式是否与reranking兼容
- **测试方法**：检查image chunks的metadata字段是否完整
- **预期结果**：应该包含reranking所需的所有字段

#### **4.2 验证大模型reranking的适用性**
- **测试目标**：确认大模型能否处理image chunks的内容
- **测试方法**：将image chunks的metadata传递给reranking服务
- **预期结果**：reranking应该能正常处理并返回结果

## **具体测试计划**

### **测试1：multimodal-embedding-one-peace-v1文本输入测试**
```python
# 测试代码框架
def test_multimodal_text_input():
    """测试multimodal-embedding-one-peace-v1的文本输入能力"""
    try:
        # 1. 初始化multimodal embeddings
        # 2. 输入纯文本查询
        # 3. 检查返回的向量维度和质量
        # 4. 与已知图片向量进行相似度计算
        pass
    except Exception as e:
        print(f"测试失败: {e}")
```

### **测试2：FAISS filter功能测试**
```python
def test_faiss_filter_support():
    """测试FAISS的filter功能"""
    try:
        # 1. 使用filter={'chunk_type': 'image'}搜索
        # 2. 验证返回结果是否都是image类型
        # 3. 检查搜索性能
        pass
    except Exception as e:
        print(f"测试失败: {e}")
```

### **测试3：跨模态搜索稳定性测试**
```python
def test_cross_modal_search_stability():
    """测试跨模态搜索的稳定性"""
    try:
        # 1. 多次执行跨模态搜索
        # 2. 统计成功率和错误类型
        # 3. 检查内存使用和性能
        pass
    except Exception as e:
        print(f"测试失败: {e}")
```

### **测试4：召回融合效果测试**
```python
def test_recall_fusion_effect():
    """测试召回融合效果"""
    try:
        # 1. 单独使用策略1搜索
        # 2. 使用策略1+策略2搜索
        # 3. 对比召回结果的数量和质量
        # 4. 分析召回多样性
        pass
    except Exception as e:
        print(f"测试失败: {e}")
```

### **测试5：Reranking兼容性测试**
```python
def test_reranking_compatibility():
    """测试reranking的兼容性"""
    try:
        # 1. 准备image chunks的测试数据
        # 2. 调用reranking服务
        # 3. 检查处理过程和结果
        # 4. 验证输出格式
        pass
    except Exception as e:
        print(f"测试失败: {e}")
```

## **测试执行顺序**

1. **第一优先级**：multimodal-embedding-one-peace-v1文本输入测试
2. **第二优先级**：FAISS filter功能测试
3. **第三优先级**：跨模态搜索稳定性测试
4. **第四优先级**：召回融合效果测试
5. **第五优先级**：Reranking兼容性测试

## **成功标准**

- **技术可行性**：所有API调用成功，向量生成正常
- **功能完整性**：filter功能正常工作，搜索稳定
- **效果提升**：融合后召回率提升，多样性增加
- **兼容性**：与现有reranking系统完全兼容

## **风险评估**

- **低风险**：multimodal-embedding-one-peace-v1文本输入测试
- **中风险**：FAISS filter功能测试
- **中风险**：跨模态搜索稳定性测试
- **低风险**：召回融合效果测试
- **低风险**：Reranking兼容性测试

