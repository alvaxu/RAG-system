
## 📱 **前端用户查询入口和类型选择机制 - 修正版**

### 🎯1. **左侧边栏查询类型选择**

前端提供了5个主要的查询类型入口，每个都有独立的预设问题区域：

```html
<!-- 预设问题区域 -->
<div class="preset-section" data-type="smart">
    <h3 onclick="togglePresetSection(this)">🤖 智能查询</h3>
    <div class="preset-questions" id="smart-questions"></div>
</div>

<div class="preset-section" data-type="image">
    <h3 onclick="togglePresetSection(this)">🖼️ 图片查询</h3>
    <div class="preset-questions" id="image-questions"></div>
</div>

<div class="preset-section" data-type="text">
    <h3 onclick="togglePresetSection(this)">📝 文本查询</h3>
    <div class="preset-questions" id="text-questions"></div>
</div>

<div class="preset-section" data-type="table">
    <h3 onclick="togglePresetSection(this)">📊 表格查询</h3>
    <div class="preset-questions" id="table-questions"></div>
</div>

<div class="preset-section" data-type="hybrid">
    <h3 onclick="togglePresetSection(this)">🔀 混合查询</h3>
    <div class="preset-questions" id="hybrid-questions"></div>
</div>
```

### 🔄2.**查询类型切换机制**

#### **2.1 手动切换**
用户点击左侧边栏的查询类型标题，系统会：
- 关闭其他查询类型区域
- 激活当前选择的查询类型
- 显示对应的预设问题
- 更新右上角的查询类型指示器

```javascript
function togglePresetSection(header) {
    const section = header.parentElement;
    const isActive = section.classList.contains('active');
    const queryType = section.getAttribute('data-type');
    
    // 关闭其他区域
    document.querySelectorAll('.preset-section').forEach(s => {
        s.classList.remove('active');
    });
    
    // 切换当前区域
    if (!isActive) {
        section.classList.add('active');
        
        // 显示查询类型切换状态
        const typeNames = {
            'text': '文本查询',
            'image': '图片查询', 
            'table': '表格查询',
            'hybrid': '混合查询',
            'smart': '智能查询'
        };
        showStatus(`已切换到${typeNames[queryType] || queryType}模式`, 'info');
    }
}
```

#### **2.2 自动激活**
当用户点击预设问题时，系统会自动激活对应的查询类型：

```javascript
questionDiv.onclick = () => {
    // 设置问题文本
    document.getElementById('user-input').value = question;
    document.getElementById('user-input').focus();
    
    // 自动激活对应的查询类型
    activateQueryType(type);
    
    // 显示状态提示
    showStatus(`已切换到${typeNames[type] || type}模式`, 'info');
};
```

### 📚3. **预设问题加载机制**

系统会为每种查询类型加载对应的预设问题：

```javascript
async function loadPresetQuestions() {
    try {
        // 分别加载各类预设问题
        const types = ['image', 'text', 'table', 'hybrid'];
        
        for (const type of types) {
            const response = await fetch(`/api/v2/qa/preset-questions?type=${type}`);
            if (!response.ok) {
                throw new Error(`HTTP ${response.status}`);
            }
            
            const data = await response.json();
            
            // 填充对应类型的预设问题
            fillPresetQuestions(type, data.questions || []);
        }
        
        // 添加智能查询的预设问题（硬编码，因为不需要从API加载）
        const smartQuestions = [
            "请分析中芯国际的整体情况",
            "中芯国际有哪些关键优势？",
            "请总结中芯国际的发展前景",
            "中芯国际面临哪些挑战？",
            "请综合分析中芯国际的财务状况"
        ];
        fillPresetQuestions('smart', smartQuestions);
        
    } catch (error) {
        console.error('加载预设问题失败:', error);
        showStatus('加载预设问题失败', 'error');
    }
}
```

### 🚀4. **查询请求发送机制**

#### **4.1 查询类型检测**
在发送查询时，系统会检测当前激活的查询类型：

```javascript
async function sendMessage() {
    // 检测当前选择的查询类型
    let queryType = 'hybrid'; // 默认值
    
    // 检查哪个查询类型被选中
    const textSection = document.querySelector('.preset-section[data-type="text"]');
    const imageSection = document.querySelector('.preset-section[data-type="image"]');
    const tableSection = document.querySelector('.preset-section[data-type="table"]');
    const hybridSection = document.querySelector('.preset-section[data-type="hybrid"]');
    const smartSection = document.querySelector('.preset-section[data-type="smart"]');
    
    if (textSection && textSection.classList.contains('active')) {
        queryType = 'text';
        console.log('检测到文本查询模式');
    } else if (imageSection && imageSection.classList.contains('active')) {
        queryType = 'image';
        console.log('检测到图片查询模式');
    } else if (tableSection && tableSection.classList.contains('active')) {
        queryType = 'table';
        console.log('检测到表格查询模式');
    } else if (hybridSection && hybridSection.classList.contains('active')) {
        queryType = 'hybrid';
        console.log('检测到混合查询模式');
    } else if (smartSection && smartSection.classList.contains('active')) {
        queryType = 'smart';
        console.log('检测到智能查询模式');
    } else {
        // 如果没有明确选择，默认使用混合查询
        queryType = 'hybrid';
        console.log('未检测到明确的查询类型，使用默认混合查询模式');
    }
```

#### **4.2 请求参数传递**
系统会将检测到的查询类型作为参数传递给后端：

```javascript
// 使用统一的查询接口，包括智能查询
const response = await fetch('/api/v2/qa/ask', {
    method: 'POST',
    headers: {
        'Content-Type': 'application/json'
    },
    body: JSON.stringify({
        question: message,
        session_id: currentSessionId,
        query_type: queryType  // 可以是 'smart', 'image', 'text', 'table', 'hybrid'
    })
});
```

### 📱5. **用户界面反馈机制**

#### **5.1 查询类型指示器**
右上角显示当前查询模式：

```html
<div class="query-type-indicator" id="query-type-indicator" style="display: none;">
    当前模式: 混合查询
</div>
```

#### **5.2 状态提示**
系统会显示查询类型切换的状态提示：

```javascript
function updateQueryTypeIndicator(type) {
    const indicator = document.getElementById('query-type-indicator');
    if (indicator) {
        const typeNames = {
            'text': '文本查询',
            'image': '图片查询', 
            'table': '表格查询',
            'hybrid': '混合查询',
            'smart': '智能查询'
        };
        
        indicator.textContent = `当前模式: ${typeNames[type] || type}`;
        indicator.style.display = 'block';
        
        // 3秒后自动隐藏
        setTimeout(() => {
            indicator.style.display = 'none';
        }, 3000);
    }
}
```

### 🔄6. **完整流程总结**

```
用户操作 → 查询类型选择 → 预设问题展示 → 问题输入 → 查询类型检测 → 请求发送 → 后端处理
    ↓              ↓              ↓           ↓          ↓           ↓          ↓
点击侧边栏 → 激活对应类型 → 显示预设问题 → 输入问题 → 检测当前类型 → 传递query_type → 后端智能处理
```

### 7.**设计优势**

1. **直观性**：用户可以通过图标和标题清楚知道每种查询类型的用途
2. **灵活性**：支持手动切换和自动激活两种方式
3. **一致性**：每种类型都有对应的预设问题，降低用户学习成本
4. **反馈性**：实时显示当前查询模式，避免用户困惑
5. **容错性**：如果没有明确选择，默认使用混合查询模式
6. **智能化**：智能查询类型能够自动判断最佳查询方式

### 8.**当前实现状态**

- ✅ **已实现并正常工作**：图片查询、文本查询、表格查询、混合查询、智能查询
- 🔧 **技术状态**：混合查询功能已修复并测试验证通过，智能查询功能已完全实现并测试通过

---

