# RAG系统Prompt构建机制详解

## 文档说明

本文档详细描述了RAG系统V3中三种类型内容（文本、图片、表格）在reranking后如何构建Prompt并给LLM提供内容的完整机制，包括混合查询和智能查询两种处理方式。

**版本**: V3.0.0  
**更新时间**: 2025年1月  
**基于代码**: `rag_system/core/` 模块实际实现  

---

## 一、整体架构概述

### 1.1 查询处理流程

#### 1.1.1 智能查询流程
```
用户查询 → 类型检测 → 单类型/混合处理 → 多类型召回 → Reranking → 上下文构建 → Prompt生成 → LLM调用
```

#### 1.1.2 混合查询流程
```
用户查询 → 并行多类型召回 → 结果融合 → Reranking → 上下文构建 → Prompt生成 → LLM调用
```

### 1.2 核心组件

- **QueryProcessor**: 查询处理器，统一入口
- **QueryRouter**: 查询路由器，分发查询类型
- **SimpleSmartProcessor**: 智能查询处理器
- **SimpleHybridProcessor**: 混合查询处理器
- **UnifiedServices**: 统一服务接口
- **VectorDBIntegration**: 负责内容提取和格式化
- **ContextManager**: 负责上下文优化和重组
- **PromptManager**: 负责Prompt模板管理
- **LLMCaller**: 负责LLM调用和响应处理

---

## 二、三种类型内容处理机制

### 2.1 文本内容处理

#### **内容提取策略**
**位置**: `rag_system/core/vector_db_integration.py` 第200-201行

```python
elif chunk_type == 'text' and 'text' in result.metadata:
    content = result.metadata['text']
```

**提取字段**:
- 主要字段: `metadata['text']` - 原始文本内容
- 备用字段: `page_content` - 页面内容

#### **内容特点**
- **格式**: 原始文本，保持段落结构
- **用途**: 直接用于LLM理解
- **优势**: 信息完整，语义清晰

#### **实际示例**
```
文本信息：
中芯国际是中国大陆规模最大、技术最先进的集成电路晶圆代工企业，也是中国内地技术最先进、配套最完善、规模最大、跨国经营的集成电路制造企业集团。
```

### 2.2 图片内容处理

#### **内容提取策略**
**位置**: `rag_system/core/vector_db_integration.py` 第198-199行

```python
if chunk_type == 'image' and 'enhanced_description' in result.metadata:
    content = result.metadata['enhanced_description']
```

**提取字段**:
- 主要字段: `metadata['enhanced_description']` - AI增强描述
- 备用字段: `metadata['description']` - 原始描述

#### **内容特点**
- **格式**: AI生成的文本描述
- **用途**: 将图片转换为文本描述给LLM
- **优势**: 包含图片的语义信息

#### **实际示例**
```
图片信息：
- 财务趋势图表显示收入稳步增长
- 资产负债表结构图
```

### 2.3 表格内容处理（增强版）

#### **内容提取策略**
**位置**: `rag_system/core/vector_db_integration.py` 第202-204行

```python
elif chunk_type == 'table':
    # 构建增强的表格信息
    content = self._build_enhanced_table_info(result.metadata)
```

#### **增强表格信息构建**
**位置**: `rag_system/core/vector_db_integration.py` 第779-834行

```python
def _build_enhanced_table_info(self, metadata: Dict[str, Any]) -> str:
    """构建增强的表格信息"""
    table_parts = []
    
    # 1. 表格标题和说明
    table_caption = metadata.get('table_caption', [])
    if table_caption:
        table_parts.append(f"**表格标题**: {', '.join(table_caption)}")
    
    # 2. 表格结构信息
    table_summary = metadata.get('table_summary', '')
    if table_summary:
        table_parts.append(f"**表格结构**: {table_summary}")
    
    # 3. 表格内容（优先使用HTML格式）
    table_body = metadata.get('table_body', '')
    table_content = metadata.get('table_content', '')
    
    if table_body:
        table_parts.append(f"**表格内容**:\n{table_body}")
    elif table_content:
        table_parts.append(f"**表格内容**:\n{table_content}")
    
    # 4. 表格脚注
    table_footnote = metadata.get('table_footnote', [])
    if table_footnote:
        table_parts.append(f"**数据来源**: {', '.join(table_footnote)}")
    
    # 5. 表格上下文
    table_context = metadata.get('table_context', '')
    if table_context:
        table_parts.append(f"**表格上下文**: {table_context}")
    
    # 6. 子表信息（如果有）
    is_subtable = metadata.get('is_subtable', False)
    if is_subtable:
        parent_table_id = metadata.get('parent_table_id', '')
        subtable_index = metadata.get('subtable_index', '')
        table_parts.append(f"**子表信息**: 这是第{subtable_index}个子表，父表ID: {parent_table_id}")
    
    return "\n\n".join(table_parts)
```

#### **内容特点**
- **格式**: Markdown格式的增强描述，包含HTML表格
- **用途**: 提供完整的表格信息给LLM
- **优势**: 信息丰富，结构化清晰

#### **实际示例**
```
表格数据：

**表格标题**: 表6：中芯国际产线一览

**表格结构**: 表格包含 2 行 8 列数据

**表格内容**:
<table><tbody><tr><td>9</td><td></td><td>中芯南方</td><td>FAB</td><td>上海</td><td>13.5</td><td>注册资本65亿美元</td><td>14nmFinFET</td></tr><tr><td>10</td><td></td><td>中芯东方</td><td></td><td></td><td>10</td><td>在建</td><td>65nm-24nm</td></tr></tbody></table>

**数据来源**: 资料来源：青岛西海岸新区国际招商，上海证券研究所

**子表信息**: 这是第1个子表，父表ID: test_table_118
```

---

## 三、查询处理方式详解

### 3.1 智能查询处理机制

#### 3.1.1 类型检测阶段
**位置**: `rag_system/core/simple_smart_processor.py` 第45-85行

```python
def _detect_type(self, query: str) -> tuple[str, float]:
    # 图片相关关键词检测
    image_keywords = ['图片', '图像', '照片', '图表', '截图', '界面', '显示', '展示', '图标', 'logo']
    image_matches = sum(1 for keyword in image_keywords if keyword in query)
    
    # 表格相关关键词检测
    table_keywords = ['表格', '数据', '统计', '数字', '金额', '数量', '比例', '百分比', '排名', '对比', 
                    '营收', '收入', '利润', '财务', '业绩', '报告', '年报', '半年报', '季度', '预测', 
                    '趋势', '变化', '增长', '下降', '上升', '下跌', '分析', '指标', '比率']
    table_matches = sum(1 for keyword in table_keywords if keyword in query)
    
    # 文本相关特征
    text_features = len(query) > 20  # 长文本倾向于文本查询
```

#### 3.1.2 处理策略选择
- **高置信度（≥0.7）**: 使用单类型处理，针对性强
- **低置信度（<0.7）**: 回退到混合查询，覆盖面广

#### 3.1.3 单类型处理流程
**位置**: `rag_system/core/simple_smart_processor.py` 第87-130行

```python
async def process_single_type_query(self, query: str, content_type: str, options: QueryOptions) -> QueryResult:
    # 1. 内容检索
    retrieval_results = await self.unified_services.retrieve(query, [content_type], {
        'max_results': options.max_results,
        'relevance_threshold': options.relevance_threshold
    })
    
    # 2. 重排序
    reranked_results = await self.unified_services.rerank(query, retrieval_results)
    
    # 3. LLM问答生成
    answer = await self.unified_services.generate_answer(query, reranked_results)
    
    # 4. 子表合并（表格类型）
    if content_type == 'table' and self.config.get('rag_system.table_merge.enabled', True):
        merged_results = vector_db.format_search_results_with_merge(reranked_results)
        reranked_results = merged_results
```

### 3.2 混合查询处理机制

#### 3.2.1 并行检索阶段
**位置**: `rag_system/core/simple_hybrid_processor.py` 第45-65行

```python
async def process_hybrid_query(self, query: str, options: QueryOptions) -> QueryResult:
    # 并行检索所有内容类型
    retrieval_tasks = [
        self._retrieve_content_type(query, 'text', options),
        self._retrieve_content_type(query, 'image', options),
        self._retrieve_content_type(query, 'table', options)
    ]
    
    # 等待所有检索任务完成
    retrieval_results = await asyncio.gather(*retrieval_tasks, return_exceptions=True)
```

#### 3.2.2 结果融合阶段
**位置**: `rag_system/core/simple_hybrid_processor.py` 第67-120行

```python
def _fuse_and_deduplicate(self, results: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
    # 1. 按内容类型分组
    type_groups = {}
    for result in results:
        content_type = result.get('chunk_type', 'unknown')
        if content_type not in type_groups:
            type_groups[content_type] = []
        type_groups[content_type].append(result)
    
    # 2. 计算各类型的最优结果数量
    total_results = len(results)
    optimal_counts = {}
    for content_type, weight in self.content_weights.items():
        optimal_counts[content_type] = max(1, int(total_results * weight))
    
    # 3. 从各类型中选择最优结果
    fused_results = []
    for content_type, type_results in type_groups.items():
        # 按分数排序
        sorted_results = sorted(type_results, key=lambda x: x.get('score', 0.0), reverse=True)
        
        # 选择最优结果
        optimal_count = optimal_counts.get(content_type, len(sorted_results))
        selected_results = sorted_results[:optimal_count]
        
        # 为结果添加融合权重
        for result in selected_results:
            result['fusion_weight'] = self.content_weights.get(content_type, 0.3)
        
        fused_results.extend(selected_results)
    
    # 4. 去重处理（基于内容相似性）
    deduplicated_results = self._remove_duplicates(fused_results)
    
    # 5. 最终排序（基于融合权重和分数）
    final_results = sorted(deduplicated_results, 
                         key=lambda x: (x.get('fusion_weight', 0.3) * x.get('score', 0.0)), 
                         reverse=True)
    
    return final_results
```

### 3.3 统一服务接口

#### 3.3.1 检索服务
**位置**: `rag_system/core/unified_services.py` 第45-80行

```python
async def retrieve(self, query: str, content_types: List[str] = None, 
                  options: Dict[str, Any] = None) -> List[Dict[str, Any]]:
    # 根据内容类型进行检索
    if 'text' in content_types:
        text_results = self.retrieval_service.retrieve_texts(query, max_results, relevance_threshold)
        all_results.extend(text_results)
    
    if 'image' in content_types:
        image_results = self.retrieval_service.retrieve_images(query, max_results, relevance_threshold)
        all_results.extend(image_results)
    
    if 'table' in content_types:
        table_results = self.retrieval_service.retrieve_tables(query, max_results, relevance_threshold)
        all_results.extend(table_results)
```

#### 3.3.2 重排序服务
**位置**: `rag_system/core/unified_services.py` 第82-90行

```python
async def rerank(self, query: str, results: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
    # 调用多模型重排序器
    reranked_results = await self.reranking_service.rerank(query, results)
    return reranked_results
```

#### 3.3.3 LLM问答服务
**位置**: `rag_system/core/unified_services.py` 第92-100行

```python
async def generate_answer(self, query: str, results: List[Dict[str, Any]]) -> str:
    # 调用LLM服务生成答案
    answer = await self.llm_service.generate_answer(query, results)
    return answer
```

---

## 四、上下文构建机制

### 4.1 上下文管理器
**位置**: `rag_system/core/context_manager.py` 第200-242行

#### **按类型分组处理**
```python
def _reorganize_context(self, selected_chunks: List[ContextChunk], query: str) -> str:
    # 按内容类型分组
    type_groups = defaultdict(list)
    for chunk in selected_chunks:
        type_groups[chunk.content_type].append(chunk)
    
    # 构建格式化的上下文
    context_parts = []
    
    # 添加文本内容
    if 'text' in type_groups:
        text_chunks = type_groups['text']
        text_content = "\n\n".join([chunk.content for chunk in text_chunks])
        context_parts.append(f"文本信息：\n{text_content}")
    
    # 添加表格内容
    if 'table' in type_groups:
        table_chunks = type_groups['table']
        table_content = "\n\n".join([chunk.content for chunk in table_chunks])
        context_parts.append(f"表格数据：\n\n{table_content}")
    
    # 添加图片内容
    if 'image' in type_groups:
        image_chunks = type_groups['image']
        image_descriptions = []
        for chunk in image_chunks:
            desc = chunk.metadata.get('description', chunk.content)
            image_descriptions.append(f"- {desc}")
        context_parts.append(f"图片信息：\n" + "\n".join(image_descriptions))
    
    # 组合所有内容
    final_context = "\n\n".join(context_parts)
    
    # 添加上下文来源信息
    sources = list(set(chunk.source for chunk in selected_chunks))
    if sources:
        final_context += f"\n\n信息来源：{', '.join(sources)}"
    
    return final_context
```

### 4.2 长度控制机制
**位置**: `rag_system/core/context_manager.py` 第244-272行

#### **配置参数**
- **最大上下文长度**: 4000字符（可配置）
- **最大块数量**: 10个（可配置）
- **相关性阈值**: 0.7（可配置）

#### **智能截断策略**
```python
def _ensure_length_limit(self, context: str, max_length: int) -> str:
    if len(context) <= max_length:
        return context
    
    # 智能截断
    truncated_context = self._smart_truncate(context, max_length)
    
    if truncated_context:
        self.context_stats['truncation_count'] += 1
        logger.info(f"上下文已截断，从 {len(context)} 到 {len(truncated_context)} 字符")
        return truncated_context
    else:
        # 如果智能截断失败，使用简单截断
        simple_truncated = context[:max_length-100] + "..."
        self.context_stats['truncation_count'] += 1
        logger.warning("智能截断失败，使用简单截断")
        return simple_truncated
```

---

## 五、不同查询方式的Prompt构建差异

### 5.1 智能查询的Prompt构建特点

#### 5.1.1 单类型查询的Prompt构建
**特点**: 针对性强，内容类型单一，上下文更聚焦

**上下文构建策略**:
- **文本查询**: 只包含文本内容，上下文简洁
- **图片查询**: 只包含图片描述，避免其他类型干扰
- **表格查询**: 只包含表格信息，结构清晰

**Prompt示例**:
```
你是一个专业的AI助手，能够基于提供的上下文信息生成准确、相关、完整的答案。

基于以下上下文信息回答问题：

上下文：
表格数据：

**表格标题**: 表6：中芯国际产线一览

**表格结构**: 表格包含 2 行 8 列数据

**表格内容**:
<table><tbody><tr><td>9</td><td></td><td>中芯南方</td><td>FAB</td><td>上海</td><td>13.5</td><td>注册资本65亿美元</td><td>14nmFinFET</td></tr><tr><td>10</td><td></td><td>中芯东方</td><td></td><td></td><td>10</td><td>在建</td><td>65nm-24nm</td></tr></tbody></table>

**数据来源**: 资料来源：青岛西海岸新区国际招商，上海证券研究所

问题：
中芯国际的产线布局情况如何？

请提供准确、详细的答案：
```

#### 5.1.2 混合查询的Prompt构建
**特点**: 信息全面，多类型内容融合，上下文丰富

**上下文构建策略**:
- **类型分组**: 按文本、图片、表格分别组织内容
- **信息平衡**: 确保各类型内容都有合理代表性
- **结构清晰**: 使用明确的分隔符区分不同类型

**Prompt示例**:
```
你是一个专业的AI助手，能够基于提供的上下文信息生成准确、相关、完整的答案。

基于以下上下文信息回答问题：

上下文：
文本信息：
中芯国际是中国大陆规模最大、技术最先进的集成电路晶圆代工企业，也是中国内地技术最先进、配套最完善、规模最大、跨国经营的集成电路制造企业集团。

表格数据：

**表格标题**: 表6：中芯国际产线一览

**表格结构**: 表格包含 2 行 8 列数据

**表格内容**:
<table><tbody><tr><td>9</td><td></td><td>中芯南方</td><td>FAB</td><td>上海</td><td>13.5</td><td>注册资本65亿美元</td><td>14nmFinFET</td></tr><tr><td>10</td><td></td><td>中芯东方</td><td></td><td></td><td>10</td><td>在建</td><td>65nm-24nm</td></tr></tbody></table>

**数据来源**: 资料来源：青岛西海岸新区国际招商，上海证券研究所

图片信息：
- 财务趋势图表显示收入稳步增长
- 资产负债表结构图

信息来源：中芯国际研究报告.pdf, 财务分析报告.pdf

问题：
中芯国际的产线布局情况如何？

请提供准确、详细的答案：
```

### 5.2 混合查询的Prompt构建特点

#### 5.2.1 结果融合对Prompt的影响
**融合权重配置**:
```python
content_weights = {
    'text': 0.4,    # 文本内容权重40%
    'image': 0.3,   # 图片内容权重30%
    'table': 0.3    # 表格内容权重30%
}
```

**融合策略**:
- **类型平衡**: 确保各类型内容都有合理数量
- **质量优先**: 优先选择分数高的结果
- **去重处理**: 避免重复或相似内容

#### 5.2.2 上下文组织策略
**按类型分组**:
```python
# 文本内容
if 'text' in type_groups:
    text_content = "\n\n".join([chunk.content for chunk in text_chunks])
    context_parts.append(f"文本信息：\n{text_content}")

# 表格内容
if 'table' in type_groups:
    table_content = "\n\n".join([chunk.content for chunk in table_chunks])
    context_parts.append(f"表格数据：\n\n{table_content}")

# 图片内容
if 'image' in type_groups:
    image_descriptions = []
    for chunk in image_chunks:
        desc = chunk.metadata.get('description', chunk.content)
        image_descriptions.append(f"- {desc}")
    context_parts.append(f"图片信息：\n" + "\n".join(image_descriptions))
```

### 5.3 查询方式选择建议

#### 5.3.1 智能查询适用场景
- **类型明确**: 用户查询意图明确，如"显示财务数据表格"
- **效率优先**: 需要快速获得特定类型信息
- **精准回答**: 希望获得针对性的专业回答

#### 5.3.2 混合查询适用场景
- **综合分析**: 需要多角度分析复杂问题
- **信息全面**: 希望获得尽可能全面的信息
- **探索性查询**: 不确定需要什么类型的信息

#### 5.3.3 配置优化建议
```python
# 智能查询配置
smart_query_config = {
    'confidence_threshold': 0.7,  # 置信度阈值
    'max_results': 10,            # 最大结果数
    'relevance_threshold': 0.5    # 相关性阈值
}

# 混合查询配置
hybrid_query_config = {
    'content_weights': {
        'text': 0.4,
        'image': 0.3,
        'table': 0.3
    },
    'max_results': 15,            # 更多结果
    'relevance_threshold': 0.3    # 更宽松的阈值
}
```

---

## 六、Prompt构建机制

### 6.1 统一Prompt模板
**位置**: `rag_system/core/unified_services.py` 第225-257行

```python
def _build_unified_prompt(self, query: str, context: str) -> str:
    """构建统一Prompt"""
    try:
        # 获取系统提示词
        system_prompt = self.config.get_rag_config('models.llm.system_prompt', 
            '你是一个专业的AI助手，能够基于提供的上下文信息生成准确、相关、完整的答案。')
        
        # 构建完整的提示词
        prompt = f"""
{system_prompt}

基于以下上下文信息回答问题：

上下文：
{context}

问题：
{query}

请提供准确、详细的答案：
"""
        return prompt.strip()
        
    except Exception as e:
        logger.error(f"构建统一Prompt失败: {e}")
        # 返回简单的提示词
        return f"基于以下上下文信息回答问题：\n\n上下文：{context}\n\n问题：{query}"
```

### 6.2 实际发送给LLM的完整Prompt示例

```
你是一个专业的AI助手，能够基于提供的上下文信息生成准确、相关、完整的答案。

基于以下上下文信息回答问题：

上下文：
文本信息：
中芯国际是中国大陆规模最大、技术最先进的集成电路晶圆代工企业，也是中国内地技术最先进、配套最完善、规模最大、跨国经营的集成电路制造企业集团。

表格数据：

**表格标题**: 表6：中芯国际产线一览

**表格结构**: 表格包含 2 行 8 列数据

**表格内容**:
<table><tbody><tr><td>9</td><td></td><td>中芯南方</td><td>FAB</td><td>上海</td><td>13.5</td><td>注册资本65亿美元</td><td>14nmFinFET</td></tr><tr><td>10</td><td></td><td>中芯东方</td><td></td><td></td><td>10</td><td>在建</td><td>65nm-24nm</td></tr></tbody></table>

**数据来源**: 资料来源：青岛西海岸新区国际招商，上海证券研究所

图片信息：
- 财务趋势图表显示收入稳步增长
- 资产负债表结构图

信息来源：中芯国际研究报告.pdf, 财务分析报告.pdf

问题：
中芯国际的产线布局情况如何？

请提供准确、详细的答案：
```

---

## 七、技术特点与优势

### 7.1 多模态统一处理
- **文本**: 直接使用原始内容
- **图片**: 转换为AI增强描述
- **表格**: 构建增强的结构化信息

### 7.2 信息完整性
- **表格增强**: 包含标题、结构、内容、来源、上下文等完整信息
- **HTML格式**: 保留表格的结构化信息，便于LLM理解
- **层次清晰**: 使用Markdown格式，信息层次分明

### 7.3 智能优化
- **长度控制**: 智能截断，优先保留最相关内容
- **类型分离**: 不同类型内容分别处理，避免混淆
- **向后兼容**: 字段缺失时仍能正常工作

### 7.4 性能优化
- **缓存机制**: 重排序结果缓存
- **批量处理**: 支持批量上下文优化
- **错误处理**: 完善的异常处理和回退机制

---

## 八、配置参数

### 8.1 上下文管理配置
```json
{
  "rag_system": {
    "query_processing": {
      "max_context_length": 4000,
      "max_chunks": 10,
      "relevance_threshold": 0.7
    }
  }
}
```

### 8.2 LLM配置
```json
{
  "rag_system": {
    "models": {
      "llm": {
        "model_name": "qwen-turbo-latest",
        "max_tokens": 2048,
        "temperature": 0.7,
        "system_prompt": "你是一个专业的AI助手，能够基于提供的上下文信息生成准确、相关、完整的答案。"
      }
    }
  }
}
```

---

## 九、实际应用效果

### 9.1 信息丰富度提升
- **表格信息**: 从简单纯文本提升为包含标题、结构、来源等完整信息
- **图片信息**: 从无到有，提供AI增强描述
- **文本信息**: 保持原有完整性

### 9.2 LLM理解能力提升
- **结构化信息**: HTML表格提供清晰的列行关系
- **上下文信息**: 数据来源、表格说明等提供额外上下文
- **语义信息**: 图片描述提供视觉内容的语义理解

### 9.3 答案质量提升
- **准确性**: 更完整的信息支持更准确的答案
- **相关性**: 智能截断确保最相关内容优先
- **完整性**: 多模态信息支持更全面的回答

---

## 十、总结

RAG系统V3的Prompt构建机制通过以下关键设计实现了高效的多模态内容处理：

### 10.1 核心设计原则

1. **分层处理**: 内容提取 → 上下文构建 → Prompt生成
2. **类型特化**: 针对文本、图片、表格的不同特点采用不同处理策略
3. **信息增强**: 特别是表格内容，从简单文本提升为结构化增强信息
4. **智能优化**: 长度控制、相关性排序、错误处理等机制
5. **统一接口**: 最终统一为文本格式给LLM，保持接口一致性

### 10.2 查询处理方式对比

| 特性 | 智能查询 | 混合查询 |
|------|----------|----------|
| **类型检测** | 智能检测查询类型 | 无需检测，处理所有类型 |
| **处理策略** | 根据置信度选择单类型或混合处理 | 固定并行处理所有类型 |
| **上下文构建** | 针对性强，内容类型单一 | 信息全面，多类型内容融合 |
| **适用场景** | 类型明确的特定查询 | 需要全面信息的复杂查询 |
| **Prompt特点** | 简洁聚焦，避免干扰 | 丰富全面，结构清晰 |

### 10.3 技术优势

1. **多模态统一处理**: 文本、图片、表格三种类型内容的统一处理机制
2. **智能类型检测**: 基于关键词和置信度的智能查询类型检测
3. **结果融合优化**: 混合查询中的智能融合和去重机制
4. **上下文增强**: 表格内容的增强信息构建，提高LLM理解能力
5. **性能优化**: 并行处理、缓存机制、错误处理等性能优化策略

### 10.4 实际应用价值

这种设计既保证了信息的完整性和准确性，又充分利用了LLM对不同格式内容的理解能力，为高质量的问答体验提供了坚实的技术基础。通过智能查询和混合查询两种处理方式，系统能够根据不同的查询需求提供最合适的处理策略，实现了效率与效果的完美平衡。
