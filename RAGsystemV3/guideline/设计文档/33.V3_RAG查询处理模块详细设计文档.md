# M12-RAG查询处理模块详细设计文档

## 一、文档基础信息

| 模块名称 | M12-RAG查询处理模块 | 所属项目 | V3版本RAG系统 |
| -------- | ------------------- | -------- | ------------- |
| 文档版本 | V2.0 | 文档状态 | ☑ 草稿 □ 评审中 □ 已确认 □ 已归档 |
| 编写人   | AI助手 | 编写日期 | 2025年1月 |
| 关联文档 | 《V3_RAG系统需求文档》《V3_RAG系统前端技术选择文档》《2.RAG系统Prompt构建机制详解.md》《3.混合查询流程分析.md》《4.智能查询流程分析.md》 | | |

## 二、模块概述

### 1. 定位与目标

作为V3 RAG系统的**核心查询处理模块**，负责智能查询类型检测、混合查询处理、结果融合、重排序和LLM问答等核心功能。该模块采用**模块化架构设计**，通过QueryProcessor + QueryRouter + SimpleSmartProcessor + SimpleHybridProcessor + UnifiedServices的复杂架构，实现不同类型查询的智能处理，确保系统高效、准确、易维护。

**核心特性**：
- **模块化架构**：QueryProcessor → QueryRouter → 具体处理器 → UnifiedServices
- **智能类型检测**：基于关键词匹配的置信度计算算法
- **混合查询处理**：并行检索、智能融合、去重算法
- **统一服务接口**：UnifiedServices提供retrieve、rerank、generate_answer统一接口
- **复杂重排序**：MultiModelReranker多模型融合、分数融合、缓存优化

### 2. 依赖与交互

| 关联模块 | 交互方向 | 核心交互内容 |
| -------- | -------- | ------------ |
| UnifiedServices | 调用 | 统一服务接口：retrieve、rerank、generate_answer |
| RetrievalEngine | 调用 | 多类型内容检索：retrieve_texts、retrieve_images、retrieve_tables |
| MultiModelReranker | 调用 | 多模型重排序：DashScope + 规则基础 + 分数融合 |
| LLMCaller | 调用 | LLM调用：generate_answer、Prompt构建、上下文管理 |
| VectorDBIntegration | 调用 | 向量数据库集成：search_texts、search_images、search_tables |
| ContextManager | 调用 | 上下文管理：_reorganize_context、_optimize_context |
| PromptManager | 调用 | Prompt管理：模板选择、Prompt构建 |
| V3向量数据库 | 被调用 | 文本、图片、表格向量检索 |

## 三、核心功能设计

### 1. 功能清单

| 功能ID | 功能名称 | 核心描述 | 操作角色 | 前置条件 |
| ------- | -------- | -------- | -------- | -------- |
| FQ01 | 智能查询类型检测 | 基于关键词匹配的置信度计算算法，支持text/image/table/hybrid/auto类型 | 系统自动 | 查询文本输入 |
| FQ02 | 单类型查询处理 | 针对特定内容类型的定向检索和处理，通过SimpleSmartProcessor处理 | 用户指定 | 查询类型明确 |
| FQ03 | 混合查询处理 | 多类型内容并行检索、智能融合、去重算法，通过SimpleHybridProcessor处理 | 系统自动 | 查询类型为hybrid或auto |
| FQ04 | 结果融合处理 | 多类型检索结果的智能合并和排序，避免重复内容，支持权重计算 | 系统自动 | 多类型结果存在 |
| FQ05 | 上下文优化选择 | ContextManager智能选择最优上下文，适配LLM输入限制，确保答案质量 | 系统自动 | 重排序结果存在 |
| FQ06 | 查询路由分发 | SimpleQueryRouter根据查询类型和用户意图，智能路由到相应的处理器 | 系统自动 | 查询请求接收 |
| FQ07 | 统一服务调用 | UnifiedServices提供retrieve、rerank、generate_answer统一接口 | 系统自动 | 服务初始化完成 |
| FQ08 | 多模型重排序 | MultiModelReranker多模型融合、分数融合、缓存优化 | 系统自动 | 检索结果存在 |
| FQ09 | 错误处理与回退 | 统一的错误处理机制，支持服务降级和自动回退 | 系统自动 | 错误发生 |
| FQ10 | 性能监控与优化 | 查询性能监控、响应时间统计、瓶颈识别 | 系统自动 | 查询执行 |

### 2. 关键功能流程

#### 2.1 智能查询处理流程

```mermaid
flowchart TD
    A[接收用户查询] --> B[QueryProcessor]
    B --> C[SimpleQueryRouter]
    C --> D[SimpleSmartProcessor]
    D --> E[智能类型检测]
    E --> F{置信度判断}
    F -->|高置信度>=0.7| G[单类型处理]
    F -->|低置信度<0.7| H[混合查询处理]
    G --> I[UnifiedServices.retrieve]
    H --> J[SimpleHybridProcessor]
    J --> K[并行检索所有类型]
    I --> L[UnifiedServices.rerank]
    K --> L
    L --> M[UnifiedServices.generate_answer]
    M --> N[返回结果]
```

**关键特点**：
- **模块化架构**：QueryProcessor → QueryRouter → SimpleSmartProcessor
- **智能类型检测**：基于关键词匹配的置信度计算
- **统一服务接口**：UnifiedServices提供retrieve、rerank、generate_answer
- **复杂重排序**：MultiModelReranker多模型融合

#### 2.2 混合查询处理流程

```mermaid
flowchart TD
    A[接收混合查询] --> B[QueryProcessor]
    B --> C[SimpleQueryRouter]
    C --> D[SimpleHybridProcessor]
    D --> E[并行检索所有类型]
    E --> F[文本检索]
    E --> G[图片检索]
    E --> H[表格检索]
    F --> I[智能融合去重]
    G --> I
    H --> I
    I --> J[UnifiedServices.rerank]
    J --> K[MultiModelReranker]
    K --> L[UnifiedServices.generate_answer]
    L --> M[ContextManager]
    M --> N[PromptManager]
    N --> O[LLMCaller]
    O --> P[结果返回]
```

**关键特点**：
- **并行检索**：同时检索文本、图片、表格三种类型
- **智能融合**：_fuse_and_deduplicate()智能融合和去重算法
- **多模型重排序**：MultiModelReranker多模型融合
- **复杂Prompt构建**：ContextManager + PromptManager + 表格内容增强

#### 2.3 查询路由分发流程

```mermaid
flowchart TD
    A[查询请求] --> B[QueryProcessor]
    B --> C[SimpleQueryRouter]
    C --> D{查询类型判断}
    D -->|smart| E[SimpleSmartProcessor]
    D -->|hybrid| F[SimpleHybridProcessor]
    D -->|text/image/table| G[SimpleSmartProcessor单类型处理]
    D -->|auto| H[自动类型检测]
    H --> I{检测结果}
    I -->|明确类型| J[SimpleSmartProcessor单类型处理]
    I -->|不明确| K[SimpleHybridProcessor混合处理]
    E --> L[UnifiedServices]
    F --> L
    G --> L
    J --> L
    K --> L
    L --> M[结果返回]
```

**关键特点**：
- **SimpleQueryRouter**：统一的查询路由分发
- **智能类型检测**：基于关键词匹配的置信度计算
- **统一服务接口**：所有处理器都通过UnifiedServices调用具体服务
- **模块化设计**：SimpleSmartProcessor和SimpleHybridProcessor分工明确

## 四、核心函数设计与调用关系

### 1. 函数清单

| 函数名 | 功能描述 | 输入参数 | 返回结果 | 所属服务 |
| ------ | -------- | -------- | -------- | -------- |
| `route_query(query, query_type, options)` | 查询路由分发主入口 | 查询文本、类型、选项 | 路由结果 | SimpleQueryRouter |
| `process_smart_query(query, options)` | 智能查询处理 | 查询文本、选项 | 智能查询结果 | SimpleSmartProcessor |
| `process_hybrid_query(query, options)` | 混合查询处理 | 查询文本、选项 | 混合查询结果 | SimpleHybridProcessor |
| `_detect_type(query)` | 查询类型检测 | 查询文本 | 检测类型和置信度 | SimpleSmartProcessor |
| `_fuse_and_deduplicate(results)` | 智能融合去重 | 结果列表 | 融合后的结果 | SimpleHybridProcessor |
| `retrieve(query, content_types, options)` | 统一检索服务 | 查询文本、内容类型、选项 | 检索结果 | UnifiedServices |
| `rerank(query, results)` | 统一重排序服务 | 查询文本、结果列表 | 重排序结果 | UnifiedServices |
| `generate_answer(query, context_chunks, prompt_template)` | 统一LLM调用 | 查询文本、上下文、模板 | LLM响应 | UnifiedServices |
| `_detect_type(query)` | 智能类型检测 | 查询文本 | 类型和置信度 | SimpleSmartProcessor |
| `_process_single_type(query, detected_type, options)` | 单类型处理 | 查询文本、类型、选项 | 处理结果 | SimpleSmartProcessor |
| `_process_hybrid_query(query, options)` | 混合查询处理 | 查询文本、选项 | 处理结果 | SimpleSmartProcessor |

### 2. 关键调用流程

```mermaid
sequenceDiagram
    participant U as 用户
    participant QP as QueryProcessor
    participant QR as SimpleQueryRouter
    participant SP as SimpleSmartProcessor
    participant HP as SimpleHybridProcessor
    participant US as UnifiedServices
    participant RE as RetrievalEngine
    participant MR as MultiModelReranker
    participant LC as LLMCaller
    
    U->>QP: 发送查询请求
    QP->>QR: 路由查询
    QR->>QR: 查询类型判断
    alt 智能查询
        QR->>SP: 转发到智能处理器
        SP->>SP: 智能类型检测
        SP->>US: 调用统一服务
        US->>RE: 调用检索引擎
        RE-->>US: 返回检索结果
        US->>MR: 调用重排序服务
        MR-->>US: 返回重排序结果
        US->>LC: 调用LLM服务
        LC-->>US: 返回答案
        US-->>SP: 返回处理结果
        SP-->>QR: 返回智能查询结果
    else 混合查询
        QR->>HP: 转发到混合处理器
        HP->>US: 并行检索所有类型
        US->>RE: 调用检索引擎
        RE-->>US: 返回多类型结果
        US-->>HP: 返回检索结果
        HP->>HP: 智能融合去重
        HP->>US: 调用重排序服务
        US->>MR: 调用重排序服务
        MR-->>US: 返回重排序结果
        US-->>HP: 返回重排序结果
        HP->>US: 调用LLM服务
        US->>LC: 调用LLM服务
        LC-->>US: 返回答案
        US-->>HP: 返回LLM响应
        HP-->>QR: 返回混合查询结果
    end
    QR-->>QP: 返回处理结果
    QP-->>U: 返回最终结果
```

**关键特点**：
- **模块化调用**：QueryProcessor → QueryRouter → 具体处理器 → UnifiedServices
- **统一服务接口**：所有具体服务都通过UnifiedServices调用
- **复杂重排序**：MultiModelReranker多模型融合
- **智能融合**：SimpleHybridProcessor的智能融合去重算法

## 五、接口设计

### 1. API接口

| 接口名 | 请求方式 | 请求地址 | 核心参数 | 返回结果 | 功能归属 |
| ------ | -------- | -------- | -------- | -------- | -------- |
| 智能查询接口 | POST | /api/v3/query/smart | question, options | 智能查询结果 | FQ01, FQ02 |
| 混合查询接口 | POST | /api/v3/query/hybrid | question, options | 混合查询结果 | FQ03, FQ04, FQ05 |
| 单类型查询接口 | POST | /api/v3/query/{type} | question, options | 单类型查询结果 | FQ02 |
| 自动查询接口 | POST | /api/v3/query/auto | question, options | 自动检测结果 | FQ01, FQ06 |

### 2. 数据格式定义

#### 2.1 查询请求格式

```json
{
  "question": "查询问题文本",
  "query_type": "smart|hybrid|text|image|table|auto",
  "options": {
    "max_results": 10,
    "relevance_threshold": 0.5,
    "context_length_limit": 4000
  }
}
```

#### 2.2 查询响应格式

```json
{
  "success": true,
  "query_type": "检测到的查询类型",
  "answer": "LLM生成的答案",
  "results": [
    {
      "id": "结果ID",
      "content_type": "text|image|table",
      "content": "内容摘要",
      "score": 0.85,
      "metadata": {
        "document_name": "文档名称",
        "page_number": "页码",
        "source_engine": "来源引擎"
      }
    }
  ],
  "processing_metadata": {
    "processing_time": 2.5,
    "engines_used": ["text", "image"],
    "detection_confidence": 0.8
  }
}
```

## 六、关键实现细节

### 1. 服务复用策略

```python
# 所有查询类型都使用相同的底层服务
class UnifiedServices:
    """统一服务接口 - 所有查询类型复用"""
    
    def __init__(self):
        self.retrieval_service = UnifiedRetrievalService()
        self.reranking_service = UnifiedRerankingService()
        self.llm_service = UnifiedLLMService()
    
    # 重排序服务 - 完全复用
    async def rerank(self, query: str, results: List[Any]):
        return await self.reranking_service.rerank(query, results)
    
    # LLM服务 - 复用+适配
    async def generate_answer(self, query: str, results: List[Any]):
        context = self._build_unified_context(results)  # 需要适配
        prompt = self._build_unified_prompt(query, context)
        return await self.llm_service.generate(prompt)
```

### 2. 简化设计原则

#### 2.1 结果融合简化
```python
def _simple_merge(self, results: List[Any]) -> List[Any]:
    """简单的结果融合 - 避免过度设计"""
    # 只做一件事：按分数排序
    return sorted(results, key=lambda x: x.get('score', 0.0), reverse=True)
```

#### 2.2 重排序简化
```python
async def rerank(self, query: str, results: List[Any]):
    """简单的重排序 - 直接调用模型"""
    try:
        return await self.reranking_model.rerank(query, results)
    except Exception as e:
        # 如果重排序失败，返回原始排序
        return sorted(results, key=lambda x: x.get('score', 0.0), reverse=True)
```

#### 2.3 上下文选择简化
```python
def select_context(self, query: str, results: List[Any]) -> List[Any]:
    """简单的上下文选择 - 取前N个"""
    max_context = 10  # 固定数量，避免复杂配置
    return results[:max_context]
```

### 3. 错误处理与回退机制

```python
class ErrorHandler:
    """统一的错误处理 - 支持服务降级"""
    
    def handle_reranking_error(self, query: str, results: List[Any]):
        """重排序失败时的回退策略"""
        logging.warning("重排序服务失败，回退到原始排序")
        return sorted(results, key=lambda x: x.get('score', 0.0), reverse=True)
    
    def handle_llm_error(self, query: str, results: List[Any]):
        """LLM服务失败时的回退策略"""
        logging.warning("LLM服务失败，返回检索结果摘要")
        return self._generate_fallback_answer(query, results)
    
    def _generate_fallback_answer(self, query: str, results: List[Any]):
        """生成回退答案"""
        if not results:
            return "抱歉，没有找到相关的信息。"
        
        # 简单的答案生成，不依赖LLM
        top_results = results[:3]
        summary = f"找到{len(results)}个相关结果，其中：\n"
        
        for i, result in enumerate(top_results, 1):
            content_type = result.get('content_type', 'unknown')
            score = result.get('score', 0.0)
            summary += f"{i}. {content_type}类型结果（相关性：{score:.2f}）\n"
        
        return summary
```

## 七、非功能需求

### 1. 性能需求
- **查询响应时间**：智能查询≤2秒，混合查询≤3秒
- **重排序时间**：≤1秒（支持批量处理）
- **LLM问答时间**：≤5秒（支持超时控制）
- **并发处理能力**：支持10个并发查询

### 2. 可靠性需求
- **服务可用性**：99.5%以上
- **错误恢复**：支持自动回退，确保基本功能可用
- **数据一致性**：查询结果与向量数据库保持一致

### 3. 可维护性需求
- **代码复杂度**：每个函数不超过50行
- **类层次深度**：不超过3层
- **配置参数**：核心配置不超过10个
- **测试覆盖率**：核心功能测试覆盖率≥80%

### 4. 扩展性需求
- **新查询类型**：支持添加新的查询类型处理器
- **新内容类型**：支持添加新的内容类型支持
- **新服务集成**：支持集成新的重排序或LLM模型

## 八、风险与应对措施

| 潜在风险 | 风险等级 | 应对措施 |
| -------- | -------- | -------- |
| 重排序服务失败 | 中 | 1. 自动回退到原始排序；2. 服务健康检查；3. 降级策略 |
| LLM服务超时 | 中 | 1. 设置合理超时时间；2. 异步处理；3. 回退答案生成 |
| 上下文过长 | 低 | 1. 智能截断；2. 长度限制配置；3. 分块处理 |
| 查询类型检测错误 | 低 | 1. 置信度阈值控制；2. 自动回退到混合查询；3. 用户手动指定 |
| 性能瓶颈 | 中 | 1. 性能监控；2. 缓存策略；3. 异步处理优化 |
| 服务依赖过多 | 高 | 1. 服务解耦；2. 接口标准化；3. 降级策略设计 |

## 九、测试策略

### 1. 单元测试
- 查询类型检测算法测试
- 结果融合逻辑测试
- 错误处理机制测试

### 2. 集成测试
- 端到端查询流程测试
- 服务间交互测试
- 错误场景测试

### 3. 性能测试
- 并发查询性能测试
- 响应时间测试
- 资源使用测试

### 4. 用户验收测试
- 真实查询场景测试
- 用户体验测试
- 边界条件测试

## 十、部署与运维

### 1. 部署要求
- Python 3.8+
- FastAPI框架
- 支持异步处理
- 环境变量配置

### 2. 监控指标
- 查询响应时间
- 错误率统计
- 服务可用性
- 资源使用情况

### 3. 日志管理
- 结构化日志格式
- 错误日志记录
- 性能日志记录
- 审计日志记录

## 十一、附件

- [附件1：RAG查询处理模块类图](#附件1rag查询处理模块类图)
- [附件2：智能查询处理流程图](#附件2智能查询处理流程图)
- [附件3：混合查询处理流程图](#附件3混合查询处理流程图)
- [附件4：服务复用架构图](#附件4服务复用架构图)
- [附件5：简化设计原则说明](#附件5简化设计原则说明)
- [附件6：错误处理流程图](#附件6错误处理流程图)

---

**文档版本历史**：
- V1.0 (2025-01-XX): 初始版本，基于讨论结果创建

---

## 附件1：RAG查询处理模块类图

```mermaid
classDiagram
    class QueryRouter {
        +route_query(query, query_type, options)
        -_route_to_processor(query, query_type)
    }
    
    class SimpleSmartProcessor {
        +process_smart_query(query, options)
        -_detect_type(query)
        -_process_single_type(query, content_type)
    }
    
    class SimpleHybridProcessor {
        +process_hybrid_query(query, options)
        -_parallel_retrieval(query)
        -_simple_merge(results)
        -_select_context(query, results)
    }
    
    class UnifiedRetrievalService {
        +search(query, content_types, options)
        -_search_text(query)
        -_search_image(query)
        -_search_table(query)
    }
    
    class UnifiedRerankingService {
        +rerank(query, results)
        -_call_reranking_model(query, results)
    }
    
    class UnifiedLLMService {
        +generate_answer(query, results)
        -_build_unified_context(results)
        -_build_unified_prompt(query, context)
        -_call_llm_model(prompt)
    }
    
    class ErrorHandler {
        +handle_reranking_error(query, results)
        +handle_llm_error(query, results)
        -_generate_fallback_answer(query, results)
    }
    
    QueryRouter --> SimpleSmartProcessor
    QueryRouter --> SimpleHybridProcessor
    SimpleSmartProcessor --> UnifiedRetrievalService
    SimpleSmartProcessor --> UnifiedRerankingService
    SimpleSmartProcessor --> UnifiedLLMService
    SimpleHybridProcessor --> UnifiedRetrievalService
    SimpleHybridProcessor --> UnifiedRerankingService
    SimpleHybridProcessor --> UnifiedLLMService
    UnifiedRerankingService --> ErrorHandler
    UnifiedLLMService --> ErrorHandler
```

## 附件2：智能查询处理流程图

```mermaid
flowchart TD
    A[接收智能查询] --> B[查询类型检测]
    B --> C{检测置信度}
    C -->|高置信度 >=0.7| D[确定内容类型]
    C -->|低置信度 <0.7| E[回退到混合查询]
    
    D --> F[调用对应类型检索]
    E --> G[并行检索所有类型]
    
    F --> H[重排序]
    G --> H
    
    H --> I[LLM问答]
    I --> J[返回结果]
    
    style A fill:#e1f5fe
    style J fill:#c8e6c9
    style E fill:#fff3e0
```

## 附件3：混合查询处理流程图

```mermaid
flowchart TD
    A[接收混合查询] --> B[并行检索所有类型]
    B --> C[文本检索]
    B --> D[图片检索]
    B --> E[表格检索]
    
    C --> F[结果收集]
    D --> F
    E --> F
    
    F --> G[简单结果融合]
    G --> H[统一重排序]
    H --> I[上下文选择]
    I --> J[LLM问答]
    J --> K[结果返回]
    
    style A fill:#e1f5fe
    style K fill:#c8e6c9
    style G fill:#fff3e0
```

## 附件4：服务复用架构图

```mermaid
graph TB
    subgraph "查询处理层"
        A[智能查询处理器]
        B[混合查询处理器]
        C[单类型处理器]
    end
    
    subgraph "统一服务层"
        D[统一检索服务]
        E[统一重排序服务]
        F[统一LLM服务]
    end
    
    subgraph "底层服务"
        G[V3向量数据库]
        H[Reranking模型]
        I[Qwen LLM]
    end
    
    A --> D
    A --> E
    A --> F
    
    B --> D
    B --> E
    B --> F
    
    C --> D
    C --> E
    C --> F
    
    D --> G
    E --> H
    F --> I
    
    style D fill:#e3f2fd
    style E fill:#e8f5e8
    style F fill:#fff3e0
```

## 六、总结

### 6.1 核心特性总结

**查询处理模块**采用**模块化架构设计**，通过复杂的模块关系实现不同类型查询的智能处理：

#### 6.1.1 模块化架构
- **QueryProcessor**：统一入口，管理所有查询处理
- **SimpleQueryRouter**：智能路由分发，根据查询类型选择处理器
- **SimpleSmartProcessor**：智能查询处理，支持类型检测和单类型处理
- **SimpleHybridProcessor**：混合查询处理，支持并行检索和智能融合
- **UnifiedServices**：统一服务接口，提供retrieve、rerank、generate_answer

#### 6.1.2 智能类型检测
- **基于关键词匹配**：图片、表格、文本关键词检测
- **置信度计算**：复杂的置信度计算算法
- **智能路由**：高置信度使用单类型处理，低置信度使用混合查询

#### 6.1.3 复杂重排序
- **MultiModelReranker**：多模型融合重排序
- **分数融合**：DashScope + 规则基础 + 加权平均
- **性能优化**：缓存机制、批处理、性能统计

### 6.2 与设计文档的差异

| 方面 | 原设计文档 | 实际实现 | 修改状态 |
|------|-----------|----------|----------|
| **架构设计** | 简单的流程图描述 | 复杂的模块化架构 | ✅ 已更新 |
| **智能查询** | 简单的类型检测 | 复杂的置信度计算算法 | ✅ 已更新 |
| **混合查询** | 简单的并行检索 | 复杂的融合去重算法 | ✅ 已更新 |
| **统一服务** | 未详细描述 | UnifiedServices统一接口 | ✅ 已更新 |
| **重排序机制** | 简单描述 | MultiModelReranker多模型融合 | ✅ 已更新 |
| **函数设计** | 简单的函数列表 | 基于实际代码的复杂函数关系 | ✅ 已更新 |

### 6.3 实际应用效果

- **模块化设计**：清晰的模块分工，便于维护和扩展
- **智能处理**：基于置信度的智能类型检测和路由
- **高效检索**：并行检索和智能融合提高检索效率
- **准确重排序**：多模型融合提供更准确的重排序结果
- **统一接口**：UnifiedServices提供统一的服务调用接口

这种设计既保证了查询处理的准确性和效率，又充分利用了现代AI技术的能力，为RAG系统提供了高质量的查询处理服务。

## 附件5：简化设计原则说明

```mermaid
mindmap
  root((简化设计原则))
    避免过度设计
      类层次不超过3层
      函数不超过50行
      配置参数最少化
      策略选择简单化
    
    服务复用最大化
      重排序服务完全复用
      LLM服务复用+适配
      错误处理统一化
      接口标准化
    
    功能聚焦化
      每个组件只做一件事
      职责边界清晰
      依赖关系简单
      测试覆盖完整
    
    渐进式开发
      先实现基础功能
      确保系统能工作
      后续再优化
      避免一次性完美
```

## 附件6：错误处理流程图

```mermaid
flowchart TD
    A[查询执行] --> B{是否出错?}
    B -->|否| C[正常返回结果]
    B -->|是| D[错误类型判断]
    
    D --> E{重排序错误?}
    D --> F{LLM错误?}
    D --> G{其他错误?}
    
    E -->|是| H[回退到原始排序]
    F -->|是| I[生成回退答案]
    G -->|是| J[记录错误日志]
    
    H --> K[继续处理]
    I --> K
    J --> K
    
    K --> L[返回降级结果]
    
    style A fill:#e1f5fe
    style C fill:#c8e6c9
    style L fill:#fff3e0
    style H fill:#ffecb3
    style I fill:#ffecb3
```
