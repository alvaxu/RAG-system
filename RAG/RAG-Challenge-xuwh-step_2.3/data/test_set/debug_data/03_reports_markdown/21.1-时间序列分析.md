# 时间序列分析

# 时间序列模型

你认为金融交易有时间上的规律么？

# 案例：沪市指数预测

Case: Shanghai Stock Index Forecast

# CASE：沪市指数预测

·沪市指数的历史数据（从1990年12月19日到2024年6月30日），shanghai_index_1990_12_19_to_2024_06_30.csv  
·请你对沪市指数未来3个月（截止到2024年9月30日）的变化进行预测

![](images/2e0f8394dc620c9c8f4210439e28f9fcf9b3dd89aff32d062e51597e391af972.jpg)  
1990年到2024年沪市指数走势

# 什么是时间序列模型

Whatisa time series model

# 时间序列：

·建立了观察结果与时间变化的关系，能帮预测未来一段时间内的结果变化情况

时间序列分析与回归分析的区别：

·在选择模型前，我们需要确定结果与变量之间的关系。回归分析训练得到的是目标变量y与自变量×（一个或多个）的相关性，然后通过新的自变量x来预测目标变量y。而时间序列分析得到的是目标变量y与时间的相关性

1990年到2024年沪市指数走势  
![](images/e9222d6e636c4cdf5ae6fcb8b781106f29f332695e199a17fe5ee96e796a86ca.jpg)  
成交量3.15亿手

·回归分析擅长的是多变量与目标结果之间的分析，即便是单一变量，也往往与时间无关。而时间序列分析建立在时间变化的基础上，它会分析目标变量的趋势、周期、时期和不稳定因素等。这些趋势和周期都是在时间维度的基础上，是我们要观察的重要特征

# 时间序列：

·按照时间顺序组成的数字序列·历史悠久，在中国古代的农业社会中，人们就将一年中不同时间节点和天气的规律总结了下来，形成了二十四节气，也就是从时间序列中观察天气和太阳的规律（只是当时没有时间序列模型和相应工具)

·时间序列在金融、经济、商业领域拥有广泛的应用·机器学习模型，包括AR、MA、ARMA、ARIMA·神经网络，时序大模型都可以进行时间序列预测时间序列分析是金融时序数据中很重要的工具，了解方法后续执行可由技术或通过AI大模型辅助进行

![](images/dd88225cf131b6f5ebbd436c1e9489f23fd9f58b6f7ce2968f715b4395242112.jpg)  
沪市指数走势

# 时间序列及分解：

平稳序列，stationary series  
基本上不存在趋势（Trend）的序列，各观察值基本上在某  
个固定的水平上波动  
·非平稳序列，non-stationary series  
包含趋势、季节性或周期性的序列，可以只有一种成分，也  
可能是多种成分的组合

![](images/6508ffac70aea6ec20cbef3992b7c6a8063b332a726aaf8ca8fb2a334148b539.jpg)

# 时间序列分析

Time Series Analysis

# 时间序列及分解：

·趋势（trend）：时间序列在长时期内呈现出来的某种持续上升或持续下降的变动，也称长期趋势

·季节性（seasonality）：时间序列在一年内重复出现的周期波动。销售旺季，销售淡季，旅游旺季、旅游淡季季节，可以是任何一种周期性变化，不一定是一年中的四季含有季节成分的序列可能含有趋势，也可能不含有趋势·周期性（cyclicity）：通常是由经济环境的变化引起不同于趋势变动，不是朝着单一方向的持续运动，而是涨落相间的交替波动

不同于季节变动，季节变动有比较固定的规律，变动周期大多为一年。周期性的循环波动无固定规律，变动周期多在一年以上，且周期长短不一

·随机性（Irregular），指受偶然因素影响所形成的的不规则波动，在时间序列中无法预估

随机性是不规则波动，除去趋势、周期性、季节性的偶然性波动

<html><body><table><tr><td>因素</td><td>举例</td></tr><tr><td>长期趋势 Trend(T)</td><td>国内生产总值</td></tr><tr><td>季节变动 Season(S)</td><td>冰淇淋、暖宝宝、羽绒服、裙 子等销售</td></tr><tr><td>周期性 Cyclic(C)</td><td>太阳黑子数量变化</td></tr><tr><td>随机性 Irregular(l)</td><td>股票市场受到突然的利好、利 空等信息的影响，影响股价产 生的波动</td></tr></table></body></html>

# 时间序列工具 (statsmodels)

Time Series Tools (statsmodels)

# statsmodels工具:

·statsmodels工具包提供统计计算，包括描述性统计以及统计模型的估计和推断

statsmodels主要包括如下子模块：

·回归模型：线性回归，广义线性模型，线性混合效应模  
·方差分析（ANOVA）  
·时间序列分析：AR，ARMA，ARIMA等

# 时间序列工具 (statsmodels)

Time Series Tools (statsmodels)

import statsmodels.api as sm

#数据加载

data.Timestamp $\mathbf { \tau } = \mathbf { \tau }$ pd.to_datetime(data.Timestamp)

data $\mathbf { \tau } = \mathbf { \tau }$ pd.read_csv('shanghai_index_1990_12_19_to_2020_03_12.csv', usecols $\ c =$ ['Timestamp','Price'])

data $\mathbf { \tau } = \mathbf { \tau }$ data.set_index('Timestamp)

data['Price'] $\mathbf { \tau } = \mathbf { \tau }$ data['Price'].apply(pd.to_numeric,errors $\cdot = \cdot$ ignore')

#进行线性插补缺漏值 data.Price.interpolate(inplace $\ c =$ True)

![](images/614de17bd44335f8b4118e3e79322d0fb638f7625ae7cd9dd1690384a251818c.jpg)

# 返回三个部分 trend（趋势），seasonal（季节性）和residual (残留  
result $\mathbf { \tau } = \mathbf { \tau }$ sm.tsa.seasonal_decompose(data.Price, period=250)  
result.plot()  
plt.show()

# 时间序列模型

Time Series Model

# AR模型：

AutoRegressive，中文叫自回归模型·认为过去若干时刻的点通过线性组合，再加上白噪声就可以预测未来某个时刻的点

·日常生活环境中就存在白噪声，在数据挖掘的过程中，可以把它理解为一个期望为0，方差为常数的纯随机过程

·AR模型存在一个阶数p，称为AR(p)模型，也叫作p阶自回归模型。指的是通过这个时刻点的前p个点，通过线性组合再加上白噪声来预测当前时刻点的值

·AR是线性时间序列分析模型中最简单的模型，通过前面部分的数据与后面部分的数据之间的相关关系来建立回归方程:

$x _ { t } = \phi _ { 1 } x _ { t - 1 } + \phi _ { 2 } x _ { t - 2 } + . . . + \phi _ { p } x _ { t - p } + u _ { t }$ AR(p)，表示p阶的自回归过程， $\phi$ 为自回归系数${ \mathbf { } } u _ { { \mathbf { } } _ { t } }$ 表示白噪声，是时间序列中的数值的随机波动。这些波动会相互抵消，即累计为0

·如果只有一个时间记录点时，则为AR(1)，即一阶自回归过程:$x _ { t } = \phi _ { 1 } x _ { t - 1 } + u _ { t }$

# 时间序列模型

Time Series Model

# MA模型：

MovingAverage，中文叫做滑动平均模型

·与AR模型大同小异，AR模型是历史时序值的线性组合MA是通过历史白噪声进行线性组合来影响当前时刻点

·MA模型中的历史白噪声是通过影响历史时序值，从而间接影响到当前时刻点的预测值

·MA模型存在一个阶数q，称为MA(q)模型，也叫作q阶移动平均模型

·AR和MA模型都存在阶数，在AR模型中，用p表示，在MA模型中用q表示，这两个模型大同小异，与AR模型不同的是MA模型是历史白噪声的线性组合

·MA模型，通过前面通过将一段时间序列中白噪声序列进行加权和，可以得到移动平均方程：

$$
x _ { t } = u _ { t } + \phi _ { 1 } u _ { t - 1 } + \phi _ { 2 } u _ { t - 2 } + . . . + \phi _ { q } u _ { t - q }
$$

·MA(q)表示q阶移动平均过程， $\phi$ 为移动回归系数， ${ \mathbf { } } u _ { { \mathbf { } } _ { t } }$ 为不同时间点的白噪声

·Xt为第t天的股票价格，而Ut为第t天的新闻影响，当天的股票价格受当天的新闻影响，也受昨天的新闻影响（但影响力要弱些，所以要乘上系数）

# ARMA模型:

·Auto Regressive MovingAverage，中文叫做自回归滑动平均模型  
·AR模型和MA模型的混合，相比AR模型和MA模型，它有更准确的估计  
· ARMA模型存在p和q两个阶数，称为ARMA(p,q)模型:  
x=u，+Φ $u _ { t - 1 } + \phi _ { 2 } u _ { t - 2 } + . . . + \phi _ { q } u _ { t - q } + \mathscr { S } _ { 1 } x _ { t - 1 } + \mathscr { S } _ { 2 } x _ { t - 2 } + . . . + \mathscr { S } _ { p } x _ { t - j }$ D：  
·自回归模型结合了两个模型的特点，AR解决当前数据与后期数据之间的关系，MA则可以解决随机变动，即噪声问题

# ARIMA模型:

·Auto Regressive Integrated MovingAverage模型，中文叫差分自回归滑动平均模型，也叫求合自回归滑动平均模型  
·相比于ARMA，ARIMA多了一个差分的过程，作用是对不平稳数据进行差分平稳，在差分平稳后再进行建模  
·ARIMA的原理和ARMA模型一样。相比于ARMA(p,q)的两个阶数，ARIMA是一个三元组的阶数(p,d,q)，称为ARIMA(p,d,q)模型，其中d是差分阶数  
·AR，MA是ARMA的特殊形式，而ARMA是ARIMA的特殊形式

# ARIMA模型步骤：

·Step1，观察时间序列数据，是否为平稳序列  
：Step2，对于非平稳时间序列要先进行d阶差分运算，化为平稳时间序列  
·Step3，使用ARIMA（p,d,q）模型进行训练拟合，找到最优的(p,d,q)，及训练好的模型  
：Step4，使用训练好的ARIMA模型进行预测，并对差分进行还原

ARIMA用差分将不平稳数据先变得平稳，再用ARMA模型

# 关于差分：

·差分 $\mathbf { \bar { \rho } } = \mathbf { \rho }$ 序列之间做差值，目的是为了得到平稳的序列，也就是去掉前面数值的影响  
·一次差分为序列之间做一次差值，二次差分为在一次差分的基础上在做一次差分  
· $f ( x ) = x ^ { 2 }$ 若x=[1,4,9,16,25...] （x有二次趋势)  
一次差分的结果为 $| [ 4 - 1 , 9 - 4 , 1 6 - 9 , 2 5 - 1 6 . . . ] = [ 3 , 5 , 7 , 9 , 1 1 . . . ]$ ，此时x  
序列仍不平稳，有一次上升的趋势  
再做一次差分为[2,2,2,2...]，此时x为平稳序列

# ARMA工具:

from statsmodels.tsa.arima_model import ARMA

ARMA(endog,order,exog $\mathbf { \bar { \rho } } = \mathbf { \rho }$ None)

·endog：endogenousvariable，代表内生变量，又叫非政策性变量，它是由模型决定的，不被政策左右，可以说是我们想要分析的变量，或者说是我们这次项目中需要用到的变量

order：代表是p和q的值，也就是ARMA中的阶数·exog：exogenousvariables，代表外生变量。外生变量和内生变量一样是经济模型中的两个重要变量。相对于内生变量而言，外生变量又称作为政策性变量，在经济机制内受外部因素的影响，不是我们模型要研究的变量

如果我们想要创建ARMA(7,0)模型，可以写成：ARMA(data,(7,0))，其中data是我们想要观察的变量，(7,0)代表(p,q)的阶数。  
fit函数，进行拟合  
predict(start,end)函数，进行预测，其中start为预测的起始时间，end为预测的终止时间

# #用ARMA进行时间序列预测

from statsmodels.tsa.arima_model import ARMA

# #创建数据

data $\mathbf { \tau } = \mathbf { \tau }$ [3821,4236,3758,6783, 4664, 2589,2538,3542, 4626, 5886, 6233,   
4199,3561, 2335,5636,3524, 4327, 6064, 3912, 1356, 4305, 4379, 4592,   
4233,4281, 1613, 1233, 4514,3431, 2159, 2322, 4239, 4733,2268, 5397,   
5821, 6115, 6631, 6474, 4134, 2728, 5753, 7130, 7860, 6991, 7499, 5301,   
2808,6755,6658,6944,6372,8380, 7366,6352,8333,8281, 11548, 10823,   
13642, 9973, 6723,13416,12205,13942, 9590,11693, 9276,6519, 6863,   
8237,10122, 8646,9749, 5346, 4836,9806, 7502, 9387, 11078, 9832, 6886,   
4285,8351, 9725, 11844, 12387, 10666, 7072, 6429]

data $\ c =$ pd.Series(data)

data_index $\mathbf { \tau } = \mathbf { \tau }$ sm.tsa.datetools.dates_from_range('1901','1990')

![](images/ef117d1cd6a943ab03a48294ab8b85b1744e61b8917feef3fbb831ad05f04c69.jpg)

# ARMA工具

Time SeriesTool ARMA

# #绘制数据图

At iterate 35 f= 8.87823D+00 Iproj gl= 6.55707D-03   
At iterate 40 f= 8.87776D+00 lproj g|= 1.28608D-04   
At iterate 45 f= 8.87776D+00 Iproj g|= 1.24345D-06   
At iterate 50 f= 8.87776D+00 lproj g|= 1.08358D-05   
At iterate 55 f= 8.87776D+00 lproj gl= 5.32907D-06   
Tit = total number of iterations   
Tnf = total number of function evaluations   
Tnint = total number of segments explored during Cauchy searches   
Skip = number of BFGS updates skipped   
Nact = number of active bounds at final generalized Cauchy point   
Projg = norm of the final projected gradient   
F final function value 中 N Tit Tnf Tnint Skip Nact Projg F 8 58 89 1 0 0 1.243D-06 8.878D+00 F= 8.8777593158679711   
CONVERGENCE: REL_REDUCTION_OF_F_<=_FACTR\*EPSMCH   
Warning: more than 10 function and gradient evaluations in the last line search. Termination may possibly be caused by a bad search direction.   
Cauchy time 0.000E+00 seconds.   
Subspace minimization time 0.000E+00 seconds.   
Line search time 0.000E+00 seconds.   
Total User time 0.000E+00 seconds.   
AIC: 1615.9967   
data.index $\mathbf { \tau } = \mathbf { \tau }$ pd.Index(data_index)   
data.plot(figsize=(12,8))   
plt.show()   
#创建ARMA模型#创建ARMA模型   
arma $\mathbf { \tau } = \mathbf { \tau }$ ARMA(data,(7,0)).fit()   
print('AIC: %0.4If' %arma.aic)   
#模型预测   
predict_y $\mathbf { \tau } = \mathbf { \tau }$ arma.predict('1990','2000')   
#预测结果绘制   
fig, ax $\mathbf { \tau } = \mathbf { \tau }$ plt.subplots(figsize=(12, 8))   
ax $\mathbf { \tau } = \mathbf { \tau }$ data.ix['1901':].plot( $\mathsf { a x } \mathsf { = a x }$   
predict_y.plot( $\scriptstyle ( { \mathsf { a x } } = { \mathsf { a x } }$   
plt.show()

![](images/ac900ef45c12a21b5aeca5530712a438f82cf9b4224807e0f0ef4aaeed26c02e.jpg)

AIC准则，也叫作赤池消息准则，是衡量统计模型拟合好坏的一个标准，数值越小代表模型拟合得越好

# 案例：沪市指数预测 (ARMA) Case: Shanghai Stock Index Forecast (ARMA)

使用ARMA工具对沪市指数进行预测：

Step1，数据加载&探索

按照不同的时间尺度（天，月，季度，年）可以将数据压缩，得到不同尺度的数据，然后做可视化呈现。

df_month $\mathbf { \tau } = \mathbf { \tau }$ df.resample('M').mean()

·Step2，模型选择&训练，在给定范围内，选择最优的超参数创建ARMA时间序列模型。我们并不知道p和q取什么值时，可以给它们设置一个区间范围，比如都是range(0,3)，然后计算不同模型的AIC数值，选择最小的AIC数值对应的那个ARMA模型

Step3，模型预测，可视化呈现用这个最优的ARMA模型预测未来3个月的沪市指数走势，并将结果做可视化呈现。

1990年到2024年沪市指数走势  
![](images/d268cb81410f9eab6a075bcc4290b8a2141632ac7d7f50eb4947956119015aa0.jpg)  
成交量3.15亿手

# 案例：沪市指数预测 (ARMA)

Case:Shanghai Stock Index Forecast (ARMA)

#数据加载

df $\mathbf { \tau } = \mathbf { \tau }$ pd.read_csv('./shanghai_index_1990_12_19_to_2024_06_30.csv')  
df $\mathbf { \tau } = \mathbf { \tau }$ df[['Timestamp','Price']]  
#将时间作为df的索引  
df.Timestamp $\mathbf { \tau } = \mathbf { \tau }$ pd.to_datetime(df.Timestamp)  
df.index $\mathbf { \tau } = \mathbf { \tau }$ df.Timestamp  
#数据探索  
print(df.head())  
#按照月，季度，年来统计  
df_month $\mathbf { \tau } = \mathbf { \tau }$ df.resample('M').mean()  
print(df_month)  
df_Q $\mathbf { \tau } = \mathbf { \tau }$ df.resample('Q-DEC').mean()  
df year $\mathbf { \tau } = \mathbf { \tau }$ df.resample('A-DEC').mean()

Timestanp Price Tinestanp 1990-12-19 1990-12-19 99.98 1990-12-20 1990-12-20 104.39 1990-12-21 1990-12-21 109.13 1990-12-24 1990-12-24 114.55 1990-12-25- 1990-12-25 120.25 Price Tinestanp 1990-12 -31 116.990000 1991-01-31 132.628182 1991-02-28 131.887778 1991-03 -31 16.01119 1991-04-30 118.426818 2019-08-31 2047.063264 2019 -09 -30 2978.383790 2019-10-31 2954.832456 2019-11-30 2923.774700 2019-12-31 2900. 789287 [349 rous x 1 coluuns]

# 案例：沪市指数预测 (ARMA)

Case: Shanghai Stock Index Forecast (ARMA)   
#按照天，月，季度，年来显示沪市指数的走势   
fig $\mathbf { \tau } = \mathbf { \tau }$ plt.figure(figsize $\ c =$ [15,7])   
plt.rcParams['font.sans-serif' $\ c =$ ['SimHei']#用来正常显示中文标签   
plt.suptitle('沪市指数',fontsize $: = 2 0$ ）   
plt.subplot(221)   
plt.plot(df.Price,'-', label='按天')   
plt.legend()   
plt.subplot(222)   
plt.plot(df_month.Price,'-',label='按月')   
plt.plot(df_Q.Price,'-', labe $| = ^ { | }$ 按季度")   
plt.plot(df_year.Price,'-',labe $\models \vDash$ 按年")   
plt.legend()   
plt.show()

![](images/eb4cb956a498d1551386c824b7807d56eaf1a3b39f3abc969d42272ce6c07efe.jpg)  
沪市指数

![](images/b56e41cc817cf892e0b8bcdea0132e2e9101dc1ac7a59cb53b6a3ef0a27d4f60.jpg)

# 案例：沪市指数预测 (ARMA)

Case: Shanghai Stock Index Forecast (ARMA)

#设置参数范围

ps = range(0, 3)   
qs = range(0, 3)   
parameters $\mathbf { \tau } = \mathbf { \tau }$ product(ps, qs)   
parameters_list $\mathbf { \tau } = \mathbf { \tau }$ list(parameters)   
#寻找最优ARMA模型参数，即best_aic最小   
results $\mathbf { \varepsilon } = [ ] \mathbf { \varepsilon }$   
best_aic $\mathbf { \tau } = \mathbf { \tau }$ float("inf")#正无穷   
for param in parameters_list: try: model $\mathbf { \tau } = \mathbf { \tau }$ ARMA(df_month.Price,order $\mathbf { \bar { \rho } } = \mathbf { \rho }$ (param[O],param[1])).fit() except ValueError: print('参数错误:',param) continue aic $\mathbf { \tau } = \mathbf { \tau }$ model.aic if aic $\rvert <$ best_aic: best_model $\mathbf { \tau } = \mathbf { \tau }$ model best_aic $\mathbf { \tau } = \mathbf { \tau }$ aic best_param $\mathbf { \tau } = \mathbf { \tau }$ param results.append([param,model.aic])   
print('最优模型:',best_model.summary())

<html><body><table><tr><td>最优模型： ARMA Hodel Results</td></tr><tr><td>Dep. Variable: Price No. Observations: 349 Model : ARMA(2, 2) Log Likelihood -2271.637 Method : css-mle S.D. of innovations 161.441 Date : Thu， 12 Dec 2019 AIC 4555.275 Time : 16 : 31 : 17 BIC 4578.405 Sample: 12 -31-1990 HQIC 4564.482</td></tr><tr><td>- 12-31-2019 coef std err z P>|z| [0.025 0.975]</td></tr><tr><td>const 1873.2337 491.673 3.810 0.000 909. 573 2836.894 ar .L1.Price 0.4987 0.130 3.844 0.000 0.244 0.753 ar.L2.Price 0.4659 0.128 3.634 0.000 0.215 0.717 ma.L1.Price 0.8587 0.123 7.000 0.000 0.618 1.099</td></tr><tr><td>ma.L2.Price 0.3721 0.062 5.979 0.000 0.250 0.494 Roots Real Imaginary Modulus Frequency</td></tr><tr><td>AR.1 1.0245 +0.0000j 1.0245 0.0000 AR.2 -2.0949 +0.0000j 2.0949 0.5000 MA.1 -1.1540 -1.1644j 1.6394 -0.3743 MA.2 -1.1540 +1.1644j 1.6394 0.3743</td></tr></table></body></html>

# 案例：沪市指数预测 (ARMA)

Case: Shanghai Stock Index Forecast (ARMA)

#设置future_month，需要预测的时间date_list   
future_month $= 3$   
last_month $\mathbf { \tau } = \mathbf { \tau }$ pd.to_datetime(df_month2.index[len(df_month2)-1])   
date_list = []   
for iin range(future_month): #计算下个月有多少天 year $\mathbf { \tau } = \mathbf { \tau }$ last_month.year month $\mathbf { \tau } = \mathbf { \tau }$ last_month.month if month $\scriptstyle = = 1 2$ ： month $= 1$ $\mathsf { y e a r } = \mathsf { y e a r } + 1$ else: $\mathsf { m o n t h } = \mathsf { m o n t h } + 1$ next_month_days $\mathbf { \tau } = \mathbf { \tau }$ calendar.monthrange(year,month)[1] #print(next_month_days) last_month $\mathbf { \tau } = \mathbf { \tau }$ last_month $^ +$ timedelta(days $\ c =$ next_month_days) date_list.append(last_month)   
print('date_list=',date_list)

date_list $\ c =$ [Timestamp('2020-04-30 00:00:00', freq='M'), Timestamp('2020-05- 31 00:00:00', freq='M'), Timestamp('2020-06-30 00:00:00', freq='M')]

# 案例：沪市指数预测 (ARMA)

Case: Shanghai Stock Index Forecast (ARMA)

![](images/d6ee52a4ae42f5bbdb8bfc076989a5aaaf5da5974bc67e95a60c5ddc2d6d283c.jpg)

# 案例：沪市指数预测 (ARMA) Case: Shanghai Stock Index Forecast (ARMA)

#设置参数范围   
ps = range(0, 5)   
${ \tt q s } = { \tt r a n g e } ( 0 , 5 )$   
$\mathsf { d } s = \mathsf { r a n g e } ( 1 , 2 )$ #使用1阶差分   
for param in parameters_list: try:

model $\mathbf { \tau } = \mathbf { \tau }$ sm.tsa.statespace.SARIMAX(df_month.Price, order=(param[O],param[1],param[2]) enforce_stationarity=False, enforce_invertibility=False).fit()

<html><body><table><tr><td>最优模型： Statespace Model Results 二二 二</td></tr><tr><td>Dep. Variable: Price No. Observations : 349 Model: SARIMAX(1， 1, 4) Log Likelihood -2230 .429 Sat, 14 Dec 2019 AIC 4472.859 22 : 15:50 BIC 4495.885 Sample : 12 -31-1990 HQIC 4482.031 - 12-31-2019 Date: Time:</td></tr><tr><td>Covariance Type: opg 二 coef std err z P>|z| [0.025 0.975]</td></tr><tr><td>ar.L1 0.5689 0.162 3.521 0.000 0.252 0.886 ma.L1 -0.2316 0.163 -1.420 0.156 -0.551 0.088 ma.L2 -0.0426 0.058 -0.732 0.464 -0.157 0.071 ma .L3 -0.1654 0.045 -3.654 0.000 -0.254 -0.077 ma . L4 0.2216 0.031 7.128 0.000 0.161 0.283 sigma2 2.603e+04 943.910 27.579 0.000 2.42e+04 2.79e+04</td></tr><tr><td>= Ljung-Box (O) : 44.60 Jarque-Bera (JB) : 1130.74 Prob(Q) : 0.28 Prob(JB) : 0.00 Heteroskedasticity (H) : 2.23 Skew : -0.84 Prob(H) (two-sided) : 0.00 Kur tosis : 11.73</td></tr></table></body></html>

except ValueError: print('参数错误:',param) continue   
aic $\mathbf { \tau } = \mathbf { \tau }$ model.aic   
if aic $\textless$ best_aic:

#输出最优模型 print('最优模型:',best_model.summary())

# 案例：沪市指数预测 (ARIMA)

Case:Shanghai Stock Index Forecast (ARIMA)

#添加未来要预测的3个月

future $\mathbf { \tau } = \mathbf { \tau }$ pd.DataFrame(index $\mathop { : = }$ date_list, columns $\ c =$ df_month.columnsdf_month2 $\mathbf { \tau } = \mathbf { \tau }$ pd.concat([df_month2, future])#get_prediction得到的是区间，使用predicted_meandf_month2['forecast'] $\mathbf { \tau } = \mathbf { \tau }$ best_model.get_prediction(start $_ { = 0 }$ end=len(df_month2)).predicted_mean 二

W\  
#沪市指数预测结果显示  
plt.figure(figsize=(30,7))_month2.Price.plot(label='实际指数')

![](images/1fba9e8c70e6d7dd9e0884b349495aa6e4a7847aee076c3ee5d328bf3e2460ee.jpg)

df_month2.forecast.plot(color='r', $k = ^ { 1 } - 1$ ,labe $\models \vDash$ 预测指数")  
plt.legend()  
plt.title('沪市指数（月）')

plt.xlabel('时间')plt.ylabel('指数')plt.show()

![](images/1a08555a3ade2976d96f434dbb658a1e433d296c7917e42c8b76803a842f7dc4.jpg)

# 资金流入流出

你能对业务量突然上涨/下降的情况进行预测么

# 案例：资金流入流出预测

CASE:Prediction of capital inflow and outflow

CASE：资金流入流出预测

:https://tianchi.aliyun.com/competition/entrance/231573/infor mation

·数据集一共包括4张表：用户基本信息数据、用户申购赎回数据、收益率表和银行间拆借利率表

2.8万用户，284万行为数据，294天拆解利率，427天收益率  
2013-07-01到2014-08-31，预测2014年9月的申购和赎回

Thinking：如果能对未来30天的资金流入流出预测准确， 对货币类理财产品有怎样的价值？

1e8 1.00 0.75 .l. ld. 0.50   
rerpeeelt 0.25 0.00 -0.25 -0.50 -0.75 -1.00 1 2 3 4 5 6 7 8 9 1011121314 151617181920 21 2223 24 2526 27 282930 31 date 1e8 10 1 L山   
eetett 550015 中 -1.0 1 2 3 4 5 6 7 8 9 101112131415161718192021 22 2324 252627 28 2930 31 date

# 案例：资金流入流出预测

CASE:Prediction of capital inflow and outflow

·用户信息表，user_profile_table

总共随机抽取了约3万用户，主要包含了用户的性别、城市和星座，其中部分用户在2014年9月份第一次出现，这些用户只在测试数据中

<html><body><table><tr><td>列名</td><td>类型</td><td>含义</td><td>示例</td></tr><tr><td>user_id</td><td>bigint</td><td>用户ID</td><td>1234</td></tr><tr><td>Sex</td><td>bigint</td><td>男，：女1：</td><td>0</td></tr><tr><td>City</td><td>bigint</td><td>所在城市</td><td>6081949</td></tr><tr><td>constellation string</td><td></td><td>星座</td><td>射手座</td></tr></table></body></html>

![](images/e587ac0afa933cc008db85eadd8e3509762c676c605a850cd0d385978910ea79.jpg)

# 案例：资金流入流出预测

CASE:Prediction of capital inflow and outflow 用户申购赎回数据表user_balance_table

·数据包括了20130701至20140831申购和赎回信息，字段包括用户操作时间和操作记录，其中操作记录包括申购和赎回两个部分  
·金额的单位是分，即0.01元  
如果用户今日消费总量为o，即consume_amt=0，同时四个category字段为空  
·数据经过了脱敏，同时保证了：

<html><body><table><tr><td>列名</td><td>类型</td><td>含义</td><td>示例</td></tr><tr><td>user_id</td><td>bigint</td><td>用户id</td><td>1234</td></tr><tr><td>report_date</td><td>string</td><td>日期</td><td>2014040 7</td></tr><tr><td>tBalance</td><td>bigint</td><td>今日余额</td><td>109004</td></tr><tr><td>yBalance</td><td>bigint</td><td>昨日余额</td><td>97389</td></tr><tr><td>total_purchase_amt</td><td>bigint</td><td>今日总购买量=直接购买+收益</td><td>21876</td></tr><tr><td>direct_purchase_amt</td><td>bigint</td><td>今日直接购买量</td><td>21863</td></tr><tr><td>purchase_bal_amt</td><td>bigint</td><td>今日支付宝余额购买量</td><td>0</td></tr><tr><td>purchase_bank_amt</td><td>bigint</td><td>今日银行卡购买量</td><td>21863</td></tr><tr><td>total_redeem_amt</td><td>bigint</td><td>今日总赎回量=消费+转出</td><td>10261</td></tr><tr><td>consume_amt</td><td>bigint</td><td>今日消费总量</td><td>O</td></tr><tr><td>transfer_amt</td><td>bigint</td><td>今日转出总量</td><td>10261</td></tr><tr><td>tftobal_amt</td><td>bigint</td><td>今日转出到支付宝余额总量</td><td>O</td></tr><tr><td>tftocard_amt</td><td>bigint</td><td>今日转出到银行卡总量</td><td>10261</td></tr><tr><td>share_amt</td><td>bigint</td><td>今日收益</td><td>13</td></tr><tr><td>category1</td><td>bigint</td><td>今日类目1消费总额</td><td></td></tr><tr><td>category2</td><td>bigint</td><td>今日类目2消费总额</td><td>0</td></tr><tr><td>category3</td><td>bigint</td><td>今日类目3消费总额</td><td>0</td></tr><tr><td>category4</td><td>bigint</td><td>今日类目4消费总额</td><td>0</td></tr></table></body></html>

今日余额 $\mathbf { \sigma } = \mathbf { \sigma }$ 昨日余额 $+$ 今日申购-今日赎回，不会出现负值

# 案例：资金流入流出预测

CASE:Prediction of capital inflow and outflow

收益率表mfd_day_share_interest

·收益表为余额宝在14个月内的收益率表

<html><body><table><tr><td>列名</td><td>类型</td><td>含义</td><td>示例</td></tr><tr><td>mfd_date</td><td>string</td><td>日期</td><td>20140102</td></tr><tr><td>mfd_daily_yield</td><td>double</td><td>万份收益，即1万块 钱的收益。</td><td>1.5787</td></tr><tr><td>mfd_7daily_yield</td><td>double</td><td>七日年化收益率 (%）</td><td>6.307</td></tr></table></body></html>

上海银行间同业拆放利率表mfd_bank_shibor

·银行间拆借利率表是14个月期间银行之间的拆借利率（皆为年化利率）

<html><body><table><tr><td>列名</td><td>类型</td><td>含义</td><td>示例</td></tr><tr><td>mfd_date</td><td>String</td><td>日期</td><td>20140102</td></tr><tr><td>Interest_O_N</td><td>Double</td><td>隔夜利率（%）</td><td>2.8</td></tr><tr><td>Interest_1_W</td><td>Double</td><td>1周利率（%）</td><td>4.25</td></tr><tr><td>Interest_2_W</td><td>Double</td><td>2周利率（%）</td><td>4.9</td></tr><tr><td>Interest_1_M</td><td>Double</td><td>1个月利率（%）</td><td>5.04</td></tr><tr><td>Interest_3_M</td><td>Double</td><td>3个月利率（%）</td><td>4.91</td></tr><tr><td>Interest_6_M</td><td>Double</td><td>6个月利率（%）</td><td>4.79</td></tr><tr><td>Interest_9_M</td><td>Double</td><td>9个月利率（%）</td><td>4.76</td></tr><tr><td>Interest_1_Y</td><td>Double</td><td>1年利率（%）</td><td>4.78</td></tr></table></body></html>

# 案例：资金流入流出预测

CASE: Prediction of capital inflow and outflow

收益计算方式

·主要基于实际余额宝收益计算方法，进行了简化

1）收益计算的时间不再是会计日，而是自然日，以o点为分隔（0点之前算昨天，0点之后算今天）

2）收益的显示时间，即实际将第一份收益打入用户账户的时间，以周一转入周三显示为例，如果用户在周一存入10000元，即1000000分，那么这笔金额是周一确认，周二是开始产生收益，在周三将周二产生的收益打入到用户的账户中，此时用户的账户中显示的是1000110分

<html><body><table><tr><td>转入时间</td><td>首次显示收益时间</td></tr><tr><td>周一</td><td>周三</td></tr><tr><td>周二</td><td>周四</td></tr><tr><td>周三</td><td>周五</td></tr><tr><td>周四</td><td>周六</td></tr><tr><td>周五</td><td>下周二</td></tr><tr><td>周六</td><td>下周三</td></tr><tr><td>周天</td><td>下周三</td></tr></table></body></html>

# 案例：资金流入流出预测

CASE:Prediction of capital inflow and outflow

提交结果表tc_comp_predict_table

<html><body><table><tr><td>字段</td><td>类型</td><td>含义</td><td>示例</td></tr><tr><td>report_date</td><td>bigint</td><td>日期</td><td>20140901</td></tr><tr><td>purchase</td><td>bigint</td><td>申购总额</td><td>40000000</td></tr><tr><td>redeem</td><td>bigint</td><td>赎回总额</td><td>30000000</td></tr></table></body></html>

每一行数据是一天对申购、赎回总额的预测值，输出2014年9月每天的预测，共30行。purchase和redeem 都是金额数据，精确到分

输出示意：  

<html><body><table><tr><td>20140901</td><td>40000000</td><td>30000000</td></tr><tr><td>20140902</td><td>40000000</td><td>30000000</td></tr><tr><td>20140903</td><td>40000000</td><td>30000000</td></tr></table></body></html>

评估指标：

1）计算测试集上每天的申购及赎回与实际的误差每日申购相对误差(真实值 $z _ { i }$ ，预则值为 $z _ { i } )$ ：

$$
\mathrm { P u r c h a s e } _ { i } = \frac { | z _ { i } - z _ { i } | } { z _ { i } }
$$

每日赎回相对误差（真实值y：，预测值为）：

$$
\mathrm { { R e d e a m } } _ { i } = \frac { | { y } _ { i } - \hat { y ^ { \prime } } _ { i } | } { { y ^ { \prime } } _ { i } }
$$

2）误差与得分之间的计算公式不公布，但保证单调递减第i天的申购误差Purchasei=0，这一天的得分为10分；当Purchasei $> 0 . 3$ ，得分为0

3)总积分 $\mathbf { \sigma } = \mathbf { \sigma }$ 申购预测得分 $\ast 4 5 \% +$ 赎回预测得分 $45 5 \%$

# 案例：资金流入流出预测

CASE:Prediction of capital inflow and outflow

·数据探索EDA

# 1）每日总购买与赎回量的时间序列图

e9 Purchase and Redeem from 7-13 to 9-14 1.0 purchase redeem 0.8 0.6 junou 0.4 0.2 ANW 0.0 2013-07 2013-09 2013-11 2014-01 2014-03 2014-05 2014-07 2014-09 Time

2）STL分解，将时序图拆分为：Trend $^ +$ Seasonal + Residual

·方法1：采用时间序列进行预测Step1，平稳性检测adfullerStep2，采用ARIMA模型Step3，模型训练集与预测

·方法2：基于时序规则的挖掘Step1，获得周期因子（weekday）Step2，计算baseStep3，使用base\*周期因子进行预测

# 案例：资金流入流出预测

CASE:Prediction of capital inflow and outflowread_csv中的日期格式解析pd.read_csv('user_balance_table.csv'，parse_dates $\mathbf { \sigma } = \mathbf { \sigma }$ ['report_date'])

设置parsedates参数，将时间字符串转换为日期格式

DataFrame.diff()函数

用来将数据进行某种移动之后与原数据进行比较得出的差异数据

DataFrame.shift()函数可以把数据移动指定的位数periods=-1往上移动或往左移动periods ${ \tt \Psi } = 1 { \tt \Psi }$ 往下移动或往右移动

![](images/584665884e123316aabaaefa169830a9eea4d81bcbdb2aaf46d6feb43f7b0c55.jpg)

# 案例：资金流入流出预测

CASE:Prediction of capital inflow and outflow平稳性检测（ADF检测）：

·在使用时间序列模型时（比如ARMA、ARIMA），需要时间序列是平稳的，所以第一步都需要进行平稳性检验，常用的统计检验方法为ADF检验（也称为单位根检验）

·ADF检验，就是判断序列是否存在单位根，如果序列平稳，就不存在单位根，否则，就会存在单位根

·ADF检验的HO假设就是存在单位根，如果得到的显著性检验统计量小于三个置信度 $( 1 0 \% , 5 \% , 1 \% )$ ，则对应有（$90 \%$ ，95， $9 9 \%$ ）的把握来拒绝原假设

from statsmodels.tsa.stattools import adfuller t=adfuller(df_p['total_purchase_amt'])

(-1.5898802926313507, 0.4886749751375928, 18, 408, {'1%': -3.446479704252724， '5%': -2.8686500930967354, $" 1 0 \% ^ { \prime }$ :-2.5705574627547096}, 15960.28197033403)

输出结果依次为：

t-statistic, p-value, usedlag, nobscritical-value：测试统计数据的临界值为 $1 \%$ ， $5 \%$ 和 $10 \%$

AIC

如何确定该序列能否平稳：

主要看 $1 \%$ 、%5、%10不同程度拒绝原假设的统计值和ADFTestresult的比较，如果ADFTestresult同时小于 $1 \%$ 、 $5 \%$ 、 $10 \%$ 即说明非常好地拒绝原假设（原假设是不稳定的，因此证明是平稳的）这里，adf结果为-1.58988，大于三个level的统计值，无法拒绝原假设（原假设是不平稳的），需要进行一阶差分后，再进行检验

# 案例：资金流入流出预测

CASE:Prediction of capital inflow and outflow

时间序列预测

1）针对购买purchase建模 ARIMA(purchase,order=(7,1,5)).fit() model.predict('2014-09-01','2014-09-30',typ $\mathbf { \tau } = \mathbf { \tau }$ levels')

2）针对赎回redeem建模 ARIMA(redeem,order $\mathbf { \bar { \rho } } = \mathbf { \rho }$ (7,1,5)).fit() model.predict('2014-09-01','2014-09-30',typ $\mathbf { \tau } = \mathbf { \tau }$ levels')

# Thinking：模型预测准确性如何？

1）过于简单，实际情况并不是  
2）周一到周日的特征规律没有利用  
3）没有考虑特殊时间，比如节日，利率波动节点

![](images/c5933a994651a1370c80e9f2853d0390a3e979b4ad246c034c0650738b49f2cb.jpg)

![](images/8b239380c011e7066598f2699ed960464b3b5de8e11fc97480d4441c6cb954e4.jpg)

# 案例：资金流入流出预测

CASE:Prediction of capital inflow and outflow

# 时间序列规则：

·选择特征可以用简单的统计量来作为特征，从中提取出有用的信息

1）中位数：居于中间位置的数，较为稳健  
2）均值：当分布符合正态分布时，可以代表整体特征  
3）临近数据：离待测数据越近的数据对其影响越大

# 基于周期因子的时间序列预测

·很多数据都具有明显的周期性，比如客流量，支付等  
·需要确定周期长度，比如一周7天，一个月30天，结合STL分解(Seasonal andTrend decomposition)观察周期变化，缺点是没有考虑到节假日、突发事件等情况

# 案例：资金流入流出预测

CASE:Prediction of capital inflow and outflow

基于周期因子的时间序列预测

·假设给任务是根据前三周的数据预测第四周每天的客流量

<html><body><table><tr><td></td><td>周一</td><td>周二</td><td>周三</td><td>周四</td><td>周五</td><td>周六</td><td>周日</td><td>周均值</td></tr><tr><td>第一周</td><td>20</td><td>10</td><td>70</td><td>50</td><td>250</td><td>200</td><td>100</td><td>100</td></tr><tr><td>第二周</td><td>26</td><td>18</td><td>66</td><td>50</td><td>180</td><td>140</td><td>80</td><td>80</td></tr><tr><td>第三周</td><td>15</td><td>8</td><td>67</td><td>60</td><td>270</td><td>160</td><td>120</td><td>100</td></tr></table></body></html>

![](images/da7a29264a03c06e58c9942cf0a4e9079805d9acc1866c6b67f7e0e02592fa0e.jpg)  
The time series of consumer flow

Step1，获得周期因子（weekday）

获得星期几的均值，再除以整体均值

<html><body><table><tr><td></td><td>周一</td><td>周二</td><td>周三</td><td>周四</td><td>周五</td><td>周六</td><td>周日</td></tr><tr><td>第一周</td><td>20</td><td>10</td><td>70</td><td>50</td><td>250</td><td>200</td><td>100</td></tr><tr><td>第二周</td><td>26</td><td>18</td><td>66</td><td>50</td><td>180</td><td>140</td><td>80</td></tr><tr><td>第三周</td><td>15</td><td>8號</td><td>67</td><td>60</td><td>270</td><td>160</td><td>120</td></tr><tr><td>均值</td><td>20.33</td><td>12</td><td>67.67</td><td>53.33</td><td>233.33</td><td>166.67</td><td>100</td></tr><tr><td>因子</td><td>0.22</td><td>0.13</td><td>0.73</td><td>0.57</td><td>2.50</td><td>1.79</td><td>1.07</td></tr></table></body></html>

Step2，计算baseStep3，使用base\*周期因子进行预测假设 $\mathtt { b a s e = 1 0 0 }$ ，可以得到第四周的客流量

<html><body><table><tr><td></td><td>周一</td><td>周二</td><td>周三</td><td>周四</td><td>周五</td><td>周六</td><td>周日</td></tr><tr><td>第四周</td><td>22</td><td>13</td><td>73</td><td>57</td><td>250</td><td>179</td><td>107</td></tr></table></body></html>

# 案例：资金流入流出预测

CASE:Prediction of capital inflow and outflow预测下个月每一天的情况：

·如果想预测下个月每天的流量情况，可以基于每月的规律（1-30号的平均流量）\*周期因子  
Step1，计算周期因子（weekday）  
Step2，计算每日（1号-30号）均值，即1号的平均流量，2号的平均流量...  
Step3，统计星期几（weekday）在每日（day）出现的频次Step4，基于周期因子获得加权均值，得到每日的base（去掉周期因子的影响）  
Step5，根据每日的base和周期因子进行预测

# 案例：资金流入流出预测 CASE:Prediction of capital inflow and outflow

观察特殊日期清明节，2014年4月5-7日五一，2014年5月1-3日六一，2014年5月31-6月2日中秋节：2014年9月6-8日国庆节：2014年10月1-7日

2014-04-11

2014年 C 4月 中 假期安排 返回今天二 三 四 五 六 日困 休31 1 2 3 4 5 6初一 愚人节 初三 初四 初五 清明节 初七休7 8 9 10 11 12 13初八 初九 初十 十 十二 十三 十四14 15 16 17 18 19 20十五 全民国. 十七 十八 十九 二十 谷雨21 22 23 24 25 26 27廿二 地球日 廿四 廿五 廿六 廿七 廿八休 休 休 班28 29 30 1 2 3 4廿九 初一 初二 劳动节 初四 初五 五四青..5 6 7 8 9 10 11立夏 初八 初九 初十 十一 十二 母亲节

11

三月十二甲午年 [马年】戊辰月 壬子日

宜嫁娅壮π蚀

忌亚烷妹断垛竭 开张

# Thank You Using data to solve problems