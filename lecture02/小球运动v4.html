<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>物理仿真小球-完整版</title>
    <style>
        canvas {
            border: 1px solid #ddd;
            background: #f8f9fa;
        }
        #restartBtn {
            padding: 10px 25px;
            margin: 15px;
            background: #007bff;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: transform 0.2s;
        }
        #restartBtn:hover {
            transform: scale(1.05);
            background: #0056b3;
        }
    </style>
</head>
<body>
    <button id="restartBtn">重新开始</button>
    <canvas id="gameCanvas" width="800" height="600"></canvas>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        let animationFrame;

        // 物理常量
        const PHYSICS = {
            gravity: 0.5,        // 重力加速度 (px/frame²)
            bounceFactor: 0.85,  // 反弹系数
            baseSpeed: 12,       // 初始速度基准值
            friction: 0.99,      // 空气阻力
            floorBounce: 0.9     // 底边反弹系数
        };

        // 三角形定义（等边三角形）
        const TRIANGLE = {
            top: { x: 400, y: 100 },
            left: { x: 150, y: 500 },
            right: { x: 650, y: 500 }
        };

        // 小球初始状态
        let ball = {
            x: 400,
            y: 300,
            radius: 10,
            velocityX: 0,
            velocityY: 0,
            color: '#ff4757'
        };

        // 初始化物理系统
        function initPhysics() {
            // 生成随机方向（弧度）
            const angle = Math.random() * Math.PI * 2;
            
            // 设置初始速度
            ball.velocityX = Math.cos(angle) * PHYSICS.baseSpeed;
            ball.velocityY = Math.sin(angle) * PHYSICS.baseSpeed;
        }

        // 绘制三角形
        function drawTriangle() {
            ctx.beginPath();
            ctx.moveTo(TRIANGLE.top.x, TRIANGLE.top.y);
            ctx.lineTo(TRIANGLE.left.x, TRIANGLE.left.y);
            ctx.lineTo(TRIANGLE.right.x, TRIANGLE.right.y);
            ctx.closePath();
            ctx.strokeStyle = '#2d3436';
            ctx.lineWidth = 3;
            ctx.stroke();
        }

        // 边界碰撞检测（向量法）
        function checkCollisions() {
            const edges = [
                { a: TRIANGLE.top, b: TRIANGLE.left },   // 左边
                { a: TRIANGLE.top, b: TRIANGLE.right },  // 右边
                { a: TRIANGLE.left, b: TRIANGLE.right }  // 底边
            ];

            edges.forEach(edge => {
                // 计算边向量
                const edgeVec = {
                    x: edge.b.x - edge.a.x,
                    y: edge.b.y - edge.a.y
                };

                // 计算法线向量（指向三角形内部）
                const normal = normalize({
                    x: edgeVec.y,
                    y: -edgeVec.x
                });

                // 计算小球到边的距离
                const ballToEdge = {
                    x: ball.x - edge.a.x,
                    y: ball.y - edge.a.y
                };
                const distance = dotProduct(ballToEdge, normal);

                // 碰撞处理
                if (distance < ball.radius) {
                    // 位置修正
                    const penetration = ball.radius - distance;
                    ball.x += normal.x * penetration * 1.1;
                    ball.y += normal.y * penetration * 1.1;

                    // 速度分解
                    const velocity = {
                        x: ball.velocityX,
                        y: ball.velocityY
                    };
                    
                    // 法线方向速度（用于反弹）
                    const normalSpeed = dotProduct(velocity, normal);
                    
                    // 切向速度（保持不变）
                    const tangentSpeed = {
                        x: velocity.x - normal.x * normalSpeed,
                        y: velocity.y - normal.y * normalSpeed
                    };

                    // 应用反弹（考虑不同边的系数）
                    const bounce = edge === edges[2] ? PHYSICS.floorBounce : PHYSICS.bounceFactor;
                    ball.velocityX = tangentSpeed.x - normal.x * normalSpeed * bounce;
                    ball.velocityY = tangentSpeed.y - normal.y * normalSpeed * bounce;
                }
            });
        }

        // 向量点积
        function dotProduct(v1, v2) {
            return v1.x * v2.x + v1.y * v2.y;
        }

        // 向量归一化
        function normalize(v) {
            const length = Math.sqrt(v.x**2 + v.y**2);
            return length > 0 ? { x: v.x/length, y: v.y/length } : { x: 0, y: 0 };
        }

        // 更新物理状态
        function updatePhysics() {
            // 应用重力
            ball.velocityY += PHYSICS.gravity;
            
            // 应用空气阻力
            ball.velocityX *= PHYSICS.friction;
            ball.velocityY *= PHYSICS.friction;

            // 更新位置
            ball.x += ball.velocityX;
            ball.y += ball.velocityY;

            // 边界碰撞检测
            checkCollisions();
        }

        // 绘制小球
        function drawBall() {
            ctx.beginPath();
            ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
            ctx.fillStyle = ball.color;
            
            // 添加立体效果
            const gradient = ctx.createRadialGradient(
                ball.x - 3, ball.y - 3, 2,
                ball.x, ball.y, ball.radius
            );
            gradient.addColorStop(0, '#ff6b81');
            gradient.addColorStop(1, '#ff4757');
            ctx.fillStyle = gradient;
            
            ctx.fill();
        }

        // 主动画循环
        function animate() {
            ctx.fillStyle = 'rgba(248, 249, 250, 0.3)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            updatePhysics();
            drawTriangle();
            drawBall();
            
            animationFrame = requestAnimationFrame(animate);
        }

        // 重置系统
        function resetSystem() {
            cancelAnimationFrame(animationFrame);
            
            // 重置小球位置
            ball.x = 400;
            ball.y = 300;
            
            // 重新初始化物理
            initPhysics();
            
            // 清除画布
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            animate();
        }

        // 事件绑定
        document.getElementById('restartBtn').addEventListener('click', resetSystem);

        // 启动系统
        initPhysics();
        animate();
    </script>
</body>
</html>