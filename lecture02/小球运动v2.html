<!DOCTYPE html>
<html>
<head>
    <style>
        canvas {
            border: 1px solid #ddd;
        }
        #restartBtn {
            padding: 8px 20px;
            margin: 10px;
            background: #4CAF50;
            color: white;
            border: none;
            cursor: pointer;
        }
    </style>
</head>
<body>
    <button id="restartBtn">重新开始</button>
    <canvas id="gameCanvas" width="600" height="400"></canvas>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        let animationId;
        
        // 三角形顶点坐标
        const triangle = {
            top: { x: 300, y: 50 },
            left: { x: 100, y: 350 },
            right: { x: 500, y: 350 }
        };

        // 小球初始状态
        let ball = {
            x: 300,
            y: 200,
            radius: 8,
            speedX: 0,
            speedY: 0,
            color: '#FF0000',
            isMoving: false
        };

        // 物理参数
        const bounceFactor = 0.92;
        const initialSpeed = 4;

        // 绘制三角形
        function drawTriangle() {
            ctx.beginPath();
            ctx.moveTo(triangle.top.x, triangle.top.y);
            ctx.lineTo(triangle.left.x, triangle.left.y);
            ctx.lineTo(triangle.right.x, triangle.right.y);
            ctx.closePath();
            ctx.strokeStyle = '#333';
            ctx.stroke();
        }

        // 精确碰撞检测与反射
        function handleCollisions() {
            // 检测三条边的碰撞
            checkEdgeCollision(triangle.top, triangle.left);  // 左侧边
            checkEdgeCollision(triangle.top, triangle.right); // 右侧边
            checkEdgeCollision(triangle.left, triangle.right);// 底边
        }

        function checkEdgeCollision(p1, p2) {
            // 计算边向量
            const edgeVec = { x: p2.x - p1.x, y: p2.y - p1.y };
            // 计算边的法线向量（单位向量）
            const normal = normalize({ x: -edgeVec.y, y: edgeVec.x });
            
            // 计算小球到边的投影
            const ballToP1 = { x: ball.x - p1.x, y: ball.y - p1.y };
            const distance = dotProduct(ballToP1, normal);
            
            // 碰撞检测（考虑小球半径）
            if (distance < ball.radius) {
                // 位置修正
                ball.x -= normal.x * (distance - ball.radius);
                ball.y -= normal.y * (distance - ball.radius);
                
                // 速度反射计算
                const speed = [ball.speedX, ball.speedY];
                const dot = 2 * dotProduct(speed, normal);
                ball.speedX = (speed[0] - dot * normal.x) * bounceFactor;
                ball.speedY = (speed[1] - dot * normal.y) * bounceFactor;
            }
        }

        // 向量工具函数
        function dotProduct(v1, v2) {
            return v1.x * v2.x + v1.y * v2.y;
        }

        function normalize(v) {
            const len = Math.sqrt(v.x*v.x + v.y*v.y);
            return { x: v.x/len, y: v.y/len };
        }

        // 动画循环
        function animate() {
            ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            if (ball.isMoving) {
                ball.x += ball.speedX;
                ball.y += ball.speedY;
                handleCollisions();
            }
            
            drawTriangle();
            ctx.beginPath();
            ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI*2);
            ctx.fillStyle = ball.color;
            ctx.fill();
            
            animationId = requestAnimationFrame(animate);
        }

        // 初始化抛射
        function startMovement() {
            if (!ball.isMoving) {
                ball.isMoving = true;
                // 随机初始方向
                const angle = Math.random() * Math.PI * 2;
                ball.speedX = Math.cos(angle) * initialSpeed;
                ball.speedY = Math.sin(angle) * initialSpeed;
            }
        }

        // 重置状态
        function resetBall() {
            cancelAnimationFrame(animationId);
            ball = {
                x: 300,
                y: 200,
                radius: 8,
                speedX: 0,
                speedY: 0,
                color: '#FF0000',
                isMoving: false
            };
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            animate();
        }

        // 事件绑定
        document.getElementById('restartBtn').addEventListener('click', () => {
            resetBall();
            setTimeout(startMovement, 100);
        });

        // 首次启动
        animate();
        startMovement();
    </script>
</body>
</html>