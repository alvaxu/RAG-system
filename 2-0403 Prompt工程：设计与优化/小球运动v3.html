<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>三角形边界小球运动-稳定版</title>
    <style>
        canvas {
            border: 1px solid #ddd;
            background: white;
        }
        #restartBtn {
            padding: 8px 20px;
            margin: 10px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.3s;
        }
        #restartBtn:hover {
            background: #45a049;
        }
    </style>
</head>
<body>
    <button id="restartBtn">重新开始</button>
    <canvas id="gameCanvas" width="600" height="400"></canvas>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        let animationId;
        
        // 三角形定义（确保坐标有效性）
        const triangle = {
            top: { x: 300, y: 50 },
            left: { x: 100, y: 350 },
            right: { x: 500, y: 350 }
        };

        // 小球初始参数（带边界保护）
        const ballConfig = {
            x: 300,
            y: 200,
            radius: 8,
            speedX: 3,
            speedY: 3,
            color: '#FF0000',
            get center() {
                return { x: this.x, y: this.y }
            }
        };
        let ball = {...ballConfig};

        // 物理参数（带范围限制）
        const physics = {
            bounceFactor: 0.92,
            maxSpeed: 8,
            minSpeed: 2
        };

        // 绘制三角形边框（修复描边问题）
        function drawTriangle() {
            ctx.save(); // 保存绘图状态
            ctx.beginPath();
            ctx.moveTo(triangle.top.x, triangle.top.y);
            ctx.lineTo(triangle.left.x, triangle.left.y);
            ctx.lineTo(triangle.right.x, triangle.right.y);
            ctx.closePath();
            ctx.lineWidth = 2;
            ctx.strokeStyle = '#333';
            ctx.stroke();
            ctx.restore(); // 恢复绘图状态
        }

        // 碰撞检测与处理（带速度限制）
        function handleCollisions() {
            const edges = [
                [triangle.top, triangle.left],
                [triangle.top, triangle.right], 
                [triangle.left, triangle.right]
            ];

            edges.forEach(([p1, p2]) => {
                const edgeVec = { x: p2.x - p1.x, y: p2.y - p1.y };
                const normal = normalize({ 
                    x: p1.y - p2.y, 
                    y: p2.x - p1.x 
                });

                const ballToEdge = { 
                    x: ball.x - p1.x, 
                    y: ball.y - p1.y 
                };
                const distance = dotProduct(ballToEdge, normal);
                
                if (distance < ball.radius) {
                    // 位置修正
                    ball.x += normal.x * (ball.radius - distance);
                    ball.y += normal.y * (ball.radius - distance);
                    
                    // 速度反射
                    const speed = dotProduct(normal, {x: ball.speedX, y: ball.speedY});
                    if (speed < 0) {
                        ball.speedX = Math.min(physics.maxSpeed, 
                            Math.max(-physics.maxSpeed, 
                                (ball.speedX - 2 * speed * normal.x) * physics.bounceFactor));
                        ball.speedY = Math.min(physics.maxSpeed, 
                            Math.max(-physics.maxSpeed, 
                                (ball.speedY - 2 * speed * normal.y) * physics.bounceFactor));
                    }
                }
            });
        }

        // 向量工具函数
        function dotProduct(v1, v2) {
            return v1.x * v2.x + v1.y * v2.y;
        }

        function normalize(v) {
            const len = Math.sqrt(v.x**2 + v.y**2);
            return len > 0 ? { x: v.x/len, y: v.y/len } : { x: 0, y: 0 };
        }

        // 动画主循环（固定绘制顺序）
        function animate() {
            ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // 先绘制三角形边框
            drawTriangle();
            
            // 更新小球状态
            ball.x += ball.speedX;
            ball.y += ball.speedY;
            handleCollisions();
            
            // 绘制小球
            ctx.beginPath();
            ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI*2);
            ctx.fillStyle = ball.color;
            ctx.fill();
            
            animationId = requestAnimationFrame(animate);
        }

        // 可靠的重置功能
        function resetBall() {
            cancelAnimationFrame(animationId);
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ball = {...ballConfig};
            animate();
        }

        // 事件绑定（带防抖处理）
        document.getElementById('restartBtn').addEventListener('click', () => {
            resetBall();
        });

        // 初始化执行
        drawTriangle(); // 初始绘制边框
        animate();
    </script>
</body>
</html>